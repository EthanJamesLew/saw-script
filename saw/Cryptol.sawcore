--------------------------------------------------------------------------------
-- Cryptol primitives for SAWCore

module Cryptol where

import Prelude;

--------------------------------------------------------------------------------
-- Additional operations on Prelude types

pairMap :: (a1 b1 a2 b2 :: sort 0) -> (a1 -> b1) -> (a2 -> b2) -> #(a1, a2) -> #(b1, b2);
pairMap _ _ _ _ f g (x, y) = (f x, g y);

pairMap2 :: (a1 b1 c1 a2 b2 c2 :: sort 0) -> (a1 -> b1 -> c1) -> (a2 -> b2 -> c2) -> #(a1, a2) -> #(b1, b2) -> #(c1, c2);
pairMap2 _ _ _ _ _ _ f1 f2 (x1, x2) (y1, y2) = (f1 x1 y1, f2 x2 y2);

compose :: (a b c :: sort 0) -> (b -> c) -> (a -> b) -> (a -> c);
compose _ _ _ f g x = f (g x);

fix :: (a :: sort 0) -> (a -> a) -> a;
fix a f = let { x :: a; x = f x; } in x;

bvExp :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
bvExp n x y = foldr Bool (bitvector n) n
  (\ (b :: Bool) -> \ (a :: bitvector n) ->
    ite (bitvector n) b (bvMul n x (bvMul n a a)) (bvMul n a a))
  (bvNat n 1)
  (reverse n Bool y);

--------------------------------------------------------------------------------
-- Extended natural numbers

data Num :: sort 0 where {
    TCNum :: Nat -> Num;
    TCInf :: Num;
  }

tcWidth :: Num -> Num;
tcWidth (TCNum n) = TCNum (widthNat n);
tcWidth TCInf = TCInf;

tcAdd :: Num -> Num -> Num;
tcAdd (TCNum x) (TCNum y) = TCNum (addNat x y);
tcAdd (TCNum _) TCInf = TCInf;
tcAdd TCInf _ = TCInf;

tcSub :: Num -> Num -> Num;
tcSub (TCNum x) (TCNum y) = TCNum (subNat x y);
tcSub TCInf (TCNum _) = TCInf;
-- other cases are undefined

tcMul :: Num -> Num -> Num;
tcMul (TCNum x) (TCNum y) = TCNum (mulNat x y);
tcMul (TCNum x) TCInf = ite Num (equalNat 0 x) (TCNum 0) TCInf;
tcMul TCInf (TCNum y) = ite Num (equalNat 0 y) (TCNum 0) TCInf;
tcMul TCInf TCInf = TCInf;

tcDiv :: Num -> Num -> Num;
tcDiv (TCNum x) (TCNum y) = TCNum ((divModNat x y).1);
tcDiv (TCNum _) TCInf = TCNum Zero;
-- other cases undefined

tcMod :: Num -> Num -> Num;
tcMod (TCNum x) (TCNum y) = TCNum ((divModNat x y).2);
tcMod (TCNum x) TCInf = TCNum x;
-- other cases undefined

tcExp :: Num -> Num -> Num;
tcExp (TCNum Zero) _ = TCNum Zero;
tcExp (TCNum (Succ Zero)) _ = TCNum (Succ Zero);
tcExp _ (TCNum Zero) = TCNum (Succ Zero);
tcExp (TCNum x) (TCNum y) = TCNum (expNat x y);
-- other cases undefined

tcMin :: Num -> Num -> Num;
tcMin (TCNum x) (TCNum y) = TCNum (minNat x y);
tcMin (TCNum x) TCInf = TCNum x;
tcMin TCInf (TCNum y) = TCNum y;
tcMin TCInf TCInf = TCInf;

tcMax :: Num -> Num -> Num;
tcMax (TCNum x) (TCNum y) = TCNum (maxNat x y);
tcMax (TCNum _) TCInf = TCInf;
tcMax TCInf (TCNum _) = TCInf;
tcMax TCInf TCInf = TCInf;

tcLenFromThen_Nat :: Nat -> Nat -> Nat -> Nat;
tcLenFromThen_Nat x y w =
  tcLenFromThenTo_Nat x y (ite Nat (ltNat x y) (subNat (expNat 2 w) 1) 0);

tcLenFromThenTo_Nat :: Nat -> Nat -> Nat -> Nat;
tcLenFromThenTo_Nat x y z =
  ite Nat (ltNat x y)
    (ite Nat (ltNat z x) 0 (addNat (divNat (subNat z x) (subNat y x)) 1)) -- increasing
    (ite Nat (ltNat x z) 0 (addNat (divNat (subNat x z) (subNat x y)) 1)); -- decreasing

tcLenFromThen :: Num -> Num -> Num -> Num;
tcLenFromThen (TCNum x) (TCNum y) (TCNum w) = TCNum (tcLenFromThen_Nat x y w);
-- tcLenFromThen is undefined on TCInf

tcLenFromThenTo :: Num -> Num -> Num -> Num;
tcLenFromThenTo (TCNum x) (TCNum y) (TCNum z) = TCNum (tcLenFromThenTo_Nat x y z);
-- tcLenFromThenTo is undefined on TCInf

--------------------------------------------------------------------------------
-- Possibly infinite sequences

seq :: Num -> sort 0 -> sort 0;
seq (TCNum n) a = Vec n a;
seq TCInf a = Stream a;

seqMap :: (a b :: sort 0) -> (n :: Num) -> (a -> b) -> seq n a -> seq n b;
seqMap a b (TCNum n) f = map a b f n;
seqMap a b TCInf f = streamMap a b f;

seqConst :: (n :: Num) -> (a :: sort 0) -> a -> seq n a;
seqConst (TCNum n) = replicate n;
seqConst TCInf = streamConst;

--------------------------------------------------------------------------------
-- Types

data KType :: sort 0 where {
    TCBit :: KType;
    TCInteger :: KType;
    TCSeq :: Num -> KType -> KType;
    TCFun :: KType -> KType -> KType;
    TCUnit :: KType;
    TCPair :: KType -> KType -> KType;
    TCEmpty :: KType;
    TCField :: String -> KType -> KType -> KType;
  }

ty :: KType -> sort 0;
ty TCBit = Bool;
ty TCInteger = Integer;
ty (TCSeq n a) = seq n (ty a);
ty (TCFun a b) = ty a -> ty b;
ty TCUnit = #();
ty (TCPair a b) = #(ty a | ty b);
ty TCEmpty = #{};
ty (TCField s a b) = #{ (s) :: ty a | ty b };

--------------------------------------------------------------------------------
-- Predicate symbols

-- Partial functions to select instances (terms translated from
-- type-correct Cryptol should never hit the undefined cases)

ePArith :: (a :: KType) -> PArith a;
--ePArith TCBit = undefined;
--ePArith (TCSeq TCInf TCBit) = undefined;
ePArith TCInteger = PArithInteger;
ePArith (TCSeq n TCBit) = PArithWord n;
ePArith (TCSeq n (TCSeq m a)) = PArithSeq n (TCSeq m a) (ePArith (TCSeq m a));
ePArith (TCSeq n (TCFun a b)) = PArithSeq n (TCFun a b) (ePArith (TCFun a b));
ePArith (TCSeq n TCUnit) = PArithSeq n TCUnit (ePArith TCUnit);
ePArith (TCSeq n (TCPair a b)) = PArithSeq n (TCPair a b) (ePArith (TCPair a b));
ePArith (TCSeq n TCEmpty) = PArithSeq n TCEmpty (ePArith TCEmpty);
ePArith (TCSeq n (TCField s a b)) = PArithSeq n (TCField s a b) (ePArith (TCField s a b));
ePArith (TCFun a b) = PArithFun a b (ePArith b);
ePArith TCUnit = PArithUnit;
ePArith (TCPair a b) = PArithPair a b (ePArith a) (ePArith b);
ePArith TCEmpty = PArithEmpty;
ePArith (TCField s a b) = PArithField s a b (ePArith a) (ePArith b);

ePCmp :: (a :: KType) -> PCmp a;
--ePCmp (TCSeq TCInf a) = undefined;
ePCmp (TCSeq n TCBit) = PCmpWord n;
ePCmp (TCSeq n TCInteger) = PCmpSeq n TCInteger (ePCmp TCInteger);
ePCmp (TCSeq n (TCSeq m a)) = PCmpSeq n (TCSeq m a) (ePCmp (TCSeq m a));
--ePCmp (TCSeq (TCNum n) (TCFun a b)) = PCmpSeq n (TCFun a b) (ePCmp (TCFun a b));
ePCmp (TCSeq n TCUnit) = PCmpSeq n TCUnit (ePCmp TCUnit);
ePCmp (TCSeq n (TCPair a b)) = PCmpSeq n (TCPair a b) (ePCmp (TCPair a b));
ePCmp (TCSeq n TCEmpty) = PCmpSeq n TCEmpty (ePCmp TCEmpty);
ePCmp (TCSeq n (TCField s a b)) = PCmpSeq n (TCField s a b) (ePCmp (TCField s a b));
ePCmp TCBit = PCmpBit;
ePCmp TCInteger = PCmpInteger;
--ePCmp (TCFun a b) = undefined;
ePCmp TCUnit = PCmpUnit;
ePCmp (TCPair a b) = PCmpPair a b (ePCmp a) (ePCmp b);
ePCmp TCEmpty = PCmpEmpty;
ePCmp (TCField s a b) = PCmpField s a b (ePCmp a) (ePCmp b);

--------------------------------------------------------------------------------
-- Auxiliary functions

eListSel :: (a :: sort 0) -> (n :: Num) -> seq n a -> Nat -> a;
eListSel a (TCNum n) xs i = at n a xs i;
eListSel a TCInf xs i = streamGet a xs i;

--------------------------------------------------------------------------------
-- List comprehensions

from :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> (a -> seq n b) -> seq (tcMul m n) #(a, b);
from a b (TCNum m) (TCNum n) =
  \ (xs :: Vec m a) ->
  \ (k :: a -> Vec n b) ->
  join m n #(a, b)
  (map a (Vec n #(a, b))
    (\(x :: a) -> map b #(a, b) (\(y :: b) -> (x, y)) n (k x))
    m xs);

from a b (TCNum m) TCInf =
  natCase
    (\ (m'::Nat) -> (Vec m' a -> (a -> Stream b) ->
        seq (ite Num (equalNat 0 m') (TCNum 0) TCInf) #(a, b)))
      (\ (xs :: Vec 0 a) ->
       \ (k :: a -> Stream b) -> EmptyVec #(a, b))
      (\ (m' :: Nat) ->
       \ (xs :: Vec (Succ m') a) ->
       \ (k :: a -> Stream b) ->
        (\ (x :: a) -> streamMap b #(a, b) (\ (y::b) -> (x, y)) (k x))
        (at (Succ m') a xs 0))
      m;

from a b TCInf (TCNum n) =
  natCase
    (\ (n'::Nat) -> (Stream a -> (a -> Vec n' b) ->
        seq (ite Num (equalNat 0 n') (TCNum 0) TCInf) #(a, b)))
      (\ (xs :: Stream a) ->
       \ (k :: a -> Vec 0 b) -> EmptyVec #(a, b))
      (\ (n' :: Nat) ->
       \ (xs :: Stream a) ->
       \ (k :: a -> Vec (Succ n') b) ->
         streamJoin #(a, b) n'
         (streamMap a (Vec (Succ n') #(a, b))
           (\ (x::a) -> map b #(a, b) (\ (y::b) -> (x, y)) (Succ n') (k x))
           xs))
      n;

from a b TCInf TCInf =
  \ (xs :: Stream a) ->
  \ (k :: a -> Stream b) ->
    (\ (x :: a) -> streamMap b #(a, b) (\ (y :: b) -> (x, y)) (k x))
    (streamGet a xs 0);

mlet :: (a b :: sort 0) -> (n :: Num) -> a -> (a -> seq n b) -> seq n #(a, b);
mlet a b (TCNum n) x f = map b #(a, b) (\(y :: b) -> (x, y)) n (f x);
mlet a b TCInf x f = streamMap b #(a, b) (\(y :: b) -> (x, y)) (f x);

seqZip :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> seq n b -> seq (tcMin m n) #(a, b);
seqZip a b (TCNum m) (TCNum n) xs ys = zip a b m n xs ys;
seqZip a b (TCNum m) TCInf xs ys = gen m #(a, b) (\(i :: Nat) -> (at m a xs i, streamGet b ys i));
seqZip a b TCInf (TCNum n) xs ys = gen n #(a, b) (\(i :: Nat) -> (streamGet a xs i, at n b ys i));
seqZip a b TCInf TCInf xs ys = streamMap2 a b #(a, b) (\(x::a) -> \(y::b) -> (x, y)) xs ys;

--------------------------------------------------------------------------------
-- Arith functions

seqBinary :: (n :: Num) -> (a :: sort 0) -> (a -> a -> a) -> seq n a -> seq n a -> seq n a;
seqBinary (TCNum n) a f = zipWith a a a f n;
seqBinary TCInf a f = streamMap2 a a a f;

unitUnary :: #() -> #();
unitUnary _ = ();

emptyUnary :: #{} -> #{};
emptyUnary _ = {};

unitBinary :: #() -> #() -> #();
unitBinary _ _ = ();

pairUnary :: (a b :: sort 0) -> (a -> a) -> (b -> b) -> #(a | b) -> #(a | b);
pairUnary _ _ f g (x | y) = (f x | g y);

pairBinary :: (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b)
           -> #(a | b) -> #(a | b) -> #(a | b);
pairBinary a b f g (x1 | x2) (y1 | y2) = (f x1 y1 | g x2 y2);

emptyBinary :: #{} -> #{} -> #{};
emptyBinary _ _ = {};

fieldUnary :: (s :: String) -> (a b :: sort 0) -> (a -> a) -> (b -> b)
         -> #{ (s) :: a | b } -> #{ (s) :: a | b };
fieldUnary s _ _ f g { (_) = x | y } = { (s) = f x | g y };

fieldBinary :: (s :: String) -> (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b)
            -> #{ (s) :: a | b } -> #{ (s) :: a | b } -> #{ (s) :: a | b };
fieldBinary s a b f g { (_) = x1 | x2 } { (_) = y1 | y2 } = { (s) = f x1 y1 | g x2 y2 };

funBinary :: (a b :: sort 0) -> (b -> b -> b) -> (a -> b) -> (a -> b) -> (a -> b);
funBinary a b op f g x = op (f x) (g x);

PArith :: KType -> sort 0;
PArith a =
  #{ add :: ty a -> ty a -> ty a
   , sub :: ty a -> ty a -> ty a
   , mul :: ty a -> ty a -> ty a
   , div :: ty a -> ty a -> ty a
   , mod :: ty a -> ty a -> ty a
   , exp :: ty a -> ty a -> ty a
   , lg2 :: ty a -> ty a
   , neg :: ty a -> ty a
   };

PArithInteger :: PArith TCInteger;
PArithInteger =
  { add = intAdd
  , sub = intSub
  , mul = intMul
  , div = intDiv
  , mod = intMod
  , exp = error (Integer -> Integer -> Integer) "unimplemented: intExp"
  , lg2 = error (Integer -> Integer) "unimplemented: intLg2"
  , neg = intNeg
  };

PArithWord :: (n :: Num) -> PArith (TCSeq n TCBit);
PArithWord (TCNum n) =
  { add = bvAdd n
  , sub = bvSub n
  , mul = bvMul n
  , div = bvUDiv n
  , mod = bvURem n
  , exp = bvExp n
  , lg2 = bvLg2 n
  , neg = bvNeg n
  };

PArithSeq :: (n :: Num) -> (a :: KType) -> PArith a -> PArith (TCSeq n a);
PArithSeq n a pa =
  { add = seqBinary n (ty a) pa.add
  , sub = seqBinary n (ty a) pa.sub
  , mul = seqBinary n (ty a) pa.mul
  , div = seqBinary n (ty a) pa.div
  , mod = seqBinary n (ty a) pa.mod
  , exp = seqBinary n (ty a) pa.exp
  , lg2 = seqMap (ty a) (ty a) n pa.lg2
  , neg = seqMap (ty a) (ty a) n pa.neg
  };

PArithFun :: (a b :: KType) -> PArith b -> PArith (TCFun a b);
PArithFun a b pb =
  { add = funBinary (ty a) (ty b) pb.add
  , sub = funBinary (ty a) (ty b) pb.sub
  , mul = funBinary (ty a) (ty b) pb.mul
  , div = funBinary (ty a) (ty b) pb.div
  , mod = funBinary (ty a) (ty b) pb.mod
  , exp = funBinary (ty a) (ty b) pb.exp
  , lg2 = compose (ty a) (ty b) (ty b) pb.lg2
  , neg = compose (ty a) (ty b) (ty b) pb.neg
  };

PArithUnit :: PArith TCUnit;
PArithUnit =
  { add = unitBinary
  , sub = unitBinary
  , mul = unitBinary
  , div = unitBinary
  , mod = unitBinary
  , exp = unitBinary
  , lg2 = unitUnary
  , neg = unitUnary
  };

PArithPair :: (a b :: KType) -> PArith a -> PArith b -> PArith (TCPair a b);
PArithPair a b pa pb =
  { add = pairBinary (ty a) (ty b) pa.add pb.add
  , sub = pairBinary (ty a) (ty b) pa.sub pb.sub
  , mul = pairBinary (ty a) (ty b) pa.mul pb.mul
  , div = pairBinary (ty a) (ty b) pa.div pb.div
  , mod = pairBinary (ty a) (ty b) pa.mod pb.mod
  , exp = pairBinary (ty a) (ty b) pa.exp pb.exp
  , lg2 = pairUnary (ty a) (ty b) pa.lg2 pb.lg2
  , neg = pairUnary (ty a) (ty b) pa.neg pb.neg
  };

PArithEmpty :: PArith TCEmpty;
PArithEmpty =
  { add = emptyBinary
  , sub = emptyBinary
  , mul = emptyBinary
  , div = emptyBinary
  , mod = emptyBinary
  , exp = emptyBinary
  , lg2 = emptyUnary
  , neg = emptyUnary
  };

PArithField :: (s :: String) -> (a b :: KType) -> PArith a -> PArith b -> PArith (TCField s a b);
PArithField s a b pa pb =
  { add = fieldBinary s (ty a) (ty b) pa.add pb.add
  , sub = fieldBinary s (ty a) (ty b) pa.sub pb.sub
  , mul = fieldBinary s (ty a) (ty b) pa.mul pb.mul
  , div = fieldBinary s (ty a) (ty b) pa.div pb.div
  , mod = fieldBinary s (ty a) (ty b) pa.mod pb.mod
  , exp = fieldBinary s (ty a) (ty b) pa.exp pb.exp
  , lg2 = fieldUnary s (ty a) (ty b) pa.lg2 pb.lg2
  , neg = fieldUnary s (ty a) (ty b) pa.neg pb.neg
  };

logicBinary :: ((n :: Nat) -> bitvector n -> bitvector n -> bitvector n)
            -> (Bool -> Bool -> Bool)
            -> (a :: KType) -> ty a -> ty a -> ty a;
logicBinary bvOp bitOp TCBit = bitOp;
logicBinary bvOp bitOp TCInteger = error (Integer -> Integer -> Integer) "logicBinary/Integer";
logicBinary bvOp bitOp (TCFun a b) = funBinary (ty a) (ty b) (logicBinary bvOp bitOp b);
logicBinary bvOp bitOp TCUnit = unitBinary;
logicBinary bvOp bitOp (TCPair a b) =
  pairBinary (ty a) (ty b) (logicBinary bvOp bitOp a) (logicBinary bvOp bitOp b);
logicBinary bvOp bitOp TCEmpty = emptyBinary;
logicBinary bvOp bitOp (TCField s a b) =
  fieldBinary s (ty a) (ty b) (logicBinary bvOp bitOp a) (logicBinary bvOp bitOp b);
logicBinary bvOp bitOp (TCSeq (TCNum n) TCBit) = bvOp n;
logicBinary bvOp bitOp (TCSeq TCInf TCBit) = streamMap2 Bool Bool Bool bitOp;
logicBinary bvOp bitOp (TCSeq n (TCSeq m a)) =
   seqBinary n (seq m (ty a)) (logicBinary bvOp bitOp (TCSeq m a));
logicBinary bvOp bitOp (TCSeq n (TCFun a b)) =
   seqBinary n (ty a -> ty b) (logicBinary bvOp bitOp (TCFun a b));
logicBinary bvOp bitOp (TCSeq n TCUnit) = seqBinary n #() unitBinary;
logicBinary bvOp bitOp (TCSeq n (TCPair a b)) =
   seqBinary n #(ty a | ty b) (logicBinary bvOp bitOp (TCPair a b));
logicBinary bvOp bitOp (TCSeq n TCEmpty) = seqBinary n #{} emptyBinary;
logicBinary bvOp bitOp (TCSeq n (TCField s a b)) =
   seqBinary n (ty (TCField s a b)) (logicBinary bvOp bitOp (TCField s a b));

--------------------------------------------------------------------------------
-- Comparisons

boolCmp :: Bool -> Bool -> Bool -> Bool;
boolCmp x y k = ite Bool x (and y k) (or y k);

integerCmp :: Integer -> Integer -> Bool -> Bool;
integerCmp x y k = or (intLt x y) (and (intEq x y) k);

bvCmp :: (n :: Nat) -> bitvector n -> bitvector n -> Bool -> Bool;
bvCmp n x y k = or (bvult n x y) (and (bvEq n x y) k);

vecCmp :: (n :: Nat) -> (a :: sort 0) -> (a -> a -> Bool -> Bool)
       -> (Vec n a -> Vec n a -> Bool -> Bool);
vecCmp n a f xs ys k =
  foldr (Bool -> Bool) Bool n (\(f :: Bool -> Bool) -> f) k
    (zipWith a a (Bool -> Bool) f n xs ys);

unitCmp :: #() -> #() -> Bool -> Bool;
unitCmp _ _ _ = False;

emptyCmp :: #{} -> #{} -> Bool -> Bool;
emptyCmp _ _ _ = False;

pairCmp :: (a b :: sort 0) -> (a -> a -> Bool -> Bool) -> (b -> b -> Bool -> Bool)
        -> #(a | b) -> #(a | b) -> Bool -> Bool;
pairCmp a b f g (x1 | x2) (y1 | y2) k = f x1 y1 (g x2 y2 k);

fieldCmp :: (s :: String) -> (a b :: sort 0)
         -> (a -> a -> Bool -> Bool) -> (b -> b -> Bool -> Bool)
         -> #{ (s) :: a | b } -> #{ (s) :: a | b } -> Bool -> Bool;
fieldCmp s a b f g { (_) = x1 | x2 } { (_) = y1 | y2 } k = f x1 y1 (g x2 y2 k);

PCmp :: KType -> sort 0;
PCmp a = #{ cmpLt :: ty a -> ty a -> Bool -> Bool };

PCmpWord :: (n :: Num) -> PCmp (TCSeq n TCBit);
PCmpWord (TCNum n) = { cmpLt = bvCmp n };

PCmpBit :: PCmp TCBit;
PCmpBit = { cmpLt = boolCmp };

PCmpInteger :: PCmp TCInteger;
PCmpInteger = { cmpLt = integerCmp };

PCmpSeq :: (n :: Num) -> (a :: KType) -> PCmp a -> PCmp (TCSeq n a);
PCmpSeq (TCNum n) a pa = { cmpLt = vecCmp n (ty a) pa.cmpLt };

PCmpUnit :: PCmp TCUnit;
PCmpUnit = { cmpLt = unitCmp };

PCmpPair :: (a b :: KType) -> PCmp a -> PCmp b -> PCmp (TCPair a b);
PCmpPair a b pa pb = { cmpLt = pairCmp (ty a) (ty b) pa.cmpLt pb.cmpLt };

PCmpEmpty :: PCmp TCEmpty;
PCmpEmpty = { cmpLt = emptyCmp };

PCmpField :: (s :: String) -> (a b :: KType) -> PCmp a -> PCmp b -> PCmp (TCField s a b);
PCmpField s a b pa pb = { cmpLt = fieldCmp s (ty a) (ty b) pa.cmpLt pb.cmpLt };

--------------------------------------------------------------------------------
-- Primitive Cryptol functions

ecDemote :: (val bits :: Num) -> seq bits Bool;
ecDemote (TCNum val) (TCNum bits) = bvNat bits val;

ecInteger :: (val :: Num) -> Integer;
ecInteger (TCNum val) = natToInt val;

ecToInteger :: (n :: Num) -> seq n Bool -> Integer;
ecToInteger (TCNum n) = bvToInt n;

ecFromInteger :: (n :: Num) -> Integer -> seq n Bool;
ecFromInteger (TCNum n) = intToBv n;

-- Arith
ecPlus :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecPlus a pa = pa.add;

ecMinus :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMinus a pa = pa.sub;

ecMul :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMul a pa = pa.mul;

ecDiv :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecDiv a pa = pa.div;

ecMod :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMod a pa = pa.mod;

ecExp :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecExp a pa = pa.exp;

ecLg2 :: (a :: KType) -> PArith a -> ty a -> ty a;
ecLg2 a pa = pa.lg2;

ecNeg :: (a :: KType) -> PArith a -> ty a -> ty a;
ecNeg a pa = pa.neg;

-- Cmp
ecLt :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecLt a pa x y = pa.cmpLt x y False;

ecGt :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecGt a pa x y = ecLt a pa y x;

ecLtEq  :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecLtEq a pa x y = not (ecLt a pa y x);

ecGtEq  :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecGtEq a pa x y = not (ecLt a pa x y);

ecEq :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecEq a _ = eq (ty a);

ecNotEq :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecNotEq a pa x y = not (ecEq a pa x y);

ecFunEq :: (a b :: KType) -> PCmp b -> (ty a -> ty b) -> (ty a -> ty b) -> ty a -> Bool;
ecFunEq a b pb f g x = ecEq b pb (f x) (g x);

ecFunNotEq :: (a b :: KType) -> PCmp b -> (ty a -> ty b) -> (ty a -> ty b) -> ty a -> Bool;
ecFunNotEq a b pb f g x = ecNotEq b pb (f x) (g x);

-- Logic

ecAnd :: (a :: KType) -> ty a -> ty a -> ty a;
ecAnd = logicBinary bvAnd and;

ecOr :: (a :: KType) -> ty a -> ty a -> ty a;
ecOr = logicBinary bvOr or;

ecXor :: (a :: KType) -> ty a -> ty a -> ty a;
ecXor = logicBinary bvXor xor;

ecCompl :: (a :: KType) -> ty a -> ty a;
ecCompl TCBit = not;
ecCompl (TCFun a b) = compose (ty a) (ty b) (ty b) (ecCompl b);
ecCompl TCUnit = unitUnary;
ecCompl (TCPair a b) = pairUnary (ty a) (ty b) (ecCompl a) (ecCompl b);
ecCompl TCEmpty = emptyUnary;
ecCompl (TCField s a b) = fieldUnary s (ty a) (ty b) (ecCompl a) (ecCompl b);
ecCompl (TCSeq (TCNum n) TCBit) = bvNot n;
ecCompl (TCSeq TCInf TCBit) = streamMap Bool Bool not;
ecCompl (TCSeq n (TCSeq m a)) = seqMap (seq m (ty a)) (seq m (ty a)) n (ecCompl (TCSeq m a));
ecCompl (TCSeq n (TCFun a b)) = seqMap (ty a -> ty b) (ty a -> ty b) n (ecCompl (TCFun a b));
ecCompl (TCSeq n TCUnit) = seqMap #() #() n unitUnary;
ecCompl (TCSeq n (TCPair a b)) = seqMap #(ty a | ty b) #(ty a | ty b) n (ecCompl (TCPair a b));
ecCompl (TCSeq n TCEmpty) = seqMap #{} #{} n emptyUnary;
ecCompl (TCSeq n (TCField s a b)) = seqMap (ty (TCField s a b)) (ty (TCField s a b)) n (ecCompl (TCField s a b));

ecZero :: (a :: KType) -> ty a;
ecZero TCBit = False;
ecZero TCInteger = natToInt 0;
ecZero (TCFun a b) = (\(_::ty a) -> ecZero b);
ecZero TCUnit = ();
ecZero (TCPair a b) = (ecZero a | ecZero b);
ecZero TCEmpty = {};
ecZero (TCField s a b) = { (s) = ecZero a | ecZero b };
ecZero (TCSeq (TCNum n) TCBit) = bvNat n 0;
ecZero (TCSeq TCInf TCBit) = streamConst Bool False;
ecZero (TCSeq n TCInteger) = seqConst n Integer (ecZero TCInteger);
ecZero (TCSeq n (TCSeq m a)) = seqConst n (seq m (ty a)) (ecZero (TCSeq m a));
ecZero (TCSeq n (TCFun a b)) = seqConst n (ty a -> ty b) (ecZero (TCFun a b));
ecZero (TCSeq n TCUnit) = seqConst n #() ();
ecZero (TCSeq n (TCPair a b)) = seqConst n #(ty a | ty b) (ecZero (TCPair a b));
ecZero (TCSeq n TCEmpty) = seqConst n #{} {};
ecZero (TCSeq n (TCField s a b)) = seqConst n #{ (s) :: ty a | ty b } (ecZero (TCField s a b));

-- Sequences
ecShiftL :: (m n :: Num) -> (a :: KType) -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecShiftL (TCNum m) (TCNum n) a = bvShiftL m (ty a) n (ecZero a);
ecShiftL TCInf (TCNum n) a = bvStreamShiftL (ty a) n;

ecShiftR :: (m n :: Num) -> (a :: KType) -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecShiftR (TCNum m) (TCNum n) a = bvShiftR m (ty a) n (ecZero a);
ecShiftR TCInf (TCNum n) a = bvStreamShiftR (ty a) n (ecZero a);

ecRotL :: (m n :: Num) -> (a :: KType) -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecRotL (TCNum m) (TCNum n) a = bvRotateL m (ty a) n;

ecRotR :: (m n :: Num) -> (a :: KType) -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecRotR (TCNum m) (TCNum n) a = bvRotateR m (ty a) n;

ecCat :: (m n :: Num) -> (a :: KType) -> seq m (ty a) -> seq n (ty a) -> seq (tcAdd m n) (ty a);
ecCat (TCNum m) (TCNum n) a = append m n (ty a);
ecCat (TCNum m) TCInf a = streamAppend (ty a) m;

ecSplitAt :: (m n :: Num) -> (a :: KType) -> seq (tcAdd m n) (ty a) -> #(seq m (ty a), seq n (ty a));
ecSplitAt (TCNum m) (TCNum n) a xs = (take (ty a) m n xs, drop (ty a) m n xs);
ecSplitAt (TCNum m) TCInf a xs = (streamTake (ty a) m xs, streamDrop (ty a) m xs);

ecJoin :: (m n :: Num) -> (a :: KType) -> seq m (seq n (ty a)) -> seq (tcMul m n) (ty a);
ecJoin (TCNum m) (TCNum n) a = join m n (ty a);
ecJoin TCInf (TCNum n) a =
  natCase
    (\ (n'::Nat) -> Stream (Vec n' (ty a)) -> seq (ite Num (equalNat 0 n') (TCNum 0) TCInf) (ty a))
      (\ (s::Stream (Vec 0 (ty a))) -> EmptyVec (ty a))
      (\ (n'::Nat) -> \ (s::Stream (Vec (Succ n') (ty a))) -> streamJoin (ty a) n' s)
      n;

ecSplit :: (m n :: Num) -> (a :: KType) -> seq (tcMul m n) (ty a) -> seq m (seq n (ty a));
ecSplit (TCNum m) (TCNum n) a = split m n (ty a);
ecSplit TCInf (TCNum n) a =
  natCase
  (\(n :: Nat) -> seq (ite Num (equalNat 0 n) (TCNum 0) TCInf) (ty a) -> Stream (Vec n (ty a)))
  (streamConst (Vec 0 (ty a))) (\(n :: Nat) -> streamSplit (ty a) (Succ n)) n;

ecReverse :: (n :: Num) -> (a :: KType) -> seq n (ty a) -> seq n (ty a);
ecReverse (TCNum n) a = reverse n (ty a);

ecTranspose :: (m n :: Num) -> (a :: KType) -> seq m (seq n (ty a)) -> seq n (seq m (ty a));
ecTranspose (TCNum m) (TCNum n) a = transpose m n (ty a);
-- TODO: other cases

ecAt :: (n :: Num) -> (a :: KType) -> (i :: Num) -> seq n (ty a) -> seq i Bool -> ty a;
ecAt (TCNum n) a (TCNum i) = bvAt n (ty a) i;
ecAt TCInf a (TCNum i) = bvStreamGet (ty a) i;

ecAtRange :: (n :: Num) -> (a :: KType) -> (m i :: Num) -> seq n (ty a) -> seq m (seq i Bool) -> seq m (ty a);
ecAtRange n a m i xs = seqMap (seq i Bool) (ty a) m (ecAt n a i xs);

ecAtBack :: (n :: Num) -> (a :: KType) -> (i :: Num) -> seq n (ty a) -> seq i Bool -> ty a;
ecAtBack n a i xs = ecAt n a i (ecReverse n a xs);

ecAtRangeBack :: (n :: Num) -> (a :: KType) -> (m i :: Num) -> seq n (ty a) -> seq m (seq i Bool) -> seq m (ty a);
ecAtRangeBack n a m i xs = seqMap (seq i Bool) (ty a) m (ecAtBack n a i xs);

-- Static word sequences
ecFromThen :: (first next bits len :: Num) -> seq len (seq bits Bool);
ecFromThen (TCNum first) (TCNum next) (TCNum bits) (TCNum len) =
  gen len (Vec bits Bool)
    (\(i :: Nat) -> bvAdd bits (bvNat bits first)
                          (bvMul bits (bvSub bits (bvNat bits next) (bvNat bits first))
			              (bvNat bits i)));

ecFromTo :: (first last bits :: Num)
         -> seq (tcAdd (TCNum 1) (tcSub last first)) (seq bits Bool);
ecFromTo (TCNum first) (TCNum last) (TCNum bits) =
  gen (addNat 1 (subNat last first)) (Vec bits Bool)
    (\(i :: Nat) -> bvNat bits (addNat i first));

ecFromThenTo :: (first next last bits len :: Num) -> seq len (seq bits Bool);
ecFromThenTo (TCNum first) (TCNum next) _ (TCNum bits) (TCNum len) =
  gen len (Vec bits Bool)
    (\(i :: Nat) ->
      bvNat bits (subNat (addNat first (mulNat i next)) (mulNat i first)));

-- Infinite word sequences
ecInfFrom :: (n :: Num) -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFrom (TCNum n) w = MkStream (bitvector n) (\(i :: Nat) -> bvAdd n w (bvNat n i));

ecInfFromThen :: (n :: Num) -> seq n Bool -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFromThen (TCNum n) first next =
  MkStream (bitvector n) (\(i :: Nat) ->
    bvAdd n first (bvMul n (bvSub n next first) (bvNat n i)));

-- Run-time error
primitive ecError :: (a :: KType) -> (len :: Num) -> seq len (bitvector 8) -> ty a;

-- Polynomials
ecPMul :: (a b :: Num) -> seq a Bool -> seq b Bool
       -> seq (tcSub (tcMax (TCNum 1) (tcAdd a b)) (TCNum 1)) Bool;
ecPMul (TCNum a) (TCNum b) = bvPMul a b;

ecPDiv :: (a b :: Num) -> seq a Bool -> seq b Bool -> seq a Bool;
ecPDiv (TCNum a) (TCNum b) = bvPDiv a b;

ecPMod :: (a b :: Num) -> seq a Bool -> seq (tcAdd (TCNum 1) b) Bool -> seq b Bool;
ecPMod (TCNum a) (TCNum b) = bvPMod a b;

-- Random values
ecRandom :: (a :: KType) -> bitvector 32 -> ty a;
ecRandom a _ = error (ty a) "Cryptol.random";

-- Trace function; simply return the final argument
ecTrace :: (n :: Num) -> (a b :: KType) -> seq n (bitvector 8) -> ty a -> ty b -> ty b;
ecTrace _ _ _ _ _ x = x;

--------------------------------------------------------------------------------
-- Extra primitives

-- Array update
ecUpdate :: (n :: Num) -> (a :: KType) -> (w :: Num)
  -> seq n (ty a) -> seq w Bool -> ty a -> seq n (ty a);
ecUpdate (TCNum n) a (TCNum w) = bvUpd n (ty a) w;
ecUpdate TCInf     a (TCNum w) = bvStreamUpd (ty a) w;

ecUpdateEnd :: (n :: Num) -> (a :: KType) -> (w :: Num)
  -> seq n (ty a) -> seq w Bool -> ty a -> seq n (ty a);
ecUpdateEnd (TCNum n) a (TCNum w) xs i y = upd n (ty a) xs (subNat (subNat n 1) (bvToNat w i)) y;

-- Bitvector truncation
ecTrunc :: (m n :: Num) -> seq (tcAdd m n) Bool -> seq n Bool;
ecTrunc (TCNum m) (TCNum n) = bvTrunc m n;

-- Zero extension
ecUExt :: (m n :: Num) -> seq n Bool -> seq (tcAdd m n) Bool;
ecUExt (TCNum m) (TCNum n) = bvUExt m n;
{-
-- Sign extension
ecSExt :: (m n :: Num) -> seq (tcAdd n (TCNum 1)) Bool -> seq (tcAdd m (tcAdd n (TCNum 1))) Bool;
ecSExt (TCNum m) (TCNum n) = bvSExt m n;

-- Signed integer division
ecSDiv :: (n :: Num) -> seq (tcAdd n (TCNum 1)) Bool
  -> seq (tcAdd n (TCNum 1)) Bool -> seq (tcAdd n (TCNum 1)) Bool;
ecSDiv (TCNum n) = bvSDiv n;

-- Signed integer remainder
ecSRem :: (n :: Num) -> seq (tcAdd n (TCNum 1)) Bool
  -> seq (tcAdd n (TCNum 1)) Bool -> seq (tcAdd n (TCNum 1)) Bool;
ecSRem (TCNum n) = bvSRem n;
-}
-- Signed greater-than
ecSgt :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSgt (TCNum n) = bvsgt n;

-- Signed greater-or-equal
ecSge :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSge (TCNum n) = bvsge n;

-- Signed less-than
ecSlt :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSlt (TCNum n) = bvslt n;

-- Signed less-or-equal
ecSle :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSle (TCNum n) = bvsle n;

-- Prelude.bvSShr

--------------------------------------------------------------------------------
-- Rewrite rules

axiom replicate_False :: (n :: Nat) -> Eq (bitvector n) (replicate n Bool False) (bvNat n 0);

axiom subNat_0 :: (n :: Nat) -> Eq Nat (subNat n 0) n;

axiom demote_add_distr
  :: (w :: Nat)
  -> (x y :: Num)
  -> Eq (bitvector w)
        (ecDemote (tcAdd x y) (TCNum w))
        (bvAdd w (ecDemote x (TCNum w)) (ecDemote y (TCNum w)));

--------------------------------------------------------------------------------
