--------------------------------------------------------------------------------
-- Cryptol primitives for SAWCore

module Cryptol where

import Prelude;

--------------------------------------------------------------------------------
-- Additional operations on Prelude types

lg2Nat :: Nat -> Nat;

pairMap :: (a1 b1 a2 b2 :: sort 0) -> (a1 -> b1) -> (a2 -> b2) -> #(a1, a2) -> #(b1, b2);
pairMap _ _ _ _ f g (x, y) = (f x, g y);

pairMap2 :: (a1 b1 c1 a2 b2 c2 :: sort 0) -> (a1 -> b1 -> c1) -> (a2 -> b2 -> c2) -> #(a1, a2) -> #(b1, b2) -> #(c1, c2);
pairMap2 _ _ _ _ _ _ f1 f2 (x1, x2) (y1, y2) = (f1 x1 y1, f2 x2 y2);

compose :: (a b c :: sort 0) -> (b -> c) -> (a -> b) -> (a -> c);
compose _ _ _ f g x = f (g x);

fix :: (a :: sort 0) -> (a -> a) -> a;
fix a f = f (fix a f);

bvExp :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
bvExp n x y = foldr Bool (bitvector n) n
  (\ (b :: Bool) -> \ (a :: bitvector n) ->
    ite (bitvector n) b (bvMul n x (bvMul n a a)) (bvMul n a a))
  (bvNat n 1)
  (reverse n Bool y);

bvLg2 :: (n :: Nat) -> bitvector n -> bitvector n;

--------------------------------------------------------------------------------
-- Extended natural numbers

data Num :: sort 0 where {
    TCNum :: Nat -> Num;
    TCInf :: Num;
  }

tcWidth :: Num -> Num;
tcWidth (TCNum n) = TCNum (widthNat n);
tcWidth TCInf = TCInf;

tcLg2 :: Num -> Num;
tcLg2 (TCNum n) = TCNum (lg2Nat n);
tcLg2 TCInf = TCInf;

tcAdd :: Num -> Num -> Num;
tcAdd (TCNum x) (TCNum y) = TCNum (addNat x y);
tcAdd (TCNum _) TCInf = TCInf;
tcAdd TCInf _ = TCInf;

tcSub :: Num -> Num -> Num;
tcSub (TCNum x) (TCNum y) = TCNum (subNat x y);
tcSub TCInf (TCNum _) = TCInf;
-- other cases are undefined

tcMul :: Num -> Num -> Num;
tcMul (TCNum x) (TCNum y) = TCNum (mulNat x y);
tcMul (TCNum x) TCInf = ite Num (equalNat 0 x) (TCNum 0) TCInf;
tcMul TCInf (TCNum y) = ite Num (equalNat 0 y) (TCNum 0) TCInf;
tcMul TCInf TCInf = TCInf;

tcDiv :: Num -> Num -> Num;
tcDiv (TCNum x) (TCNum y) = TCNum ((divModNat x y).1);
tcDiv (TCNum _) TCInf = TCNum Zero;
-- other cases undefined

tcMod :: Num -> Num -> Num;
tcMod (TCNum x) (TCNum y) = TCNum ((divModNat x y).2);
tcMod (TCNum x) TCInf = TCNum x;
-- other cases undefined

tcExp :: Num -> Num -> Num;
tcExp (TCNum Zero) _ = TCNum Zero;
tcExp (TCNum (Succ Zero)) _ = TCNum (Succ Zero);
tcExp _ (TCNum Zero) = TCNum (Succ Zero);
tcExp (TCNum x) (TCNum y) = TCNum (expNat x y);
-- other cases undefined

tcMin :: Num -> Num -> Num;
tcMin (TCNum x) (TCNum y) = TCNum (minNat x y);
tcMin (TCNum x) TCInf = TCNum x;
tcMin TCInf (TCNum y) = TCNum y;
tcMin TCInf TCInf = TCInf;

tcMax :: Num -> Num -> Num;
tcMax (TCNum x) (TCNum y) = TCNum (maxNat x y);
tcMax (TCNum _) TCInf = TCInf;
tcMax TCInf (TCNum _) = TCInf;
tcMax TCInf TCInf = TCInf;

tcLenFromThen :: Num -> Num -> Num -> Num;
tcLenFromThenTo :: Num -> Num -> Num -> Num;

--------------------------------------------------------------------------------
-- Possibly infinite sequences

seq :: Num -> sort 0 -> sort 0;
seq (TCNum n) a = Vec n a;
seq TCInf a = Stream a;

seqMap :: (a b :: sort 0) -> (n :: Num) -> (a -> b) -> seq n a -> seq n b;
seqMap a b (TCNum n) f = vMap a b f n;
seqMap a b TCInf f = streamMap a b f;

seqConst :: (n :: Num) -> (a :: sort 0) -> a -> seq n a;
seqConst (TCNum n) = replicate n;
seqConst TCInf = streamConst;

--------------------------------------------------------------------------------
-- Predicate symbols

PEqual :: Num -> Num -> sort 0;
PNeq   :: Num -> Num -> sort 0;
PGeq   :: Num -> Num -> sort 0;

data PFin :: Num -> sort 0 where {
    PFinNum :: (n :: Nat) -> PFin (TCNum n);
  }

PArith :: sort 0 -> sort 0;
PCmp   :: sort 0 -> sort 0;
{-
data PArith :: sort 0 -> sort 0 where {
    PArithWord :: (n :: Num) -> PFin n -> PArith (seq n Bool);
    PArithSeq :: (n :: Num) -> (a :: KType) -> PArith a -> PArith (seq n a);
    PArithFun :: (a b :: KType) -> PArith b -> PArith (TCFun a b);
    PArithPair :: (a b :: KType) -> PArith a -> PArith b -> PArith (TCPair a b);
  }

data PCmp :: KType -> sort 0 where {
    PCmpUnit :: PCmp #();
    PCmpBit :: PCmp Bool;
    PCmpSeq :: (n :: Num) -> (a :: KType) -> PFin n -> PCmp a -> PCmp (seq n a);
    PCmpPair :: (a b :: KType) -> PCmp a -> PCmp b -> PCmp (TCPair a b);
  }
-}

-- Partial functions to select instances (terms translated from
-- type-correct Cryptol should never hit the undefined cases)

ePEqual :: (m n :: Num) -> PEqual m n;
ePNeq :: (m n :: Num) -> PNeq m n;
ePGeq :: (m n :: Num) -> PGeq m n;

ePFin :: (n :: Num) -> PFin n;
ePFin (TCNum n) = PFinNum n;
-- ePFin TCInf is undefined

ePArith :: (a :: sort 0) -> PArith a;

ePCmp :: (a :: sort 0) -> PCmp a;

--------------------------------------------------------------------------------
-- Auxiliary functions

eListSel :: (a :: sort 0) -> (n :: Num) -> seq n a -> Nat -> a;
eListSel a (TCNum n) xs i = at n a xs i;
eListSel a TCInf xs i = streamGet a xs i;

--------------------------------------------------------------------------------
-- List comprehensions

from :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> (a -> seq n b) -> seq (tcMul m n) #(a, b);
from a b (TCNum m) (TCNum n) xs k =
  join m n #(a, b)
  (vMap a (Vec n #(a, b))
    (\(x :: a) -> vMap b #(a, b) (\(y :: b) -> (x, y)) n (k x))
    m xs);

mlet :: (a b :: sort 0) -> (n :: Num) -> a -> (a -> seq n b) -> seq n #(a, b);
mlet a b (TCNum n) x f = vMap b #(a, b) (\(y :: b) -> (x, y)) n (f x);

zip :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> seq n b -> seq (tcMin m n) #(a, b);
zip a b (TCNum m) (TCNum n) xs ys = vZip a b m n xs ys;
zip a b (TCNum m) TCInf xs ys = generate m #(a, b) (\(i :: Fin m) -> (get m a xs i, streamGet b ys (finFront m i)));
zip a b TCInf (TCNum n) xs ys = generate n #(a, b) (\(i :: Fin n) -> (streamGet a xs (finFront n i), get n b ys i));
zip a b TCInf TCInf xs ys = streamMap2 a b #(a, b) (\(x::a) -> \(y::b) -> (x, y)) xs ys;

map :: (a b :: sort 0) -> (n :: Num) -> (a -> b) -> seq n a -> seq n b;
map a b (TCNum n) f = vMap a b f n;
map a b TCInf f = streamMap a b f;

--------------------------------------------------------------------------------
-- Arith functions

seqBinary :: (n :: Num) -> (a :: sort 0) -> (a -> a -> a) -> seq n a -> seq n a -> seq n a;
seqBinary (TCNum n) a f = vZipWith a a a f n;
seqBinary TCInf a f = streamMap2 a a a f;

unitBinary :: #() -> #() -> #();
unitBinary _ _ = ();

pairBinary :: (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b) -> #(a, b) -> #(a, b) -> #(a, b);
pairBinary a b f g x y = (f x.1 y.1, g x.2 y.2);

funBinary :: (a b :: sort 0) -> (b -> b -> b) -> (a -> b) -> (a -> b) -> (a -> b);
funBinary a b op f g x = op (f x) (g x);

arithUnaryBool :: Bool -> Bool;
arithBinaryBool :: Bool -> Bool -> Bool;

arithUnary :: ((n :: Nat) -> bitvector n -> bitvector n)
           -> (a :: sort 0) -> PArith a -> a -> a;
arithUnary bvOp a _ = unary bvOp arithUnaryBool a;

arithBinary :: ((n :: Nat) -> bitvector n -> bitvector n -> bitvector n)
            -> (a :: sort 0) -> PArith a -> a -> a -> a;
arithBinary bvOp a _ = binary bvOp arithBinaryBool a;

eq_binary_bvsub :: (n :: Nat) ->
                   Eq (Vec n Bool -> Vec n Bool -> Vec n Bool)
                      (binary bvSub arithBinaryBool (Vec n Bool))
                      (bvSub n);

eq_binary_bvadd :: (n :: Nat) ->
                   Eq (Vec n Bool -> Vec n Bool -> Vec n Bool)
                      (binary bvAdd arithBinaryBool (Vec n Bool))
                      (bvAdd n);

eq_binary_bvand :: (n :: Nat) ->
                   Eq (Vec n Bool -> Vec n Bool -> Vec n Bool)
                      (binary bvAnd and (Vec n Bool))
                      (bvAnd n);

eq_binary_bvor :: (n :: Nat) ->
                  Eq (Vec n Bool -> Vec n Bool -> Vec n Bool)
                     (binary bvOr or (Vec n Bool))
                     (bvOr n);

eq_binary_bvxor :: (n :: Nat) ->
                   Eq (Vec n Bool -> Vec n Bool -> Vec n Bool)
                      (binary bvXor xor (Vec n Bool))
                      (bvXor n);

--------------------------------------------------------------------------------
-- Primitive Cryptol functions

ecDemote :: (val bits :: Num) -> PFin val -> PFin bits -> PGeq bits (tcWidth val) -> seq bits Bool;
ecDemote _ _ (PFinNum val) (PFinNum bits) _ = bvNat bits val;

-- Arith
ecPlus :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecPlus = arithBinary bvAdd;

ecMinus :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMinus = arithBinary bvSub;

ecMul :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMul = arithBinary bvMul;

ecDiv :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecDiv = arithBinary bvUDiv;

ecMod :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMod = arithBinary bvURem;

ecExp :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecExp = arithBinary bvExp;

ecLg2 :: (a :: sort 0) -> PArith a -> a -> a;
ecLg2 = arithUnary bvLg2;

ecNeg :: (a :: sort 0) -> PArith a -> a -> a;
ecNeg = arithUnary bvNeg;

-- Cmp
ecLt :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
--ecLt a pa x y = cmpLt a pa x y False;
ecLt a _ = lt a;

ecGt :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecGt a pa x y = ecLt a pa y x;

ecLtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecLtEq a pa x y = not (ecLt a pa y x);

ecGtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecGtEq a pa x y = not (ecLt a pa x y);

ecEq :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecEq a _ = eq a;

ecNotEq :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecNotEq a pa x y = not (ecEq a pa x y);

ecFunEq    :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;
ecFunEq a b pb f g x = ecEq b pb (f x) (g x);

ecFunNotEq :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;
ecFunNotEq a b pb f g x = ecNotEq b pb (f x) (g x);

ecMin :: (a :: sort 0) -> PCmp a -> a -> a -> a;
ecMax :: (a :: sort 0) -> PCmp a -> a -> a -> a;

-- Logic
ecAnd :: (a :: sort 0) -> a -> a -> a;
ecAnd = binary bvAnd and;

ecOr :: (a :: sort 0) -> a -> a -> a;
ecOr = binary bvOr or;

ecXor :: (a :: sort 0) -> a -> a -> a;
ecXor = binary bvXor xor;

ecCompl :: (a :: sort 0) -> a -> a;
ecCompl = unary bvNot not;

ecZero  :: (a :: sort 0) -> a;
ecZero = zero;

-- Sequences
ecShiftL :: (m n :: Num) -> (a :: sort 0) -> PFin n -> seq m a -> seq n Bool -> seq m a;
ecShiftL (TCNum m) _ a (PFinNum n) = bvShiftL m a n (ecZero a);
ecShiftL TCInf _ a (PFinNum n) = bvStreamShiftL a n;

ecShiftR :: (m n :: Num) -> (a :: sort 0) -> PFin n -> seq m a -> seq n Bool -> seq m a;
ecShiftR (TCNum m) _ a (PFinNum n) = bvShiftR m a n (ecZero a);
ecShiftR TCInf _ a (PFinNum n) = bvStreamShiftR a n (ecZero a);

ecRotL :: (m n :: Num) -> (a :: sort 0) -> PFin m -> PFin n -> seq m a -> seq n Bool -> seq m a;
ecRotL _ _ a (PFinNum m) (PFinNum n) = bvRotateL m a n;

ecRotR :: (m n :: Num) -> (a :: sort 0) -> PFin m -> PFin n -> seq m a -> seq n Bool -> seq m a;
ecRotR _ _ a (PFinNum m) (PFinNum n) = bvRotateR m a n;

ecCat :: (m n :: Num) -> (a :: sort 0) -> PFin m -> seq m a -> seq n a -> seq (tcAdd m n) a;
ecCat _ (TCNum n) a (PFinNum m) = append m n a;
ecCat _ TCInf a (PFinNum m) = streamAppend a m;

ecSplitAt :: (m n :: Num) -> (a :: sort 0) -> PFin m -> seq (tcAdd m n) a -> #(seq m a, seq n a);
ecSplitAt _ (TCNum n) a (PFinNum m) xs = (vTake a m n xs, vDrop a m n xs);
ecSplitAt _ TCInf a (PFinNum m) xs = (streamTake a m xs, streamDrop a m xs);

ecJoin :: (m n :: Num) -> (a :: sort 0) -> PFin n -> seq m (seq n a) -> seq (tcMul m n) a;
ecJoin (TCNum m) _ a (PFinNum n) = join m n a;
ecJoin TCInf _ a (PFinNum n) =
  natCase
    (\ (n'::Nat) -> Stream (Vec n' a) -> seq (ite Num (equalNat 0 n') (TCNum 0) TCInf) a)
      (\ (s::Stream (Vec 0 a)) -> EmptyVec a)
      (\ (n'::Nat) -> \ (s::Stream (Vec (Succ n') a)) -> streamJoin a n' s)
      n;

ecSplit :: (m n :: Num) -> (a :: sort 0) -> PFin n -> seq (tcMul m n) a -> seq m (seq n a);
ecSplit (TCNum m) _ a (PFinNum n) = split m n a;
ecSplit TCInf _ a (PFinNum n) =
  natCase
  (\(n :: Nat) -> seq (ite Num (equalNat 0 n) (TCNum 0) TCInf) a -> Stream (Vec n a))
  (streamConst (Vec 0 a)) (\(n :: Nat) -> streamSplit a (Succ n)) n;

ecReverse :: (n :: Num) -> (a :: sort 0) -> PFin n -> seq n a -> seq n a;
ecReverse _ a (PFinNum n) = reverse n a;

ecTranspose :: (m n :: Num) -> (a :: sort 0) -> seq m (seq n a) -> seq n (seq m a);
ecTranspose (TCNum m) (TCNum n) a = transpose m n a;
-- TODO: other cases

ecAt :: (n :: Num) -> (a :: sort 0) -> (i :: Num) -> PFin i -> seq n a -> seq i Bool -> a;
ecAt (TCNum n) a _ (PFinNum i) = bvAt n a i;
ecAt TCInf a _ (PFinNum i) = bvStreamGet a i;

ecAtRange :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> PFin i -> seq n a -> seq m (seq i Bool) -> seq m a;
ecAtRange n a m i pi xs = map (seq i Bool) a m (ecAt n a i pi xs);

ecAtBack :: (n :: Num) -> (a :: sort 0) -> (i :: Num) -> PFin n -> PFin i -> seq n a -> seq i Bool -> a;
ecAtBack n a i pn pi xs = ecAt n a i pi (ecReverse n a pn xs);

ecAtRangeBack :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> PFin n -> PFin i -> seq n a -> seq m (seq i Bool) -> seq m a;
ecAtRangeBack n a m i pn pi xs = map (seq i Bool) a m (ecAtBack n a i pn pi xs);

-- Static word sequences
ecFromThen :: (first next bits len :: Num) -> PFin first -> PFin next -> PFin bits
           -> PGeq bits (tcWidth first) -> PGeq bits (tcWidth next)
           -> PEqual (tcLenFromThen first next bits) len
           -> seq len (seq bits Bool);

ecFromTo :: (first last bits :: Num) -> PFin last -> PFin bits
         -> PGeq last first -> PGeq bits (tcWidth last)
         -> seq (tcAdd (TCNum 1) (tcSub last first)) (seq bits Bool);
ecFromTo (TCNum first) _ _ (PFinNum last) (PFinNum bits) _ _ =
  generate (addNat 1 (subNat last first)) (Vec bits Bool)
    (\(i::Fin (addNat 1 (subNat last first))) ->
      bvNat bits (addNat (finFront (addNat 1 (subNat last first)) i) first));

ecFromThenTo :: (first next last bits len :: Num) -> PFin first -> PFin next -> PFin last -> PFin bits
             -> PGeq bits (tcWidth first) -> PGeq bits (tcWidth next) -> PGeq bits (tcWidth last)
             -> PEqual (tcLenFromThenTo first next last) len
             -> seq len (seq bits Bool);
ecFromThenTo _ _ _ _ (TCNum len) (PFinNum first) (PFinNum next) _ (PFinNum bits) _ _ _ _ =
  generate len (Vec bits Bool)
    (\(i::Fin len) ->
      bvNat bits (subNat (addNat first (mulNat (finFront len i) next)) (mulNat (finFront len i) first)));

-- Infinite word sequences
ecInfFrom :: (n :: Num) -> PFin n -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFrom _ (PFinNum n) w = MkStream (bitvector n) (\(i :: Nat) -> bvAdd n w (bvNat n i));

ecInfFromThen :: (n :: Num) -> PFin n -> seq n Bool -> seq n Bool -> seq TCInf (seq n Bool);

-- Run-time error
ecError :: (a :: sort 0) -> (len :: Num) -> PFin len -> seq len (bitvector 8) -> a;

-- Polynomials
ecPMul :: (a b :: Num) -> PFin a -> PFin b -> seq a Bool -> seq b Bool
       -> seq (tcSub (tcMax (TCNum 1) (tcAdd a b)) (TCNum 1)) Bool;
ecPMul _ _ (PFinNum a) (PFinNum b) = bvPMul a b;

ecPDiv :: (a b :: Num) -> PFin a -> PFin b
       -> seq a Bool -> seq b Bool -> seq a Bool;
ecPDiv _ _ (PFinNum a) (PFinNum b) = bvPDiv a b;

ecPMod :: (a b :: Num) -> PFin a -> PFin b
       -> seq a Bool -> seq (tcAdd (TCNum 1) b) Bool -> seq b Bool;
ecPMod _ _ (PFinNum a) (PFinNum b) = bvPMod a b;

-- Random values
ecRandom :: (a :: sort 0) -> bitvector 32 -> a;


--------------------------------------------------------------------------------
-- Rewrite rules

replicate_False :: (n :: Nat) -> Eq (bitvector n) (replicate n Bool False) (bvNat n 0);

unsafeCoerce_same :: (a :: sort 0) -> (x :: a) -> Eq a (unsafeCoerce a a x) x;

subNat_0 :: (n :: Nat) -> Eq Nat (subNat n 0) n;

-- TODO: implement these rules more generally with conversions:
subNat_5_1 :: Eq Nat (subNat 5 1) 4;
widthNat_4 :: Eq Nat (widthNat 4) 3;
widthNat_5 :: Eq Nat (widthNat 5) 3;

--------------------------------------------------------------------------------
