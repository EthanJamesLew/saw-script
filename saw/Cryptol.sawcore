--------------------------------------------------------------------------------
-- Cryptol primitives for SAWCore

module Cryptol where

import Prelude;

--------------------------------------------------------------------------------
-- Additional operations on Prelude types

lg2Nat :: Nat -> Nat;

pairMap :: (a1 b1 a2 b2 :: sort 0) -> (a1 -> b1) -> (a2 -> b2) -> #(a1, a2) -> #(b1, b2);
pairMap _ _ _ _ f g (x, y) = (f x, g y);

pairMap2 :: (a1 b1 c1 a2 b2 c2 :: sort 0) -> (a1 -> b1 -> c1) -> (a2 -> b2 -> c2) -> #(a1, a2) -> #(b1, b2) -> #(c1, c2);
pairMap2 _ _ _ _ _ _ f1 f2 (x1, x2) (y1, y2) = (f1 x1 y1, f2 x2 y2);

compose :: (a b c :: sort 0) -> (b -> c) -> (a -> b) -> (a -> c);
compose _ _ _ f g x = f (g x);

fix :: (a :: sort 0) -> (a -> a) -> a;
fix a f = f (fix a f);

bvExp :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
bvLg2 :: (n :: Nat) -> bitvector n -> bitvector n;

--------------------------------------------------------------------------------
-- Extended natural numbers

data Num :: sort 0 where {
    TCNum :: Nat -> Num;
    TCInf :: Num;
  }

tcWidth :: Num -> Num;
tcWidth (TCNum n) = TCNum (widthNat n);
tcWidth TCInf = TCInf;

tcLg2 :: Num -> Num;
tcLg2 (TCNum n) = TCNum (lg2Nat n);
tcLg2 TCInf = TCInf;

tcAdd :: Num -> Num -> Num;
tcAdd (TCNum x) (TCNum y) = TCNum (addNat x y);
tcAdd (TCNum _) TCInf = TCInf;
tcAdd TCInf _ = TCInf;

tcSub :: Num -> Num -> Num;
tcSub (TCNum x) (TCNum y) = TCNum (subNat x y);
tcSub TCInf (TCNum _) = TCInf;
-- other cases are undefined

tcMul :: Num -> Num -> Num;
tcMul (TCNum x) (TCNum y) = TCNum (mulNat x y);
tcMul (TCNum x) TCInf = ite Num (equalNat 0 x) (TCNum 0) TCInf;
tcMul TCInf (TCNum y) = ite Num (equalNat 0 y) (TCNum 0) TCInf;
tcMul TCInf TCInf = TCInf;

tcDiv :: Num -> Num -> Num;
tcMod :: Num -> Num -> Num;
tcExp :: Num -> Num -> Num;

tcMin :: Num -> Num -> Num;
tcMin (TCNum x) (TCNum y) = TCNum (minNat x y);
tcMin (TCNum x) TCInf = TCNum x;
tcMin TCInf (TCNum y) = TCNum y;
tcMin TCInf TCInf = TCInf;

tcMax :: Num -> Num -> Num;
tcMax (TCNum x) (TCNum y) = TCNum (maxNat x y);
tcMax (TCNum _) TCInf = TCInf;
tcMax TCInf (TCNum _) = TCInf;
tcMax TCInf TCInf = TCInf;

tcLenFromThen :: Num -> Num -> Num -> Num;
tcLenFromThenTo :: Num -> Num -> Num -> Num;

--------------------------------------------------------------------------------
-- Possibly infinite sequences

seq :: Num -> sort 0 -> sort 0;
seq (TCNum n) a = Vec n a;
seq TCInf a = Stream a;

seqMap :: (a b :: sort 0) -> (n :: Num) -> (a -> b) -> seq n a -> seq n b;
seqMap a b (TCNum n) f = vMap a b f n;
seqMap a b TCInf f = streamMap a b f;

seqConst :: (n :: Num) -> (a :: sort 0) -> a -> seq n a;
seqConst (TCNum n) = replicate n;
seqConst TCInf = streamConst;

--------------------------------------------------------------------------------
-- Types

data KType :: sort 0 where {
    TCBit :: KType;
    TCSeq :: Num -> KType -> KType;
    TCFun :: KType -> KType -> KType;
    TCUnit :: KType;
    TCPair :: KType -> KType -> KType;
  }

ty :: KType -> sort 0;
ty TCBit = Bool;
ty (TCSeq n a) = seq n (ty a);
ty (TCFun a b) = ty a -> ty b;
ty TCUnit = #();
ty (TCPair a b) = #(ty a, ty b);

--------------------------------------------------------------------------------
-- Predicate symbols

PEqual :: Num -> Num -> sort 0;
PNeq   :: Num -> Num -> sort 0;
PGeq   :: Num -> Num -> sort 0;

data PFin :: Num -> sort 0 where {
    PFinNum :: (n :: Nat) -> PFin (TCNum n);
  }

data PArith :: KType -> sort 0 where {
    PArithWord :: (n :: Num) -> PFin n -> PArith (TCSeq n TCBit);
    PArithSeq :: (n :: Num) -> (a :: KType) -> PArith a -> PArith (TCSeq n a);
    PArithFun :: (a b :: KType) -> PArith b -> PArith (TCFun a b);
    PArithPair :: (a b :: KType) -> PArith a -> PArith b -> PArith (TCPair a b);
  }

data PCmp :: KType -> sort 0 where {
    PCmpBit :: PCmp TCBit;
    PCmpSeq :: (n :: Num) -> (a :: KType) -> PFin n -> PCmp a -> PCmp (TCSeq n a);
    PCmpPair :: (a b :: KType) -> PCmp a -> PCmp b -> PCmp (TCPair a b);
  }

-- Partial functions to select instances (terms translated from
-- type-correct Cryptol should never hit the undefined cases)

ePEqual :: (m n :: Num) -> PEqual m n;
ePNeq :: (m n :: Num) -> PNeq m n;
ePGeq :: (m n :: Num) -> PGeq m n;

ePFin :: (n :: Num) -> PFin n;
ePFin (TCNum n) = PFinNum n;
-- ePFin TCInf is undefined

illegalPArithTCBit :: PArith TCBit;

ePArith :: (a :: KType) -> PArith a;
ePArith TCBit = illegalPArithTCBit;
ePArith (TCSeq n TCBit) = PArithWord n (ePFin n);
ePArith (TCSeq n (TCSeq m a)) = PArithSeq n (TCSeq m a) (ePArith (TCSeq m a));
ePArith (TCSeq n (TCFun a b)) = PArithSeq n (TCFun a b) (ePArith (TCFun a b));
ePArith (TCSeq n (TCPair a b)) = PArithSeq n (TCPair a b) (ePArith (TCPair a b));
ePArith (TCFun a b) = PArithFun a b (ePArith b);
ePArith (TCPair a b) = PArithPair a b (ePArith a) (ePArith b);

ePCmp :: (a :: KType) -> PCmp a;
ePCmp TCBit = PCmpBit;
ePCmp (TCSeq n a) = PCmpSeq n a (ePFin n) (ePCmp a);
ePCmp (TCPair a b) = PCmpPair a b (ePCmp a) (ePCmp b);

--------------------------------------------------------------------------------
-- Auxiliary functions

eCast :: (a b :: KType) -> ty a -> ty b;
eCast a b = unsafeCoerce (ty a) (ty b);

eListSel :: (a :: KType) -> (n :: Num) -> seq n (ty a) -> Nat -> ty a;
eListSel a (TCNum n) xs i = get n (ty a) xs (finOfNat n i);
eListSel a TCInf xs i = streamGet (ty a) xs i;

eIf :: (a :: KType) -> Bool -> ty a -> ty a -> ty a;
eIf a = ite (ty a);

--------------------------------------------------------------------------------
-- List comprehensions

-- TODO: use Prelude one
uncurry :: (a b c :: KType) -> (ty a -> ty b -> ty c) -> (#(ty a, ty b) -> ty c);
uncurry a b c f = (\(x :: #(ty a, ty b)) -> f (x.1) (x.2));

from :: (a b :: KType) -> (m n :: Num) -> seq m (ty a) -> (ty a -> seq n (ty b)) -> seq (tcMul m n) #(ty a, ty b);
from a b (TCNum m) (TCNum n) xs k =
  join m n #(ty a, ty b)
  (vMap (ty a) (Vec n #(ty a, ty b))
    (\(x :: ty a) -> vMap (ty b) #(ty a, ty b) (\(y :: ty b) -> (x, y)) n (k x))
    m xs);

eSingle :: (a :: KType) -> ty a -> Vec 1 (ty a);
eSingle a = single (ty a);

mlet :: (a b :: KType) -> (n :: Num) -> ty a -> (ty a -> seq n (ty b)) -> seq n #(ty a, ty b);
mlet a b (TCNum n) x f = vMap (ty b) #(ty a, ty b) (\(y :: ty b) -> (x, y)) n (f x);

zip :: (a b :: KType) -> (m n :: Num) -> seq m (ty a) -> seq n (ty b) -> seq (tcMin m n) #(ty a, ty b);
zip a b (TCNum m) (TCNum n) xs ys = vZip (ty a) (ty b) m n xs ys;
zip a b (TCNum m) TCInf xs ys = generate m #(ty a, ty b) (\(i :: Fin m) -> (get m (ty a) xs i, streamGet (ty b) ys (finFront m i)));
zip a b TCInf (TCNum n) xs ys = generate n #(ty a, ty b) (\(i :: Fin n) -> (streamGet (ty a) xs (finFront n i), get n (ty b) ys i));
zip a b TCInf TCInf xs ys = streamMap2 (ty a) (ty b) #(ty a, ty b) (\(x::ty a) -> \(y::ty b) -> (x, y)) xs ys;

map :: (a b :: KType) -> (n :: Num) -> (ty a -> ty b) -> seq n (ty a) -> seq n (ty b);
map a b (TCNum n) f = vMap (ty a) (ty b) f n;
map a b TCInf f = streamMap (ty a) (ty b) f;

--------------------------------------------------------------------------------
-- Arith functions

seqBinary :: (n :: Num) -> (a :: KType) -> (ty a -> ty a -> ty a) -> seq n (ty a) -> seq n (ty a) -> seq n (ty a);
seqBinary (TCNum n) a f = vZipWith (ty a) (ty a) (ty a) f n;
seqBinary TCInf a f = streamMap2 (ty a) (ty a) (ty a) f;

unitBinary :: #() -> #() -> #();
unitBinary _ _ = ();

pairBinary :: (a b :: KType) -> (ty a -> ty a -> ty a) -> (ty b -> ty b -> ty b) -> #(ty a, ty b) -> #(ty a, ty b) -> #(ty a, ty b);
pairBinary a b f g x y = (f x.1 y.1, g x.2 y.2);

funBinary :: (a b :: KType) -> (ty b -> ty b -> ty b) -> (ty a -> ty b) -> (ty a -> ty b) -> (ty a -> ty b);
funBinary a b op f g x = op (f x) (g x);

arithBinary :: ((n :: Nat) -> bitvector n -> bitvector n -> bitvector n)
            -> (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
arithBinary bvOp _ (PArithWord _ (PFinNum n)) = bvOp n;
arithBinary bvOp _ (PArithSeq n a pa) = seqBinary n a (arithBinary bvOp a pa);
arithBinary bvOp _ (PArithFun a b pb) = funBinary a b (arithBinary bvOp b pb);
arithBinary bvOp _ (PArithPair a b pa pb) =
  pairBinary a b (arithBinary bvOp a pa) (arithBinary bvOp b pb);

arithUnary :: ((n :: Nat) -> bitvector n -> bitvector n)
           -> (a :: KType) -> PArith a -> ty a -> ty a;
arithUnary bvOp _ (PArithWord _ (PFinNum n)) = bvOp n;
arithUnary bvOp _ (PArithSeq n a pa) = seqMap (ty a) (ty a) n (arithUnary bvOp a pa);
arithUnary bvOp _ (PArithFun a b pb) = compose (ty a) (ty b) (ty b) (arithUnary bvOp b pb);
arithUnary bvOp _ (PArithPair a b pa pb) =
  pairMap (ty a) (ty a) (ty b) (ty b) (arithUnary bvOp a pa) (arithUnary bvOp b pb);

--------------------------------------------------------------------------------
-- Comparisons

cmpBoolEq :: Bool -> Bool -> Bool -> Bool;
cmpBoolEq x y k = and (boolEq x y) k;

cmpBoolLt :: Bool -> Bool -> Bool -> Bool;
cmpBoolLt x y k = or (and (not x) y) (cmpBoolEq x y k);

cmpBvEq :: (n :: Nat) -> bitvector n -> bitvector n -> Bool -> Bool;
cmpBvEq n x y k = and (bvEq n x y) k;

cmpBvLt :: (n :: Nat) -> bitvector n -> bitvector n -> Bool -> Bool;
cmpBvLt n x y k = or (bvult n x y) (cmpBvEq n x y k);

cmpLt :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool -> Bool;
cmpLt _ PCmpBit = cmpBoolLt;
cmpLt _ (PCmpSeq _ _ (PFinNum n) PCmpBit) = cmpBvLt n;
cmpLt _ (PCmpSeq _ a (PFinNum n) pa) =
  (\(xs :: Vec n (ty a)) -> \(ys :: Vec n (ty a)) -> \(k :: Bool) ->
    foldr (Bool -> Bool) Bool n (\(f :: Bool -> Bool) -> f) k (vZipWith (ty a) (ty a) (Bool -> Bool) (cmpLt a pa) n xs ys));
cmpLt _ (PCmpPair a b pa pb) =
  (\(x :: #(ty a, ty b)) -> \(y :: #(ty a, ty b)) -> \(k :: Bool) ->
    cmpLt a pa x.1 y.1 (cmpLt b pb x.2 y.2 k));

--------------------------------------------------------------------------------
-- Primitive Cryptol functions

ecDemote :: (val bits :: Num) -> PFin val -> PFin bits -> PGeq bits (tcWidth val) -> seq bits Bool;
ecDemote _ _ (PFinNum val) (PFinNum bits) _ = bvNat bits val;

-- Arith
ecPlus  :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecPlus = arithBinary bvAdd;

ecMinus :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMinus = arithBinary bvSub;

ecMul :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMul = arithBinary bvMul;

ecDiv :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecDiv = arithBinary bvUDiv;

ecMod :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMod = arithBinary bvURem;

ecExp :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecExp = arithBinary bvExp;

ecLg2 :: (a :: KType) -> PArith a -> ty a -> ty a;
ecLg2 = arithUnary bvLg2;

ecNeg :: (a :: KType) -> PArith a -> ty a -> ty a;
ecNeg = arithUnary bvNeg;

-- Cmp
ecLt :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecLt a pa x y = cmpLt a pa x y False;

ecGt :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecGt a pa x y = ecLt a pa y x;

ecLtEq  :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecLtEq a pa x y = not (ecLt a pa y x);

ecGtEq  :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecGtEq a pa x y = not (ecLt a pa x y);

ecEq :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecEq _ PCmpBit = boolEq;
ecEq _ (PCmpSeq _ a (PFinNum n) p) =
  vecEq n (ty a) (ecEq a p);
ecEq _ (PCmpSeq _ _ (PFinNum n) PCmpBit) = bvEq n;
ecEq _ (PCmpPair a b pa pb) =
  (\(x :: #(ty a, ty b)) -> \(y :: #(ty a, ty b)) -> and (ecEq a pa x.1 y.1) (ecEq b pb x.2 y.2));

ecNotEq :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecNotEq a pa x y = not (ecEq a pa x y);

ecFunEq    :: (a b :: KType) -> PCmp b -> (ty a -> ty b) -> (ty a -> ty b) -> ty a -> Bool;
ecFunEq a b pb f g x = ecEq b pb (f x) (g x);

ecFunNotEq :: (a b :: KType) -> PCmp b -> (ty a -> ty b) -> (ty a -> ty b) -> ty a -> Bool;
ecFunNotEq a b pb f g x = ecNotEq b pb (f x) (g x);

ecMin :: (a :: KType) -> PCmp a -> ty a -> ty a -> ty a;
ecMax :: (a :: KType) -> PCmp a -> ty a -> ty a -> ty a;

-- Logic
ecAnd :: (a :: KType) -> ty a -> ty a -> ty a;
ecAnd TCBit = and;
ecAnd (TCSeq n a) = seqBinary n a (ecAnd a);
ecAnd (TCSeq (TCNum n) TCBit) = bvAnd n;
--ecAnd (TCFun a b) = 
ecAnd TCUnit = unitBinary;
ecAnd (TCPair a b) = pairBinary a b (ecAnd a) (ecAnd b);

ecOr :: (a :: KType) -> ty a -> ty a -> ty a;
ecOr TCBit = or;
ecOr (TCSeq n a) = seqBinary n a (ecOr a);
ecOr (TCSeq (TCNum n) TCBit) = bvOr n;
--ecOr (TCFun a b) = 
ecOr TCUnit = unitBinary;
ecOr (TCPair a b) = pairBinary a b (ecOr a) (ecOr b);

ecXor :: (a :: KType) -> ty a -> ty a -> ty a;
ecXor TCBit = xor;
ecXor (TCSeq n a) = seqBinary n a (ecXor a);
ecXor (TCSeq (TCNum n) TCBit) = bvXor n;
--ecXor (TCFun a b) = funMap2 FIXME
ecXor TCUnit = unitBinary;
ecXor (TCPair a b) = pairBinary a b (ecXor a) (ecXor b);

ecCompl :: (a :: KType) -> ty a -> ty a;
ecCompl TCBit = not;
ecCompl (TCSeq n a) = map a a n (ecCompl a);
ecCompl (TCFun a b) = compose (ty a) (ty b) (ty b) (ecCompl b);
--ecCompl TCUnit =
ecCompl (TCPair a b) = pairMap (ty a) (ty a) (ty b) (ty b) (ecCompl a) (ecCompl b);

ecZero  :: (a :: KType) -> ty a;
ecZero TCBit = False;
ecZero (TCSeq n a) = seqConst n (ty a) (ecZero a);
ecZero (TCFun a b) = (\(_::ty a) -> ecZero b);
ecZero TCUnit = ();
ecZero (TCPair a b) = (ecZero a, ecZero b);

-- Sequences
ecShiftL :: (m n :: Num) -> (a :: KType) -> PFin n -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecShiftL (TCNum m) _ TCBit (PFinNum n) xs i = bvShl m xs (bvToNat n i);
ecShiftL TCInf _ a (PFinNum n) xs i = streamDrop (ty a) (bvToNat n i) xs;

ecShiftR :: (m n :: Num) -> (a :: KType) -> PFin n -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecShiftR (TCNum m) _ a (PFinNum n) xs i =
  vTake (ty a) m (bvToNat n i)
    (coerceVec (ty a) (addNat (bvToNat n i) m) (addNat m (bvToNat n i)) (eqNatAddComm (bvToNat n i) m)
      (append (bvToNat n i) m (ty a) (replicate (bvToNat n i) (ty a) (ecZero a)) xs));
ecShiftR TCInf _ a (PFinNum n) xs i =
  streamAppend (ty a) (bvToNat n i) (replicate (bvToNat n i) (ty a) (ecZero a)) xs;

ecRotL :: (m n :: Num) -> (a :: KType) -> PFin m -> PFin n -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecRotL _ _ a (PFinNum m) (PFinNum n) xs i = rotateL m (ty a) xs (bvToNat n i);

ecRotR :: (m n :: Num) -> (a :: KType) -> PFin m -> PFin n -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecRotR _ _ a (PFinNum m) (PFinNum n) xs i = rotateR m (ty a) xs (bvToNat n i);

ecCat :: (m n :: Num) -> (a :: KType) -> PFin m -> seq m (ty a) -> seq n (ty a) -> seq (tcAdd m n) (ty a);
ecCat _ (TCNum n) a (PFinNum m) = append m n (ty a);
ecCat _ TCInf a (PFinNum m) = streamAppend (ty a) m;

ecSplitAt :: (m n :: Num) -> (a :: KType) -> PFin m -> seq (tcAdd m n) (ty a) -> #(seq m (ty a), seq n (ty a));
ecSplitAt _ (TCNum n) a (PFinNum m) xs = (vTake (ty a) m n xs, vDrop (ty a) m n xs);
ecSplitAt _ TCInf a (PFinNum m) xs = (streamTake (ty a) m xs, streamDrop (ty a) m xs);

ecJoin :: (m n :: Num) -> (a :: KType) -> PFin n -> seq m (seq n (ty a)) -> seq (tcMul m n) (ty a);
ecJoin (TCNum m) _ a (PFinNum n) = join m n (ty a);
-- ecJoin TCInf _ a (PFinNum n) = streamJoin ...
-- FIXME: cases on whether n = 0.

ecSplit :: (m n :: Num) -> (a :: KType) -> PFin n -> seq (tcMul m n) (ty a) -> seq m (seq n (ty a));
ecSplit (TCNum m) _ a (PFinNum n) = split m n (ty a);
ecSplit TCInf _ a (PFinNum n) =
  natCase
  (\(n :: Nat) -> seq (ite Num (equalNat 0 n) (TCNum 0) TCInf) (ty a) -> Stream (Vec n (ty a)))
  (streamConst (Vec 0 (ty a))) (\(n :: Nat) -> streamSplit (ty a) (Succ n)) n;

ecReverse :: (n :: Num) -> (a :: KType) -> PFin n -> seq n (ty a) -> seq n (ty a);
ecReverse _ a (PFinNum n) = reverse n (ty a);

ecTranspose :: (m n :: Num) -> (a :: KType) -> seq m (seq n (ty a)) -> seq n (seq m (ty a));
ecTranspose (TCNum m) (TCNum n) a = transpose m n (ty a);
-- TODO: other cases

ecAt :: (n :: Num) -> (a :: KType) -> (i :: Num) -> PFin i -> seq n (ty a) -> seq i Bool -> ty a;
ecAt n a _ (PFinNum i) xs idx = eListSel a n xs (bvToNat i idx);

ecAtRange :: (n :: Num) -> (a :: KType) -> (m i :: Num) -> PFin i -> seq n (ty a) -> seq m (seq i Bool) -> seq m (ty a);
ecAtRange n a m i pi xs = map (TCSeq i TCBit) a m (ecAt n a i pi xs);

ecAtBack :: (n :: Num) -> (a :: KType) -> (i :: Num) -> PFin n -> PFin i -> seq n (ty a) -> seq i Bool -> (ty a);
ecAtBack n a i pn pi xs = ecAt n a i pi (ecReverse n a pn xs);

ecAtRangeBack :: (n :: Num) -> (a :: KType) -> (m i :: Num) -> PFin n -> PFin i -> seq n (ty a) -> seq m (seq i Bool) -> seq m (ty a);
ecAtRangeBack n a m i pn pi xs = map (TCSeq i TCBit) a m (ecAtBack n a i pn pi xs);

-- Static word sequences
ecFromThen :: (first next bits len :: Num) -> PFin first -> PFin next -> PFin bits
           -> PGeq bits (tcWidth first) -> PGeq bits (tcWidth next)
           -> PEqual (tcLenFromThen first next bits) len
           -> seq len (seq bits Bool);

ecFromTo :: (first last bits :: Num) -> PFin last -> PFin bits
         -> PGeq last first -> PGeq bits (tcWidth last)
         -> seq (tcAdd (TCNum 1) (tcSub last first)) (seq bits Bool);
ecFromTo (TCNum first) _ _ (PFinNum last) (PFinNum bits) _ _ =
  generate (addNat 1 (subNat last first)) (Vec bits Bool)
    (\(i::Fin (addNat 1 (subNat last first))) ->
      bvNat bits (addNat (finFront (addNat 1 (subNat last first)) i) first));

-- Infinite word sequences
ecInfFrom :: (n :: Num) -> PFin n -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFrom _ (PFinNum n) w = MkStream (bitvector n) (\(i :: Nat) -> bvAdd n w (bvNat n i));

ecInfFromThen :: (n :: Num) -> PFin n -> seq n Bool -> seq n Bool -> seq TCInf (seq n Bool);

-- Run-time error
ecError :: (a :: KType) -> (len :: Num) -> PFin len -> seq len (bitvector 8) -> ty a;

-- Polynomials
ecPMul :: (a b :: Num) -> PFin a -> PFin b -> seq a Bool -> seq b Bool
       -> seq (tcSub (tcMax (TCNum 1) (tcAdd a b)) (TCNum 1)) Bool;
ecPMul _ _ (PFinNum a) (PFinNum b) = bvPMul a b;

ecPDiv :: (a b :: Num) -> PFin a -> PFin b
       -> seq a Bool -> seq b Bool -> seq a Bool;
ecPDiv _ _ (PFinNum a) (PFinNum b) = bvPDiv a b;

ecPMod :: (a b :: Num) -> PFin a -> PFin b
       -> seq a Bool -> seq (tcAdd (TCNum 1) b) Bool -> seq b Bool;
ecPMod _ _ (PFinNum a) (PFinNum b) = bvPMod a b;

-- Random values
ecRandom :: (a :: KType) -> bitvector 32 -> ty a;


--------------------------------------------------------------------------------
-- Rewrite rules

replicate_False :: (n :: Nat) -> Eq (bitvector n) (replicate n Bool False) (bvNat n 0);

eCast_same :: (a :: KType) -> (x :: ty a) -> Eq (ty a) (eCast a a x) x;

subNat_0 :: (n :: Nat) -> Eq Nat (subNat n 0) n;

-- TODO: implement these rules more generally with conversions:
subNat_5_1 :: Eq Nat (subNat 5 1) 4;
widthNat_4 :: Eq Nat (widthNat 4) 3;
widthNat_5 :: Eq Nat (widthNat 5) 3;

--------------------------------------------------------------------------------
