From Coq          Require Import Lists.List.
Import            ListNotations.
From Coq          Require Import String.
From Coq          Require Import Vectors.Vector.
From CryptolToCoq Require Import SAWCoreScaffolding.
From CryptolToCoq Require Import SAWCoreVectorsAsCoqVectors.
From Records      Require Import Records.

From CryptolToCoq Require Import SAWCorePrelude.
Import SAWCorePrelude.

Module CryptolPrimitives.

Definition const : forall (a : Type), forall (b : Type), (a) -> (b) -> a :=
  (fun (a : Type) (b : Type) (x : a) (y : b) => x).

Definition compose : forall (a : Type), forall (b : Type), forall (c : Type), ((b) -> c) -> ((a) -> b) -> (a) -> c :=
  (fun (_ : Type) (_ : Type) (_ : Type) (f : (_) -> _) (g : (_) -> _) (x : _) => (f ((g (x))))).

Definition bvExp : forall (n : (@Nat)), ((@SAWCorePrelude.bitvector (n))) -> ((@SAWCorePrelude.bitvector (n))) -> (@SAWCorePrelude.bitvector (n)) :=
  (fun (n : (@Nat)) (x : (@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool))) (y : (@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool))) => (@SAWCoreVectorsAsCoqVectors.foldr (@SAWCoreScaffolding.Bool) ((@SAWCorePrelude.bitvector (n))) (n) ((fun (b : @SAWCoreScaffolding.Bool) (a : (@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool))) => if b then (@SAWCorePrelude.bvMul (n) (x) ((@SAWCorePrelude.bvMul (n) (a) (a)))) else (@SAWCorePrelude.bvMul (n) (a) (a)))) ((@SAWCoreVectorsAsCoqVectors.bvNat (n) (1))) ((@SAWCorePrelude.reverse (n) (@SAWCoreScaffolding.Bool) (y))))).

Definition updFst : forall (a : Type), forall (b : Type), ((a) -> a) -> ((prod (a) (b))) -> (prod (a) (b)) :=
  (fun (a : Type) (b : Type) (f : (a) -> a) (x : (prod (a) (b))) => (pair ((f ((fst (x))))) ((snd (x))))).

Definition updSnd : forall (a : Type), forall (b : Type), ((b) -> b) -> ((prod (a) (b))) -> (prod (a) (b)) :=
  (fun (a : Type) (b : Type) (f : (b) -> b) (x : (prod (a) (b))) => (pair ((fst (x))) ((f ((snd (x))))))).

Inductive Num : Type :=
| TCNum : ((@Nat)) -> (@Num)
| TCInf : (@Num)
.

(* Cryptol.Num_rec was skipped *)

Definition getFinNat : forall (n : (@Num)), (@Nat) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (@Nat))) ((fun (n : (@Nat)) => n)) ((@SAWCoreScaffolding.error ((@Nat)) (("Unexpected Fin constraint violation!")%string))) (n))).

Definition finNumRec : forall (p : ((@Num)) -> Type), (forall (n : (@Nat)), (p ((@TCNum (n))))) -> forall (n : (@Num)), (p (n)) :=
  (fun (p : ((@Num)) -> Type) (f : forall (n : (@Nat)), (p ((@TCNum (n))))) (n : (@Num)) => (@Num_rect (p) (f) ((@SAWCoreScaffolding.error ((p ((@TCInf)))) (("Unexpected Fin constraint violation!")%string))) (n))).

Definition finNumRec2 : forall (p : ((@Num)) -> ((@Num)) -> Type), (forall (m : (@Nat)), forall (n : (@Nat)), (p ((@TCNum (m))) ((@TCNum (n))))) -> forall (m : (@Num)), forall (n : (@Num)), (p (m) (n)) :=
  (fun (p : ((@Num)) -> ((@Num)) -> Type) (f : forall (m : (@Nat)), forall (n : (@Nat)), (p ((@TCNum (m))) ((@TCNum (n))))) => (@CryptolPrimitives.finNumRec ((fun (m : (@Num)) => forall (n : (@Num)), (p (m) (n)))) ((fun (m : (@Nat)) => (@CryptolPrimitives.finNumRec ((p ((@TCNum (m))))) ((f (m)))))))).

Definition binaryNumFun : (((@Nat)) -> ((@Nat)) -> (@Nat)) -> (((@Nat)) -> (@Num)) -> (((@Nat)) -> (@Num)) -> ((@Num)) -> ((@Num)) -> ((@Num)) -> (@Num) :=
  (fun (f1 : ((@Nat)) -> ((@Nat)) -> (@Nat)) (f2 : ((@Nat)) -> (@Num)) (f3 : ((@Nat)) -> (@Num)) (f4 : (@Num)) (num1 : (@Num)) (num2 : (@Num)) => (@Num_rect ((fun (num1' : (@Num)) => (@Num))) ((fun (n1 : (@Nat)) => (@Num_rect ((fun (num2' : (@Num)) => (@Num))) ((fun (n2 : (@Nat)) => (@TCNum ((f1 (n1) (n2)))))) ((f2 (n1))) (num2)))) ((@Num_rect ((fun (num2' : (@Num)) => (@Num))) (f3) (f4) (num2))) (num1))).

Definition ternaryNumFun : (((@Nat)) -> ((@Nat)) -> ((@Nat)) -> (@Nat)) -> ((@Num)) -> ((@Num)) -> ((@Num)) -> ((@Num)) -> (@Num) :=
  (fun (f1 : ((@Nat)) -> ((@Nat)) -> ((@Nat)) -> (@Nat)) (f2 : (@Num)) (num1 : (@Num)) (num2 : (@Num)) (num3 : (@Num)) => (@Num_rect ((fun (num1' : (@Num)) => (@Num))) ((fun (n1 : (@Nat)) => (@Num_rect ((fun (num2' : (@Num)) => (@Num))) ((fun (n2 : (@Nat)) => (@Num_rect ((fun (num3' : (@Num)) => (@Num))) ((fun (n3 : (@Nat)) => (@TCNum ((f1 (n1) (n2) (n3)))))) (f2) (num3)))) (f2) (num2)))) (f2) (num1))).

Definition tcWidth : ((@Num)) -> (@Num) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (@Num))) ((fun (x : (@Nat)) => (@TCNum ((@SAWCoreScaffolding.widthNat (x)))))) ((@TCInf)) (n))).

Definition tcAdd : ((@Num)) -> ((@Num)) -> (@Num) :=
  (@CryptolPrimitives.binaryNumFun (@SAWCorePrelude.addNat) ((fun (x : (@Nat)) => (@TCInf))) ((fun (y : (@Nat)) => (@TCInf))) ((@TCInf))).

Definition tcSub : ((@Num)) -> ((@Num)) -> (@Num) :=
  (@CryptolPrimitives.binaryNumFun (@SAWCorePrelude.subNat) ((fun (x : (@Nat)) => (@TCNum (0)))) ((fun (y : (@Nat)) => (@TCInf))) ((@TCNum (0)))).

Definition tcMul : ((@Num)) -> ((@Num)) -> (@Num) :=
  (@CryptolPrimitives.binaryNumFun (@SAWCorePrelude.mulNat) ((fun (x : (@Nat)) => (@SAWCorePrelude.if0Nat ((@Num)) (x) ((@TCNum (0))) ((@TCInf))))) ((fun (y : (@Nat)) => (@SAWCorePrelude.if0Nat ((@Num)) (y) ((@TCNum (0))) ((@TCInf))))) ((@TCInf))).

Definition tcDiv : ((@Num)) -> ((@Num)) -> (@Num) :=
  (@CryptolPrimitives.binaryNumFun ((fun (x : (@Nat)) (y : (@Nat)) => (@SAWCorePrelude.divNat (x) (y)))) ((fun (x : (@Nat)) => (@TCNum (0)))) ((fun (y : (@Nat)) => (@TCInf))) ((@TCNum (1)))).

Definition tcMod : ((@Num)) -> ((@Num)) -> (@Num) :=
  (@CryptolPrimitives.binaryNumFun ((fun (x : (@Nat)) (y : (@Nat)) => (@SAWCorePrelude.modNat (x) (y)))) ((fun (x : (@Nat)) => (@TCNum (0)))) ((fun (y : (@Nat)) => (@TCNum (0)))) ((@TCNum (0)))).

Definition tcExp : ((@Num)) -> ((@Num)) -> (@Num) :=
  (@CryptolPrimitives.binaryNumFun (@SAWCorePrelude.expNat) ((fun (x : (@Nat)) => (@SAWCorePrelude.natCase ((fun (_ : (@Nat)) => (@Num))) ((@TCNum (0))) ((fun (x_minus_1 : (@Nat)) => (@SAWCorePrelude.if0Nat ((@Num)) (x_minus_1) ((@TCNum (1))) ((@TCInf))))) (x)))) ((fun (y : (@Nat)) => (@SAWCorePrelude.if0Nat ((@Num)) (y) ((@TCNum (1))) ((@TCInf))))) ((@TCInf))).

Definition tcMin : ((@Num)) -> ((@Num)) -> (@Num) :=
  (@CryptolPrimitives.binaryNumFun (@SAWCorePrelude.minNat) ((fun (x : (@Nat)) => (@TCNum (x)))) ((fun (y : (@Nat)) => (@TCNum (y)))) ((@TCInf))).

Definition tcMax : ((@Num)) -> ((@Num)) -> (@Num) :=
  (@CryptolPrimitives.binaryNumFun (@SAWCorePrelude.maxNat) ((fun (x : (@Nat)) => (@TCInf))) ((fun (y : (@Nat)) => (@TCInf))) ((@TCInf))).

Definition ceilDivNat : ((@Nat)) -> ((@Nat)) -> (@Nat) :=
  (fun (x : (@Nat)) (y : (@Nat)) => (@SAWCorePrelude.divNat ((@SAWCorePrelude.addNat (x) ((@SAWCorePrelude.subNat (y) (1))))) (y))).

Definition ceilModNat : ((@Nat)) -> ((@Nat)) -> (@Nat) :=
  (fun (x : (@Nat)) (y : (@Nat)) => (@SAWCorePrelude.subNat ((@SAWCorePrelude.mulNat ((@CryptolPrimitives.ceilDivNat (x) (y))) (y))) (x))).

Definition tcCeilDiv : ((@Num)) -> ((@Num)) -> (@Num) :=
  (@CryptolPrimitives.binaryNumFun (@CryptolPrimitives.ceilDivNat) ((fun (x : (@Nat)) => (@TCNum (0)))) ((fun (y : (@Nat)) => (@TCInf))) ((@TCInf))).

Definition tcCeilMod : ((@Num)) -> ((@Num)) -> (@Num) :=
  (@CryptolPrimitives.binaryNumFun (@CryptolPrimitives.ceilModNat) ((fun (x : (@Nat)) => (@TCNum (0)))) ((fun (y : (@Nat)) => (@TCInf))) ((@TCInf))).

Definition tcLenFromThenTo_Nat : ((@Nat)) -> ((@Nat)) -> ((@Nat)) -> (@Nat) :=
  (fun (x : (@Nat)) (y : (@Nat)) (z : (@Nat)) => if (@SAWCorePrelude.ltNat (x) (y)) then if (@SAWCorePrelude.ltNat (z) (x)) then 0 else (@SAWCorePrelude.addNat ((@SAWCorePrelude.divNat ((@SAWCorePrelude.subNat (z) (x))) ((@SAWCorePrelude.subNat (y) (x))))) (1)) else if (@SAWCorePrelude.ltNat (x) (z)) then 0 else (@SAWCorePrelude.addNat ((@SAWCorePrelude.divNat ((@SAWCorePrelude.subNat (x) (z))) ((@SAWCorePrelude.subNat (x) (y))))) (1))).

Definition tcLenFromThenTo : ((@Num)) -> ((@Num)) -> ((@Num)) -> (@Num) :=
  (@CryptolPrimitives.ternaryNumFun (@CryptolPrimitives.tcLenFromThenTo_Nat) ((@TCInf))).

Definition seq : ((@Num)) -> (Type) -> Type :=
  (fun (num : (@Num)) (a : Type) => (@Num_rect ((fun (num : (@Num)) => Type)) ((fun (n : (@Nat)) => (@SAWCoreVectorsAsCoqVectors.Vec (n) (a)))) ((@Stream (a))) (num))).

Definition seq_TCNum : forall (n : (@Nat)), forall (a : Type), (@Eq (Type) ((@CryptolPrimitives.seq ((@TCNum (n))) (a))) ((@SAWCoreVectorsAsCoqVectors.Vec (n) (a)))) :=
  (fun (n : (@Nat)) (a : Type) => (@Refl (Type) ((@SAWCoreVectorsAsCoqVectors.Vec (n) (a))))).

Definition seq_TCInf : forall (a : Type), (@Eq (Type) ((@CryptolPrimitives.seq ((@TCInf)) (a))) ((@Stream (a)))) :=
  (fun (a : Type) => (@Refl (Type) ((@Stream (a))))).

Definition seqMap : forall (a : Type), forall (b : Type), forall (n : (@Num)), ((a) -> b) -> ((@CryptolPrimitives.seq (n) (a))) -> (@CryptolPrimitives.seq (n) (b)) :=
  (fun (a : Type) (b : Type) (num : (@Num)) (f : (a) -> b) => (@Num_rect ((fun (n : (@Num)) => ((@CryptolPrimitives.seq (n) (a))) -> (@CryptolPrimitives.seq (n) (b)))) ((@SAWCorePrelude.map (a) (b) (f))) ((@SAWCorePrelude.streamMap (a) (b) (f))) (num))).

Definition seqConst : forall (n : (@Num)), forall (a : Type), (a) -> (@CryptolPrimitives.seq (n) (a)) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => forall (a : Type), (a) -> (@CryptolPrimitives.seq (n) (a)))) (@SAWCorePrelude.replicate) (@SAWCorePrelude.streamConst) (n))).

Definition IntModNum : forall (num : (@Num)), Type :=
  (fun (num : (@Num)) => (@Num_rect ((fun (n : (@Num)) => Type)) (@SAWCorePrelude.IntMod) (@SAWCorePrelude.Integer) (num))).

Definition seq_cong : forall (m : (@Num)), forall (n : (@Num)), forall (a : Type), forall (b : Type), ((@Eq ((@Num)) (m) (n))) -> ((@Eq (Type) (a) (b))) -> (@Eq (Type) ((@CryptolPrimitives.seq (m) (a))) ((@CryptolPrimitives.seq (n) (b)))) :=
  (fun (m : (@Num)) (n : (@Num)) (a : Type) (b : Type) (eq_mn : (@Eq ((@Num)) (m) (n))) (eq_ab : (@Eq (Type) (a) (b))) => (@SAWCorePrelude.trans (Type) ((@CryptolPrimitives.seq (m) (a))) ((@CryptolPrimitives.seq (n) (a))) ((@CryptolPrimitives.seq (n) (b))) ((@SAWCorePrelude.eq_cong ((@Num)) (m) (n) (eq_mn) (Type) ((fun (x : (@Num)) => (@CryptolPrimitives.seq (x) (a)))))) ((@SAWCorePrelude.eq_cong (Type) (a) (b) (eq_ab) (Type) ((fun (x : Type) => (@CryptolPrimitives.seq (n) (x)))))))).

Definition seq_cong1 : forall (m : (@Num)), forall (n : (@Num)), forall (a : Type), ((@Eq ((@Num)) (m) (n))) -> (@Eq (Type) ((@CryptolPrimitives.seq (m) (a))) ((@CryptolPrimitives.seq (n) (a)))) :=
  (fun (m : (@Num)) (n : (@Num)) (a : Type) (eq_mn : (@Eq ((@Num)) (m) (n))) => (@SAWCorePrelude.eq_cong ((@Num)) (m) (n) (eq_mn) (Type) ((fun (x : (@Num)) => (@CryptolPrimitives.seq (x) (a)))))).

Definition fun_cong : forall (a : Type), forall (b : Type), forall (c : Type), forall (d : Type), ((@Eq (Type) (a) (b))) -> ((@Eq (Type) (c) (d))) -> (@Eq (Type) ((a) -> c) ((b) -> d)) :=
  (fun (a : Type) (b : Type) (c : Type) (d : Type) (eq_ab : (@Eq (Type) (a) (b))) (eq_cd : (@Eq (Type) (c) (d))) => (@SAWCorePrelude.trans (Type) ((a) -> c) ((b) -> c) ((b) -> d) ((@SAWCorePrelude.eq_cong (Type) (a) (b) (eq_ab) (Type) ((fun (x : Type) => (x) -> c)))) ((@SAWCorePrelude.eq_cong (Type) (c) (d) (eq_cd) (Type) ((fun (x : Type) => (b) -> x)))))).

Definition pair_cong : forall (a : Type), forall (a' : Type), forall (b : Type), forall (b' : Type), ((@Eq (Type) (a) (a'))) -> ((@Eq (Type) (b) (b'))) -> (@Eq (Type) ((prod (a) (b))) ((prod (a') (b')))) :=
  (fun (a : Type) (a' : Type) (b : Type) (b' : Type) (eq_a : (@Eq (Type) (a) (a'))) (eq_b : (@Eq (Type) (b) (b'))) => (@SAWCorePrelude.trans (Type) ((prod (a) (b))) ((prod (a') (b))) ((prod (a') (b'))) ((@SAWCorePrelude.eq_cong (Type) (a) (a') (eq_a) (Type) ((fun (x : Type) => (prod (x) (b)))))) ((@SAWCorePrelude.eq_cong (Type) (b) (b') (eq_b) (Type) ((fun (x : Type) => (prod (a') (x)))))))).

Definition pair_cong1 : forall (a : Type), forall (a' : Type), forall (b : Type), ((@Eq (Type) (a) (a'))) -> (@Eq (Type) ((prod (a) (b))) ((prod (a') (b)))) :=
  (fun (a : Type) (a' : Type) (b : Type) (eq_a : (@Eq (Type) (a) (a'))) => (@SAWCorePrelude.eq_cong (Type) (a) (a') (eq_a) (Type) ((fun (x : Type) => (prod (x) (b)))))).

Definition pair_cong2 : forall (a : Type), forall (b : Type), forall (b' : Type), ((@Eq (Type) (b) (b'))) -> (@Eq (Type) ((prod (a) (b))) ((prod (a) (b')))) :=
  (fun (a : Type) (b : Type) (b' : Type) (eq_b : (@Eq (Type) (b) (b'))) => (@SAWCorePrelude.eq_cong (Type) (b) (b') (eq_b) (Type) ((fun (x : Type) => (prod (a) (x)))))).

(* Cryptol.unsafeAssert_same_Num was skipped *)

Definition eListSel : forall (a : Type), forall (n : (@Num)), ((@CryptolPrimitives.seq (n) (a))) -> ((@Nat)) -> a :=
  (fun (a : Type) (n : (@Num)) => (@Num_rect ((fun (num : (@Num)) => ((@CryptolPrimitives.seq (num) (a))) -> ((@Nat)) -> a)) ((fun (n : (@Nat)) => (@SAWCorePrelude.sawAt (n) (a)))) ((@SAWCorePrelude.streamGet (a))) (n))).

Definition from : forall (a : Type), forall (b : Type), forall (m : (@Num)), forall (n : (@Num)), ((@CryptolPrimitives.seq (m) (a))) -> ((a) -> (@CryptolPrimitives.seq (n) (b))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul (m) (n))) ((prod (a) (b)))) :=
  (fun (a : Type) (b : Type) (m : (@Num)) (n : (@Num)) => (@Num_rect ((fun (m : (@Num)) => ((@CryptolPrimitives.seq (m) (a))) -> ((a) -> (@CryptolPrimitives.seq (n) (b))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul (m) (n))) ((prod (a) (b)))))) ((fun (m : (@Nat)) => (@Num_rect ((fun (n : (@Num)) => ((@SAWCoreVectorsAsCoqVectors.Vec (m) (a))) -> ((a) -> (@CryptolPrimitives.seq (n) (b))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul ((@TCNum (m))) (n))) ((prod (a) (b)))))) ((fun (n : (@Nat)) (xs : (@SAWCoreVectorsAsCoqVectors.Vec (m) (a))) (k : (a) -> (@SAWCoreVectorsAsCoqVectors.Vec (n) (b))) => (@SAWCorePrelude.join (m) (n) ((prod (a) (b))) ((@SAWCorePrelude.map (a) ((@SAWCoreVectorsAsCoqVectors.Vec (n) ((prod (a) (b))))) ((fun (x : a) => (@SAWCorePrelude.map (b) ((prod (a) (b))) ((fun (y : b) => (pair (x) (y)))) (n) ((k (x)))))) (m) (xs)))))) ((@SAWCorePrelude.natCase ((fun (m' : (@Nat)) => ((@SAWCoreVectorsAsCoqVectors.Vec (m') (a))) -> ((a) -> (@Stream (b))) -> (@CryptolPrimitives.seq ((@SAWCorePrelude.if0Nat ((@Num)) (m') ((@TCNum (0))) ((@TCInf)))) ((prod (a) (b)))))) ((fun (xs : (@SAWCoreVectorsAsCoqVectors.Vec (0) (a))) (k : (a) -> (@Stream (b))) => (@SAWCoreVectorsAsCoqVectors.EmptyVec ((prod (a) (b)))))) ((fun (m' : (@Nat)) (xs : (@SAWCoreVectorsAsCoqVectors.Vec ((@Succ (m'))) (a))) (k : (a) -> (@Stream (b))) => ((fun (x : a) => (@SAWCorePrelude.streamMap (b) ((prod (a) (b))) ((fun (y : b) => (pair (x) (y)))) ((k (x))))) ((@SAWCorePrelude.sawAt ((@Succ (m'))) (a) (xs) (0)))))) (m))) (n)))) ((@Num_rect ((fun (n : (@Num)) => ((@Stream (a))) -> ((a) -> (@CryptolPrimitives.seq (n) (b))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul ((@TCInf)) (n))) ((prod (a) (b)))))) ((fun (n : (@Nat)) => (@SAWCorePrelude.natCase ((fun (n' : (@Nat)) => ((@Stream (a))) -> ((a) -> (@SAWCoreVectorsAsCoqVectors.Vec (n') (b))) -> (@CryptolPrimitives.seq ((@SAWCorePrelude.if0Nat ((@Num)) (n') ((@TCNum (0))) ((@TCInf)))) ((prod (a) (b)))))) ((fun (xs : (@Stream (a))) (k : (a) -> (@SAWCoreVectorsAsCoqVectors.Vec (0) (b))) => (@SAWCoreVectorsAsCoqVectors.EmptyVec ((prod (a) (b)))))) ((fun (n' : (@Nat)) (xs : (@Stream (a))) (k : (a) -> (@SAWCoreVectorsAsCoqVectors.Vec ((@Succ (n'))) (b))) => (@SAWCorePrelude.streamJoin ((prod (a) (b))) (n') ((@SAWCorePrelude.streamMap (a) ((@SAWCoreVectorsAsCoqVectors.Vec ((@Succ (n'))) ((prod (a) (b))))) ((fun (x : a) => (@SAWCorePrelude.map (b) ((prod (a) (b))) ((fun (y : b) => (pair (x) (y)))) ((@Succ (n'))) ((k (x)))))) (xs)))))) (n)))) ((fun (xs : (@Stream (a))) (k : (a) -> (@Stream (b))) => ((fun (x : a) => (@SAWCorePrelude.streamMap (b) ((prod (a) (b))) ((fun (y : b) => (pair (x) (y)))) ((k (x))))) ((@SAWCorePrelude.streamGet (a) (xs) (0)))))) (n))) (m))).

Definition mlet : forall (a : Type), forall (b : Type), forall (n : (@Num)), (a) -> ((a) -> (@CryptolPrimitives.seq (n) (b))) -> (@CryptolPrimitives.seq (n) ((prod (a) (b)))) :=
  (fun (a : Type) (b : Type) (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (a) -> ((a) -> (@CryptolPrimitives.seq (n) (b))) -> (@CryptolPrimitives.seq (n) ((prod (a) (b)))))) ((fun (n : (@Nat)) (x : a) (f : (a) -> (@SAWCoreVectorsAsCoqVectors.Vec (n) (b))) => (@SAWCorePrelude.map (b) ((prod (a) (b))) ((fun (y : b) => (pair (x) (y)))) (n) ((f (x)))))) ((fun (x : a) (f : (a) -> (@Stream (b))) => (@SAWCorePrelude.streamMap (b) ((prod (a) (b))) ((fun (y : b) => (pair (x) (y)))) ((f (x)))))) (n))).

Definition seqZip : forall (a : Type), forall (b : Type), forall (m : (@Num)), forall (n : (@Num)), ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (b))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMin (m) (n))) ((prod (a) (b)))) :=
  (fun (a : Type) (b : Type) (m : (@Num)) (n : (@Num)) => (@Num_rect ((fun (m : (@Num)) => ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (b))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMin (m) (n))) ((prod (a) (b)))))) ((fun (m : (@Nat)) => (@Num_rect ((fun (n : (@Num)) => ((@SAWCoreVectorsAsCoqVectors.Vec (m) (a))) -> ((@CryptolPrimitives.seq (n) (b))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMin ((@TCNum (m))) (n))) ((prod (a) (b)))))) ((fun (n : (@Nat)) => (@SAWCorePrelude.zip (a) (b) (m) (n)))) ((fun (xs : (@SAWCoreVectorsAsCoqVectors.Vec (m) (a))) (ys : (@Stream (b))) => (@SAWCoreVectorsAsCoqVectors.gen (m) ((prod (a) (b))) ((fun (i : (@Nat)) => (pair ((@SAWCorePrelude.sawAt (m) (a) (xs) (i))) ((@SAWCorePrelude.streamGet (b) (ys) (i))))))))) (n)))) ((@Num_rect ((fun (n : (@Num)) => ((@Stream (a))) -> ((@CryptolPrimitives.seq (n) (b))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMin ((@TCInf)) (n))) ((prod (a) (b)))))) ((fun (n : (@Nat)) (xs : (@Stream (a))) (ys : (@SAWCoreVectorsAsCoqVectors.Vec (n) (b))) => (@SAWCoreVectorsAsCoqVectors.gen (n) ((prod (a) (b))) ((fun (i : (@Nat)) => (pair ((@SAWCorePrelude.streamGet (a) (xs) (i))) ((@SAWCorePrelude.sawAt (n) (b) (ys) (i))))))))) ((@SAWCorePrelude.streamMap2 (a) (b) ((prod (a) (b))) ((fun (x : a) (y : b) => (pair (x) (y)))))) (n))) (m))).

Definition seqBinary : forall (n : (@Num)), forall (a : Type), ((a) -> (a) -> a) -> ((@CryptolPrimitives.seq (n) (a))) -> ((@CryptolPrimitives.seq (n) (a))) -> (@CryptolPrimitives.seq (n) (a)) :=
  (fun (num : (@Num)) (a : Type) (f : (a) -> (a) -> a) => (@Num_rect ((fun (n : (@Num)) => ((@CryptolPrimitives.seq (n) (a))) -> ((@CryptolPrimitives.seq (n) (a))) -> (@CryptolPrimitives.seq (n) (a)))) ((fun (n : (@Nat)) => (@SAWCorePrelude.zipWith (a) (a) (a) (f) (n)))) ((@SAWCorePrelude.streamMap2 (a) (a) (a) (f))) (num))).

Definition unitUnary : (unit) -> unit :=
  (fun (_ : unit) => tt).

Definition unitBinary : (unit) -> (unit) -> unit :=
  (fun (_ : unit) (_ : unit) => tt).

Definition pairUnary : forall (a : Type), forall (b : Type), ((a) -> a) -> ((b) -> b) -> ((prod (a) (b))) -> (prod (a) (b)) :=
  (fun (a : Type) (b : Type) (f : (a) -> a) (g : (b) -> b) (xy : (prod (a) (b))) => (pair ((f ((@SAWCoreScaffolding.fst (a) (b) (xy))))) ((g ((@SAWCoreScaffolding.snd (a) (b) (xy))))))).

Definition pairBinary : forall (a : Type), forall (b : Type), ((a) -> (a) -> a) -> ((b) -> (b) -> b) -> ((prod (a) (b))) -> ((prod (a) (b))) -> (prod (a) (b)) :=
  (fun (a : Type) (b : Type) (f : (a) -> (a) -> a) (g : (b) -> (b) -> b) (x12 : (prod (a) (b))) (y12 : (prod (a) (b))) => (pair ((f ((@SAWCoreScaffolding.fst (a) (b) (x12))) ((@SAWCoreScaffolding.fst (a) (b) (y12))))) ((g ((@SAWCoreScaffolding.snd (a) (b) (x12))) ((@SAWCoreScaffolding.snd (a) (b) (y12))))))).

Definition funBinary : forall (a : Type), forall (b : Type), ((b) -> (b) -> b) -> ((a) -> b) -> ((a) -> b) -> (a) -> b :=
  (fun (a : Type) (b : Type) (op : (b) -> (b) -> b) (f : (a) -> b) (g : (a) -> b) (x : a) => (op ((f (x))) ((g (x))))).

Definition errorUnary : forall (s : @SAWCoreScaffolding.String), forall (a : Type), (a) -> a :=
  (fun (s : @SAWCoreScaffolding.String) (a : Type) (_ : a) => (@SAWCoreScaffolding.error (a) (s))).

Definition errorBinary : forall (s : @SAWCoreScaffolding.String), forall (a : Type), (a) -> (a) -> a :=
  (fun (s : @SAWCoreScaffolding.String) (a : Type) (_ : a) (_ : a) => (@SAWCoreScaffolding.error (a) (s))).

Definition boolCmp : (@SAWCoreScaffolding.Bool) -> (@SAWCoreScaffolding.Bool) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool :=
  (fun (x : @SAWCoreScaffolding.Bool) (y : @SAWCoreScaffolding.Bool) (k : @SAWCoreScaffolding.Bool) => if x then (@SAWCoreScaffolding.and (y) (k)) else (@SAWCoreScaffolding.or (y) (k))).

Definition integerCmp : (@SAWCorePrelude.Integer) -> (@SAWCorePrelude.Integer) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool :=
  (fun (x : @SAWCorePrelude.Integer) (y : @SAWCorePrelude.Integer) (k : @SAWCoreScaffolding.Bool) => (@SAWCoreScaffolding.or ((@SAWCorePrelude.intLt (x) (y))) ((@SAWCoreScaffolding.and ((@SAWCorePrelude.intEq (x) (y))) (k))))).

Definition bvCmp : forall (n : (@Nat)), ((@SAWCorePrelude.bitvector (n))) -> ((@SAWCorePrelude.bitvector (n))) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool :=
  (fun (n : (@Nat)) (x : (@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool))) (y : (@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool))) (k : @SAWCoreScaffolding.Bool) => (@SAWCoreScaffolding.or ((@SAWCorePrelude.bvult (n) (x) (y))) ((@SAWCoreScaffolding.and ((@SAWCorePrelude.bvEq (n) (x) (y))) (k))))).

Definition bvSCmp : forall (n : (@Nat)), ((@SAWCorePrelude.bitvector (n))) -> ((@SAWCorePrelude.bitvector (n))) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool :=
  (fun (n : (@Nat)) (x : (@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool))) (y : (@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool))) (k : @SAWCoreScaffolding.Bool) => (@SAWCoreScaffolding.or ((@SAWCorePrelude.bvslt (n) (x) (y))) ((@SAWCoreScaffolding.and ((@SAWCorePrelude.bvEq (n) (x) (y))) (k))))).

Definition vecCmp : forall (n : (@Nat)), forall (a : Type), ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool) -> ((@SAWCoreVectorsAsCoqVectors.Vec (n) (a))) -> ((@SAWCoreVectorsAsCoqVectors.Vec (n) (a))) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool :=
  (fun (n : (@Nat)) (a : Type) (f : (a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool) (xs : (@SAWCoreVectorsAsCoqVectors.Vec (n) (a))) (ys : (@SAWCoreVectorsAsCoqVectors.Vec (n) (a))) (k : @SAWCoreScaffolding.Bool) => (@SAWCoreVectorsAsCoqVectors.foldr ((@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool) (@SAWCoreScaffolding.Bool) (n) ((fun (f : (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool) => f)) (k) ((@SAWCorePrelude.zipWith (a) (a) ((@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool) (f) (n) (xs) (ys))))).

Definition unitCmp : (unit) -> (unit) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool :=
  (fun (_ : unit) (_ : unit) (_ : @SAWCoreScaffolding.Bool) => @SAWCoreScaffolding.False).

Definition pairEq : forall (a : Type), forall (b : Type), ((a) -> (a) -> @SAWCoreScaffolding.Bool) -> ((b) -> (b) -> @SAWCoreScaffolding.Bool) -> ((prod (a) (b))) -> ((prod (a) (b))) -> @SAWCoreScaffolding.Bool :=
  (fun (a : Type) (b : Type) (f : (a) -> (a) -> @SAWCoreScaffolding.Bool) (g : (b) -> (b) -> @SAWCoreScaffolding.Bool) (x : (prod (a) (b))) (y : (prod (a) (b))) => (@SAWCoreScaffolding.and ((f ((@SAWCoreScaffolding.fst (a) (b) (x))) ((@SAWCoreScaffolding.fst (a) (b) (y))))) ((g ((@SAWCoreScaffolding.snd (a) (b) (x))) ((@SAWCoreScaffolding.snd (a) (b) (y))))))).

Definition pairCmp : forall (a : Type), forall (b : Type), ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool) -> ((b) -> (b) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool) -> ((prod (a) (b))) -> ((prod (a) (b))) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool :=
  (fun (a : Type) (b : Type) (f : (a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool) (g : (b) -> (b) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool) (x12 : (prod (a) (b))) (y12 : (prod (a) (b))) (k : @SAWCoreScaffolding.Bool) => (f ((@SAWCoreScaffolding.fst (a) (b) (x12))) ((@SAWCoreScaffolding.fst (a) (b) (y12))) ((g ((@SAWCoreScaffolding.snd (a) (b) (x12))) ((@SAWCoreScaffolding.snd (a) (b) (y12))) (k))))).

Definition PZero : (Type) -> Type :=
  (fun (a : Type) => a).

Definition PZeroBit : (@CryptolPrimitives.PZero (@SAWCoreScaffolding.Bool)) :=
  @SAWCoreScaffolding.False.

Definition PZeroInteger : (@CryptolPrimitives.PZero (@SAWCorePrelude.Integer)) :=
  (@SAWCorePrelude.natToInt (0)).

Definition PZeroIntMod : forall (n : (@Nat)), (@CryptolPrimitives.PZero ((@SAWCorePrelude.IntMod (n)))) :=
  (fun (n : (@Nat)) => (@SAWCorePrelude.toIntMod (n) ((@SAWCorePrelude.natToInt (0))))).

Definition PZeroIntModNum : forall (num : (@Num)), (@CryptolPrimitives.PZero ((@CryptolPrimitives.IntModNum (num)))) :=
  (fun (num : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (@CryptolPrimitives.PZero ((@CryptolPrimitives.IntModNum (n)))))) (@CryptolPrimitives.PZeroIntMod) (@CryptolPrimitives.PZeroInteger) (num))).

Definition PZeroSeq : forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.PZero (a))) -> (@CryptolPrimitives.PZero ((@CryptolPrimitives.seq (n) (a)))) :=
  (fun (n : (@Num)) (a : Type) (pa : a) => (@CryptolPrimitives.seqConst (n) (a) (pa))).

Definition PZeroSeqBool : forall (n : (@Num)), (@CryptolPrimitives.PZero ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (@CryptolPrimitives.PZero ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))))) ((fun (n : (@Nat)) => (@SAWCoreVectorsAsCoqVectors.bvNat (n) (0)))) ((@SAWCorePrelude.streamConst (@SAWCoreScaffolding.Bool) (@SAWCoreScaffolding.False))) (n))).

Definition PZeroFun : forall (a : Type), forall (b : Type), ((@CryptolPrimitives.PZero (b))) -> (@CryptolPrimitives.PZero ((a) -> b)) :=
  (fun (a : Type) (b : Type) (pb : b) (_ : a) => pb).

Definition PLogic : (Type) -> Type :=
  (fun (a : Type) => (record ((Fields ((FScons ((@pair (field) (_) (("not")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("xor")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("or")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("and")%string) ((a) -> (a) -> a))) (FSnil))))))))))))).

Definition PLogicBit : (@CryptolPrimitives.PLogic (@SAWCoreScaffolding.Bool)) :=
  (@Rjoin (_) (_) ((@record_singleton (_) (("not")%string) (@SAWCoreScaffolding.not))) ((@Rjoin (_) (_) ((@record_singleton (_) (("xor")%string) (@SAWCoreScaffolding.xor))) ((@Rjoin (_) (_) ((@record_singleton (_) (("or")%string) (@SAWCoreScaffolding.or))) ((@Rjoin (_) (_) ((@record_singleton (_) (("and")%string) (@SAWCoreScaffolding.and))) (record_empty)))))))).

Definition PLogicVec : forall (n : (@Nat)), forall (a : Type), ((@CryptolPrimitives.PLogic (a))) -> (@CryptolPrimitives.PLogic ((@SAWCoreVectorsAsCoqVectors.Vec (n) (a)))) :=
  (fun (n : (@Nat)) (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("xor")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("or")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("not")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("and")%string) ((a) -> (a) -> a))) (FSnil))))))))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("not")%string) ((@SAWCorePrelude.map (a) (a) ((@Rget (_) (pa) (("not")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("xor")%string) ((@SAWCorePrelude.zipWith (a) (a) (a) ((@Rget (_) (pa) (("xor")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("or")%string) ((@SAWCorePrelude.zipWith (a) (a) (a) ((@Rget (_) (pa) (("or")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("and")%string) ((@SAWCorePrelude.zipWith (a) (a) (a) ((@Rget (_) (pa) (("and")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) (record_empty))))))))).

Definition PLogicStream : forall (a : Type), ((@CryptolPrimitives.PLogic (a))) -> (@CryptolPrimitives.PLogic ((@Stream (a)))) :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("xor")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("or")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("not")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("and")%string) ((a) -> (a) -> a))) (FSnil))))))))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("not")%string) ((@SAWCorePrelude.streamMap (a) (a) ((@Rget (_) (pa) (("not")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("xor")%string) ((@SAWCorePrelude.streamMap2 (a) (a) (a) ((@Rget (_) (pa) (("xor")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("or")%string) ((@SAWCorePrelude.streamMap2 (a) (a) (a) ((@Rget (_) (pa) (("or")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("and")%string) ((@SAWCorePrelude.streamMap2 (a) (a) (a) ((@Rget (_) (pa) (("and")%string) (_) (ltac:(simpl; exact eq_refl)))))))) (record_empty))))))))).

Definition PLogicSeq : forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.PLogic (a))) -> (@CryptolPrimitives.PLogic ((@CryptolPrimitives.seq (n) (a)))) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.PLogic (a))) -> (@CryptolPrimitives.PLogic ((@CryptolPrimitives.seq (n) (a)))))) ((fun (n : (@Nat)) => (@CryptolPrimitives.PLogicVec (n)))) (@CryptolPrimitives.PLogicStream) (n))).

Definition PLogicWord : forall (n : (@Nat)), (@CryptolPrimitives.PLogic ((@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool)))) :=
  (fun (n : (@Nat)) => (@Rjoin (_) (_) ((@record_singleton (_) (("not")%string) ((@SAWCorePrelude.bvNot (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("xor")%string) ((@SAWCorePrelude.bvXor (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("or")%string) ((@SAWCorePrelude.bvOr (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("and")%string) ((@SAWCorePrelude.bvAnd (n))))) (record_empty))))))))).

Definition PLogicSeqBool : forall (n : (@Num)), (@CryptolPrimitives.PLogic ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (@CryptolPrimitives.PLogic ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))))) ((fun (n : (@Nat)) => (@CryptolPrimitives.PLogicWord (n)))) ((@CryptolPrimitives.PLogicStream (@SAWCoreScaffolding.Bool) (@CryptolPrimitives.PLogicBit))) (n))).

Definition PLogicFun : forall (a : Type), forall (b : Type), ((@CryptolPrimitives.PLogic (b))) -> (@CryptolPrimitives.PLogic ((a) -> b)) :=
  (fun (a : Type) (b : Type) (pb : (record ((Fields ((FScons ((@pair (field) (_) (("xor")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("or")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("not")%string) ((b) -> b))) ((FScons ((@pair (field) (_) (("and")%string) ((b) -> (b) -> b))) (FSnil))))))))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("not")%string) ((@CryptolPrimitives.compose (a) (b) (b) ((@Rget (_) (pb) (("not")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("xor")%string) ((@CryptolPrimitives.funBinary (a) (b) ((@Rget (_) (pb) (("xor")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("or")%string) ((@CryptolPrimitives.funBinary (a) (b) ((@Rget (_) (pb) (("or")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("and")%string) ((@CryptolPrimitives.funBinary (a) (b) ((@Rget (_) (pb) (("and")%string) (_) (ltac:(simpl; exact eq_refl)))))))) (record_empty))))))))).

Definition PLogicUnit : (@CryptolPrimitives.PLogic (unit)) :=
  (@Rjoin (_) (_) ((@record_singleton (_) (("not")%string) (@CryptolPrimitives.unitUnary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("xor")%string) (@CryptolPrimitives.unitBinary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("or")%string) (@CryptolPrimitives.unitBinary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("and")%string) (@CryptolPrimitives.unitBinary))) (record_empty)))))))).

Definition PLogicPair : forall (a : Type), forall (b : Type), ((@CryptolPrimitives.PLogic (a))) -> ((@CryptolPrimitives.PLogic (b))) -> (@CryptolPrimitives.PLogic ((prod (a) (b)))) :=
  (fun (a : Type) (b : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("xor")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("or")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("not")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("and")%string) ((a) -> (a) -> a))) (FSnil))))))))))))) (pb : (record ((Fields ((FScons ((@pair (field) (_) (("xor")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("or")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("not")%string) ((b) -> b))) ((FScons ((@pair (field) (_) (("and")%string) ((b) -> (b) -> b))) (FSnil))))))))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("not")%string) ((@CryptolPrimitives.pairUnary (a) (b) ((@Rget (_) (pa) (("not")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("not")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("xor")%string) ((@CryptolPrimitives.pairBinary (a) (b) ((@Rget (_) (pa) (("xor")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("xor")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("or")%string) ((@CryptolPrimitives.pairBinary (a) (b) ((@Rget (_) (pa) (("or")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("or")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("and")%string) ((@CryptolPrimitives.pairBinary (a) (b) ((@Rget (_) (pa) (("and")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("and")%string) (_) (ltac:(simpl; exact eq_refl)))))))) (record_empty))))))))).

Definition PArith : (Type) -> Type :=
  (fun (a : Type) => (record ((Fields ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))).

Definition PArithInteger : (@CryptolPrimitives.PArith (@SAWCorePrelude.Integer)) :=
  (@Rjoin (_) (_) ((@record_singleton (_) (("int")%string) ((fun (i : @SAWCorePrelude.Integer) => i)))) ((@Rjoin (_) (_) ((@record_singleton (_) (("smod")%string) ((@CryptolPrimitives.errorBinary (("no implementation for smod on Integer")%string) (@SAWCorePrelude.Integer))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sdiv")%string) ((@CryptolPrimitives.errorBinary (("no implementation for sdiv on Integer")%string) (@SAWCorePrelude.Integer))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("neg")%string) (@SAWCorePrelude.intNeg))) ((@Rjoin (_) (_) ((@record_singleton (_) (("lg2")%string) ((@CryptolPrimitives.errorUnary (("no implementation for lg2 on Integer")%string) (@SAWCorePrelude.Integer))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("exp")%string) ((@CryptolPrimitives.errorBinary (("no implementation for exp on Integer")%string) (@SAWCorePrelude.Integer))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mod")%string) (@SAWCorePrelude.intMod))) ((@Rjoin (_) (_) ((@record_singleton (_) (("div")%string) (@SAWCorePrelude.intDiv))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mul")%string) (@SAWCorePrelude.intMul))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sub")%string) (@SAWCorePrelude.intSub))) ((@Rjoin (_) (_) ((@record_singleton (_) (("add")%string) (@SAWCorePrelude.intAdd))) (record_empty)))))))))))))))))))))).

Definition PArithIntMod : forall (n : (@Nat)), (@CryptolPrimitives.PArith ((@SAWCorePrelude.IntMod (n)))) :=
  (fun (n : (@Nat)) => (@Rjoin (_) (_) ((@record_singleton (_) (("int")%string) ((@SAWCorePrelude.toIntMod (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("smod")%string) ((@CryptolPrimitives.errorBinary (("no implementation for smod on IntMod")%string) ((@SAWCorePrelude.IntMod (n))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sdiv")%string) ((@CryptolPrimitives.errorBinary (("no implementation for sdiv on IntMod")%string) ((@SAWCorePrelude.IntMod (n))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("neg")%string) ((@SAWCorePrelude.intModNeg (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("lg2")%string) ((@CryptolPrimitives.errorUnary (("no implementation for lg2 on IntMod")%string) ((@SAWCorePrelude.IntMod (n))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("exp")%string) ((@CryptolPrimitives.errorBinary (("no implementation for exp on IntMod")%string) ((@SAWCorePrelude.IntMod (n))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mod")%string) ((fun (x : (@SAWCorePrelude.IntMod (n))) (y : (@SAWCorePrelude.IntMod (n))) => (@SAWCorePrelude.toIntMod (n) ((@SAWCorePrelude.intMod ((@SAWCorePrelude.fromIntMod (n) (x))) ((@SAWCorePrelude.fromIntMod (n) (y)))))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("div")%string) ((fun (x : (@SAWCorePrelude.IntMod (n))) (y : (@SAWCorePrelude.IntMod (n))) => (@SAWCorePrelude.toIntMod (n) ((@SAWCorePrelude.intDiv ((@SAWCorePrelude.fromIntMod (n) (x))) ((@SAWCorePrelude.fromIntMod (n) (y)))))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mul")%string) ((@SAWCorePrelude.intModMul (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sub")%string) ((@SAWCorePrelude.intModSub (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("add")%string) ((@SAWCorePrelude.intModAdd (n))))) (record_empty))))))))))))))))))))))).

Definition PArithIntModNum : forall (num : (@Num)), (@CryptolPrimitives.PArith ((@CryptolPrimitives.IntModNum (num)))) :=
  (fun (num : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (@CryptolPrimitives.PArith ((@CryptolPrimitives.IntModNum (n)))))) (@CryptolPrimitives.PArithIntMod) (@CryptolPrimitives.PArithInteger) (num))).

Definition PArithVec : forall (n : (@Nat)), forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (@CryptolPrimitives.PArith ((@SAWCoreVectorsAsCoqVectors.Vec (n) (a)))) :=
  (fun (n : (@Nat)) (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("int")%string) ((fun (i : @SAWCorePrelude.Integer) => (@SAWCorePrelude.replicate (n) (a) (((@Rget (_) (pa) (("int")%string) (_) (ltac:(simpl; exact eq_refl))) (i)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("smod")%string) ((@SAWCorePrelude.zipWith (a) (a) (a) ((@Rget (_) (pa) (("smod")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sdiv")%string) ((@SAWCorePrelude.zipWith (a) (a) (a) ((@Rget (_) (pa) (("sdiv")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("neg")%string) ((@SAWCorePrelude.map (a) (a) ((@Rget (_) (pa) (("neg")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("lg2")%string) ((@SAWCorePrelude.map (a) (a) ((@Rget (_) (pa) (("lg2")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("exp")%string) ((@SAWCorePrelude.zipWith (a) (a) (a) ((@Rget (_) (pa) (("exp")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mod")%string) ((@SAWCorePrelude.zipWith (a) (a) (a) ((@Rget (_) (pa) (("mod")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("div")%string) ((@SAWCorePrelude.zipWith (a) (a) (a) ((@Rget (_) (pa) (("div")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mul")%string) ((@SAWCorePrelude.zipWith (a) (a) (a) ((@Rget (_) (pa) (("mul")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sub")%string) ((@SAWCorePrelude.zipWith (a) (a) (a) ((@Rget (_) (pa) (("sub")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("add")%string) ((@SAWCorePrelude.zipWith (a) (a) (a) ((@Rget (_) (pa) (("add")%string) (_) (ltac:(simpl; exact eq_refl)))) (n))))) (record_empty))))))))))))))))))))))).

Definition PArithStream : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (@CryptolPrimitives.PArith ((@Stream (a)))) :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("int")%string) ((fun (i : @SAWCorePrelude.Integer) => (@SAWCorePrelude.streamConst (a) (((@Rget (_) (pa) (("int")%string) (_) (ltac:(simpl; exact eq_refl))) (i)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("smod")%string) ((@SAWCorePrelude.streamMap2 (a) (a) (a) ((@Rget (_) (pa) (("smod")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sdiv")%string) ((@SAWCorePrelude.streamMap2 (a) (a) (a) ((@Rget (_) (pa) (("sdiv")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("neg")%string) ((@SAWCorePrelude.streamMap (a) (a) ((@Rget (_) (pa) (("neg")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("lg2")%string) ((@SAWCorePrelude.streamMap (a) (a) ((@Rget (_) (pa) (("lg2")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("exp")%string) ((@SAWCorePrelude.streamMap2 (a) (a) (a) ((@Rget (_) (pa) (("exp")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mod")%string) ((@SAWCorePrelude.streamMap2 (a) (a) (a) ((@Rget (_) (pa) (("mod")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("div")%string) ((@SAWCorePrelude.streamMap2 (a) (a) (a) ((@Rget (_) (pa) (("div")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mul")%string) ((@SAWCorePrelude.streamMap2 (a) (a) (a) ((@Rget (_) (pa) (("mul")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sub")%string) ((@SAWCorePrelude.streamMap2 (a) (a) (a) ((@Rget (_) (pa) (("sub")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("add")%string) ((@SAWCorePrelude.streamMap2 (a) (a) (a) ((@Rget (_) (pa) (("add")%string) (_) (ltac:(simpl; exact eq_refl)))))))) (record_empty))))))))))))))))))))))).

Definition PArithSeq : forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (@CryptolPrimitives.PArith ((@CryptolPrimitives.seq (n) (a)))) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (@CryptolPrimitives.PArith ((@CryptolPrimitives.seq (n) (a)))))) ((fun (n : (@Nat)) => (@CryptolPrimitives.PArithVec (n)))) (@CryptolPrimitives.PArithStream) (n))).

Definition PArithWord : forall (n : (@Nat)), (@CryptolPrimitives.PArith ((@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool)))) :=
  (fun (n : (@Nat)) => (@Rjoin (_) (_) ((@record_singleton (_) (("int")%string) ((@SAWCorePrelude.intToBv (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("smod")%string) ((@SAWCorePrelude.natCase ((fun (w : (@Nat)) => ((@SAWCorePrelude.bitvector (w))) -> ((@SAWCorePrelude.bitvector (w))) -> (@SAWCorePrelude.bitvector (w)))) ((@CryptolPrimitives.errorBinary (("no implementation for smod on empty bit vectors")%string) ((@SAWCorePrelude.bitvector (0))))) (@SAWCorePrelude.bvSRem) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sdiv")%string) ((@SAWCorePrelude.natCase ((fun (w : (@Nat)) => ((@SAWCorePrelude.bitvector (w))) -> ((@SAWCorePrelude.bitvector (w))) -> (@SAWCorePrelude.bitvector (w)))) ((@CryptolPrimitives.errorBinary (("no implementation for sdiv on empty bit vectors")%string) ((@SAWCorePrelude.bitvector (0))))) (@SAWCorePrelude.bvSDiv) (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("neg")%string) ((@SAWCorePrelude.bvNeg (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("lg2")%string) ((@SAWCorePrelude.bvLg2 (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("exp")%string) ((@CryptolPrimitives.bvExp (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mod")%string) ((@SAWCorePrelude.bvURem (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("div")%string) ((@SAWCorePrelude.bvUDiv (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mul")%string) ((@SAWCorePrelude.bvMul (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sub")%string) ((@SAWCorePrelude.bvSub (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("add")%string) ((@SAWCorePrelude.bvAdd (n))))) (record_empty))))))))))))))))))))))).

Definition PArithSeqBool : forall (n : (@Num)), (@CryptolPrimitives.PArith ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (@CryptolPrimitives.PArith ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))))) ((fun (n : (@Nat)) => (@CryptolPrimitives.PArithWord (n)))) ((@SAWCoreScaffolding.error ((@CryptolPrimitives.PArith ((@Stream (@SAWCoreScaffolding.Bool))))) (("PArithSeqBool: no instance for streams")%string))) (n))).

Definition PArithFun : forall (a : Type), forall (b : Type), ((@CryptolPrimitives.PArith (b))) -> (@CryptolPrimitives.PArith ((a) -> b)) :=
  (fun (a : Type) (b : Type) (pb : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("smod")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("neg")%string) ((b) -> b))) ((FScons ((@pair (field) (_) (("mul")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("mod")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("lg2")%string) ((b) -> b))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> b))) ((FScons ((@pair (field) (_) (("exp")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("div")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("add")%string) ((b) -> (b) -> b))) (FSnil))))))))))))))))))))))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("int")%string) ((fun (i : @SAWCorePrelude.Integer) (_ : a) => ((@Rget (_) (pb) (("int")%string) (_) (ltac:(simpl; exact eq_refl))) (i)))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("smod")%string) ((@CryptolPrimitives.funBinary (a) (b) ((@Rget (_) (pb) (("smod")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sdiv")%string) ((@CryptolPrimitives.funBinary (a) (b) ((@Rget (_) (pb) (("sdiv")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("neg")%string) ((@CryptolPrimitives.compose (a) (b) (b) ((@Rget (_) (pb) (("neg")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("lg2")%string) ((@CryptolPrimitives.compose (a) (b) (b) ((@Rget (_) (pb) (("lg2")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("exp")%string) ((@CryptolPrimitives.funBinary (a) (b) ((@Rget (_) (pb) (("exp")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mod")%string) ((@CryptolPrimitives.funBinary (a) (b) ((@Rget (_) (pb) (("mod")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("div")%string) ((@CryptolPrimitives.funBinary (a) (b) ((@Rget (_) (pb) (("div")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mul")%string) ((@CryptolPrimitives.funBinary (a) (b) ((@Rget (_) (pb) (("mul")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sub")%string) ((@CryptolPrimitives.funBinary (a) (b) ((@Rget (_) (pb) (("sub")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("add")%string) ((@CryptolPrimitives.funBinary (a) (b) ((@Rget (_) (pb) (("add")%string) (_) (ltac:(simpl; exact eq_refl)))))))) (record_empty))))))))))))))))))))))).

Definition PArithUnit : (@CryptolPrimitives.PArith (unit)) :=
  (@Rjoin (_) (_) ((@record_singleton (_) (("int")%string) ((fun (i : @SAWCorePrelude.Integer) => tt)))) ((@Rjoin (_) (_) ((@record_singleton (_) (("smod")%string) (@CryptolPrimitives.unitBinary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sdiv")%string) (@CryptolPrimitives.unitBinary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("neg")%string) (@CryptolPrimitives.unitUnary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("lg2")%string) (@CryptolPrimitives.unitUnary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("exp")%string) (@CryptolPrimitives.unitBinary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mod")%string) (@CryptolPrimitives.unitBinary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("div")%string) (@CryptolPrimitives.unitBinary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mul")%string) (@CryptolPrimitives.unitBinary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sub")%string) (@CryptolPrimitives.unitBinary))) ((@Rjoin (_) (_) ((@record_singleton (_) (("add")%string) (@CryptolPrimitives.unitBinary))) (record_empty)))))))))))))))))))))).

Definition PArithPair : forall (a : Type), forall (b : Type), ((@CryptolPrimitives.PArith (a))) -> ((@CryptolPrimitives.PArith (b))) -> (@CryptolPrimitives.PArith ((prod (a) (b)))) :=
  (fun (a : Type) (b : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) (pb : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("smod")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("neg")%string) ((b) -> b))) ((FScons ((@pair (field) (_) (("mul")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("mod")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("lg2")%string) ((b) -> b))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> b))) ((FScons ((@pair (field) (_) (("exp")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("div")%string) ((b) -> (b) -> b))) ((FScons ((@pair (field) (_) (("add")%string) ((b) -> (b) -> b))) (FSnil))))))))))))))))))))))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("int")%string) ((fun (i : @SAWCorePrelude.Integer) => (pair (((@Rget (_) (pa) (("int")%string) (_) (ltac:(simpl; exact eq_refl))) (i))) (((@Rget (_) (pb) (("int")%string) (_) (ltac:(simpl; exact eq_refl))) (i)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("smod")%string) ((@CryptolPrimitives.pairBinary (a) (b) ((@Rget (_) (pa) (("smod")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("smod")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sdiv")%string) ((@CryptolPrimitives.pairBinary (a) (b) ((@Rget (_) (pa) (("sdiv")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("sdiv")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("neg")%string) ((@CryptolPrimitives.pairUnary (a) (b) ((@Rget (_) (pa) (("neg")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("neg")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("lg2")%string) ((@CryptolPrimitives.pairUnary (a) (b) ((@Rget (_) (pa) (("lg2")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("lg2")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("exp")%string) ((@CryptolPrimitives.pairBinary (a) (b) ((@Rget (_) (pa) (("exp")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("exp")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mod")%string) ((@CryptolPrimitives.pairBinary (a) (b) ((@Rget (_) (pa) (("mod")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("mod")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("div")%string) ((@CryptolPrimitives.pairBinary (a) (b) ((@Rget (_) (pa) (("div")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("div")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("mul")%string) ((@CryptolPrimitives.pairBinary (a) (b) ((@Rget (_) (pa) (("mul")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("mul")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("sub")%string) ((@CryptolPrimitives.pairBinary (a) (b) ((@Rget (_) (pa) (("sub")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("sub")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("add")%string) ((@CryptolPrimitives.pairBinary (a) (b) ((@Rget (_) (pa) (("add")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("add")%string) (_) (ltac:(simpl; exact eq_refl)))))))) (record_empty))))))))))))))))))))))).

Definition PCmp : (Type) -> Type :=
  (fun (a : Type) => (record ((Fields ((FScons ((@pair (field) (_) (("cmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) ((FScons ((@pair (field) (_) (("eq")%string) ((a) -> (a) -> @SAWCoreScaffolding.Bool))) (FSnil))))))))).

Definition PCmpBit : (@CryptolPrimitives.PCmp (@SAWCoreScaffolding.Bool)) :=
  (@Rjoin (_) (_) ((@record_singleton (_) (("cmp")%string) (@CryptolPrimitives.boolCmp))) ((@Rjoin (_) (_) ((@record_singleton (_) (("eq")%string) (@SAWCoreScaffolding.boolEq))) (record_empty)))).

Definition PCmpInteger : (@CryptolPrimitives.PCmp (@SAWCorePrelude.Integer)) :=
  (@Rjoin (_) (_) ((@record_singleton (_) (("cmp")%string) (@CryptolPrimitives.integerCmp))) ((@Rjoin (_) (_) ((@record_singleton (_) (("eq")%string) (@SAWCorePrelude.intEq))) (record_empty)))).

Definition PCmpIntMod : forall (n : (@Nat)), (@CryptolPrimitives.PCmp ((@SAWCorePrelude.IntMod (n)))) :=
  (fun (n : (@Nat)) => (@Rjoin (_) (_) ((@record_singleton (_) (("cmp")%string) ((fun (x : (@SAWCorePrelude.IntMod (n))) (y : (@SAWCorePrelude.IntMod (n))) => (@CryptolPrimitives.integerCmp ((@SAWCorePrelude.fromIntMod (n) (x))) ((@SAWCorePrelude.fromIntMod (n) (y)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("eq")%string) ((@SAWCorePrelude.intModEq (n))))) (record_empty))))).

Definition PCmpIntModNum : forall (num : (@Num)), (@CryptolPrimitives.PCmp ((@CryptolPrimitives.IntModNum (num)))) :=
  (fun (num : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (@CryptolPrimitives.PCmp ((@CryptolPrimitives.IntModNum (n)))))) (@CryptolPrimitives.PCmpIntMod) (@CryptolPrimitives.PCmpInteger) (num))).

Definition PCmpVec : forall (n : (@Nat)), forall (a : Type), ((@CryptolPrimitives.PCmp (a))) -> (@CryptolPrimitives.PCmp ((@SAWCoreVectorsAsCoqVectors.Vec (n) (a)))) :=
  (fun (n : (@Nat)) (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("eq")%string) ((a) -> (a) -> @SAWCoreScaffolding.Bool))) ((FScons ((@pair (field) (_) (("cmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("cmp")%string) ((@CryptolPrimitives.vecCmp (n) (a) ((@Rget (_) (pa) (("cmp")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("eq")%string) ((@SAWCorePrelude.vecEq (n) (a) ((@Rget (_) (pa) (("eq")%string) (_) (ltac:(simpl; exact eq_refl)))))))) (record_empty))))).

Definition PCmpSeq : forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.PCmp (a))) -> (@CryptolPrimitives.PCmp ((@CryptolPrimitives.seq (n) (a)))) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.PCmp (a))) -> (@CryptolPrimitives.PCmp ((@CryptolPrimitives.seq (n) (a)))))) ((fun (n : (@Nat)) => (@CryptolPrimitives.PCmpVec (n)))) ((fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("eq")%string) ((a) -> (a) -> @SAWCoreScaffolding.Bool))) ((FScons ((@pair (field) (_) (("cmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))))) => (@SAWCoreScaffolding.error ((@CryptolPrimitives.PCmp ((@Stream (a))))) (("invalid Cmp instance")%string)))) (n))).

Definition PCmpWord : forall (n : (@Nat)), (@CryptolPrimitives.PCmp ((@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool)))) :=
  (fun (n : (@Nat)) => (@Rjoin (_) (_) ((@record_singleton (_) (("cmp")%string) ((@CryptolPrimitives.bvCmp (n))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("eq")%string) ((@SAWCorePrelude.bvEq (n))))) (record_empty))))).

Definition PCmpSeqBool : forall (n : (@Num)), (@CryptolPrimitives.PCmp ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (@CryptolPrimitives.PCmp ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))))) ((fun (n : (@Nat)) => (@CryptolPrimitives.PCmpWord (n)))) ((@SAWCoreScaffolding.error ((@CryptolPrimitives.PCmp ((@Stream (@SAWCoreScaffolding.Bool))))) (("invalid Cmp instance")%string))) (n))).

Definition PCmpUnit : (@CryptolPrimitives.PCmp (unit)) :=
  (@Rjoin (_) (_) ((@record_singleton (_) (("cmp")%string) (@CryptolPrimitives.unitCmp))) ((@Rjoin (_) (_) ((@record_singleton (_) (("eq")%string) ((fun (x : unit) (y : unit) => @SAWCoreScaffolding.True)))) (record_empty)))).

Definition PCmpPair : forall (a : Type), forall (b : Type), ((@CryptolPrimitives.PCmp (a))) -> ((@CryptolPrimitives.PCmp (b))) -> (@CryptolPrimitives.PCmp ((prod (a) (b)))) :=
  (fun (a : Type) (b : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("eq")%string) ((a) -> (a) -> @SAWCoreScaffolding.Bool))) ((FScons ((@pair (field) (_) (("cmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))))) (pb : (record ((Fields ((FScons ((@pair (field) (_) (("eq")%string) ((b) -> (b) -> @SAWCoreScaffolding.Bool))) ((FScons ((@pair (field) (_) (("cmp")%string) ((b) -> (b) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("cmp")%string) ((@CryptolPrimitives.pairCmp (a) (b) ((@Rget (_) (pa) (("cmp")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("cmp")%string) (_) (ltac:(simpl; exact eq_refl)))))))) ((@Rjoin (_) (_) ((@record_singleton (_) (("eq")%string) ((@CryptolPrimitives.pairEq (a) (b) ((@Rget (_) (pa) (("eq")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("eq")%string) (_) (ltac:(simpl; exact eq_refl)))))))) (record_empty))))).

Definition PSignedCmp : (Type) -> Type :=
  (fun (a : Type) => (record ((Fields ((FScons ((@pair (field) (_) (("scmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))).

Definition PSignedCmpVec : forall (n : (@Nat)), forall (a : Type), ((@CryptolPrimitives.PSignedCmp (a))) -> (@CryptolPrimitives.PSignedCmp ((@SAWCoreVectorsAsCoqVectors.Vec (n) (a)))) :=
  (fun (n : (@Nat)) (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("scmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("scmp")%string) ((@CryptolPrimitives.vecCmp (n) (a) ((@Rget (_) (pa) (("scmp")%string) (_) (ltac:(simpl; exact eq_refl)))))))) (record_empty))).

Definition PSignedCmpSeq : forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.PSignedCmp (a))) -> (@CryptolPrimitives.PSignedCmp ((@CryptolPrimitives.seq (n) (a)))) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.PSignedCmp (a))) -> (@CryptolPrimitives.PSignedCmp ((@CryptolPrimitives.seq (n) (a)))))) ((fun (n : (@Nat)) => (@CryptolPrimitives.PSignedCmpVec (n)))) ((fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("scmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))) => (@SAWCoreScaffolding.error ((@CryptolPrimitives.PSignedCmp ((@Stream (a))))) (("invalid SignedCmp instance")%string)))) (n))).

Definition PSignedCmpWord : forall (n : (@Nat)), (@CryptolPrimitives.PSignedCmp ((@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool)))) :=
  (fun (n : (@Nat)) => (@Rjoin (_) (_) ((@record_singleton (_) (("scmp")%string) ((@CryptolPrimitives.bvSCmp (n))))) (record_empty))).

Definition PSignedCmpUnit : (@CryptolPrimitives.PSignedCmp (unit)) :=
  (@Rjoin (_) (_) ((@record_singleton (_) (("scmp")%string) (@CryptolPrimitives.unitCmp))) (record_empty)).

Definition PSignedCmpPair : forall (a : Type), forall (b : Type), ((@CryptolPrimitives.PSignedCmp (a))) -> ((@CryptolPrimitives.PSignedCmp (b))) -> (@CryptolPrimitives.PSignedCmp ((prod (a) (b)))) :=
  (fun (a : Type) (b : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("scmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))) (pb : (record ((Fields ((FScons ((@pair (field) (_) (("scmp")%string) ((b) -> (b) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))) => (@Rjoin (_) (_) ((@record_singleton (_) (("scmp")%string) ((@CryptolPrimitives.pairCmp (a) (b) ((@Rget (_) (pa) (("scmp")%string) (_) (ltac:(simpl; exact eq_refl)))) ((@Rget (_) (pb) (("scmp")%string) (_) (ltac:(simpl; exact eq_refl)))))))) (record_empty))).

Definition PLiteral : forall (a : Type), Type :=
  (fun (a : Type) => ((@Nat)) -> a).

Definition PLiteralSeqBool : forall (n : (@Num)), (@CryptolPrimitives.PLiteral ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (@CryptolPrimitives.PLiteral ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))))) (@SAWCoreVectorsAsCoqVectors.bvNat) ((@SAWCoreScaffolding.error ((@CryptolPrimitives.PLiteral ((@Stream (@SAWCoreScaffolding.Bool))))) (("PLiteralSeqBool: no instance for streams")%string))) (n))).

Definition PLiteralInteger : (@CryptolPrimitives.PLiteral (@SAWCorePrelude.Integer)) :=
  @SAWCorePrelude.natToInt.

Definition PLiteralIntMod : forall (n : (@Nat)), (@CryptolPrimitives.PLiteral ((@SAWCorePrelude.IntMod (n)))) :=
  (fun (n : (@Nat)) (x : (@Nat)) => (@SAWCorePrelude.toIntMod (n) ((@SAWCorePrelude.natToInt (x))))).

Definition PLiteralIntModNum : forall (num : (@Num)), (@CryptolPrimitives.PLiteral ((@CryptolPrimitives.IntModNum (num)))) :=
  (fun (num : (@Num)) => (@Num_rect ((fun (n : (@Num)) => (@CryptolPrimitives.PLiteral ((@CryptolPrimitives.IntModNum (n)))))) (@CryptolPrimitives.PLiteralIntMod) (@CryptolPrimitives.PLiteralInteger) (num))).

Definition ecNumber : forall (val : (@Num)), forall (a : Type), ((@CryptolPrimitives.PLiteral (a))) -> a :=
  (fun (val : (@Num)) (a : Type) (pa : ((@Nat)) -> a) => (@Num_rect ((fun (_ : (@Num)) => a)) (pa) ((pa (0))) (val))).

Definition ecToInteger : forall (n : (@Num)), ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCorePrelude.Integer :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCorePrelude.Integer)) (@SAWCorePrelude.bvToInt) ((@SAWCoreScaffolding.error (((@Stream (@SAWCoreScaffolding.Bool))) -> @SAWCorePrelude.Integer) (("ecToInteger called on TCInf")%string))) (n))).

Definition ecFromInteger : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (@SAWCorePrelude.Integer) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rget (_) (pa) (("int")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecFromZ : forall (n : (@Num)), ((@CryptolPrimitives.IntModNum (n))) -> @SAWCorePrelude.Integer :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => ((@CryptolPrimitives.IntModNum (n))) -> @SAWCorePrelude.Integer)) (@SAWCorePrelude.fromIntMod) ((fun (x : @SAWCorePrelude.Integer) => x)) (n))).

Definition ecPlus : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rget (_) (pa) (("add")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecMinus : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rget (_) (pa) (("sub")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecMul : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rget (_) (pa) (("mul")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecDiv : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rget (_) (pa) (("div")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecMod : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rget (_) (pa) (("mod")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecExp : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rget (_) (pa) (("exp")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecLg2 : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rget (_) (pa) (("lg2")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecNeg : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rget (_) (pa) (("neg")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecSDiv : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rget (_) (pa) (("sdiv")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecSMod : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) => (@Rget (_) (pa) (("smod")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecLt : forall (a : Type), ((@CryptolPrimitives.PCmp (a))) -> (a) -> (a) -> @SAWCoreScaffolding.Bool :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("eq")%string) ((a) -> (a) -> @SAWCoreScaffolding.Bool))) ((FScons ((@pair (field) (_) (("cmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))))) (x : a) (y : a) => ((@Rget (_) (pa) (("cmp")%string) (_) (ltac:(simpl; exact eq_refl))) (x) (y) (@SAWCoreScaffolding.False))).

Definition ecGt : forall (a : Type), ((@CryptolPrimitives.PCmp (a))) -> (a) -> (a) -> @SAWCoreScaffolding.Bool :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("eq")%string) ((a) -> (a) -> @SAWCoreScaffolding.Bool))) ((FScons ((@pair (field) (_) (("cmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))))) (x : a) (y : a) => (@CryptolPrimitives.ecLt (a) (pa) (y) (x))).

Definition ecLtEq : forall (a : Type), ((@CryptolPrimitives.PCmp (a))) -> (a) -> (a) -> @SAWCoreScaffolding.Bool :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("eq")%string) ((a) -> (a) -> @SAWCoreScaffolding.Bool))) ((FScons ((@pair (field) (_) (("cmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))))) (x : a) (y : a) => (@SAWCoreScaffolding.not ((@CryptolPrimitives.ecLt (a) (pa) (y) (x))))).

Definition ecGtEq : forall (a : Type), ((@CryptolPrimitives.PCmp (a))) -> (a) -> (a) -> @SAWCoreScaffolding.Bool :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("eq")%string) ((a) -> (a) -> @SAWCoreScaffolding.Bool))) ((FScons ((@pair (field) (_) (("cmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))))) (x : a) (y : a) => (@SAWCoreScaffolding.not ((@CryptolPrimitives.ecLt (a) (pa) (x) (y))))).

Definition ecSLt : forall (a : Type), ((@CryptolPrimitives.PSignedCmp (a))) -> (a) -> (a) -> @SAWCoreScaffolding.Bool :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("scmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))) (x : a) (y : a) => ((@Rget (_) (pa) (("scmp")%string) (_) (ltac:(simpl; exact eq_refl))) (x) (y) (@SAWCoreScaffolding.False))).

Definition ecEq : forall (a : Type), ((@CryptolPrimitives.PCmp (a))) -> (a) -> (a) -> @SAWCoreScaffolding.Bool :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("eq")%string) ((a) -> (a) -> @SAWCoreScaffolding.Bool))) ((FScons ((@pair (field) (_) (("cmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))))) => (@Rget (_) (pa) (("eq")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecNotEq : forall (a : Type), ((@CryptolPrimitives.PCmp (a))) -> (a) -> (a) -> @SAWCoreScaffolding.Bool :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("eq")%string) ((a) -> (a) -> @SAWCoreScaffolding.Bool))) ((FScons ((@pair (field) (_) (("cmp")%string) ((a) -> (a) -> (@SAWCoreScaffolding.Bool) -> @SAWCoreScaffolding.Bool))) (FSnil))))))))) (x : a) (y : a) => (@SAWCoreScaffolding.not ((@CryptolPrimitives.ecEq (a) (pa) (x) (y))))).

Definition ecAnd : forall (a : Type), ((@CryptolPrimitives.PLogic (a))) -> (a) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("xor")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("or")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("not")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("and")%string) ((a) -> (a) -> a))) (FSnil))))))))))))) => (@Rget (_) (pa) (("and")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecOr : forall (a : Type), ((@CryptolPrimitives.PLogic (a))) -> (a) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("xor")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("or")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("not")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("and")%string) ((a) -> (a) -> a))) (FSnil))))))))))))) => (@Rget (_) (pa) (("or")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecXor : forall (a : Type), ((@CryptolPrimitives.PLogic (a))) -> (a) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("xor")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("or")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("not")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("and")%string) ((a) -> (a) -> a))) (FSnil))))))))))))) => (@Rget (_) (pa) (("xor")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecCompl : forall (a : Type), ((@CryptolPrimitives.PLogic (a))) -> (a) -> a :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("xor")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("or")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("not")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("and")%string) ((a) -> (a) -> a))) (FSnil))))))))))))) => (@Rget (_) (pa) (("not")%string) (_) (ltac:(simpl; exact eq_refl)))).

Definition ecZero : forall (a : Type), ((@CryptolPrimitives.PZero (a))) -> a :=
  (fun (a : Type) (pa : a) => pa).

Definition ecShiftL : forall (m : (@Num)), forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.PZero (a))) -> ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (m) (a)) :=
  (fun (m : (@Num)) => (@Num_rect ((fun (m : (@Num)) => forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.PZero (a))) -> ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (m) (a)))) ((fun (m : (@Nat)) => (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.PZero (a))) -> ((@SAWCoreVectorsAsCoqVectors.Vec (m) (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@SAWCoreVectorsAsCoqVectors.Vec (m) (a)))) ((fun (n : (@Nat)) (a : Type) (pz : a) => (@SAWCorePrelude.bvShiftL (m) (a) (n) ((@CryptolPrimitives.ecZero (a) (pz))))))))) ((@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.PZero (a))) -> ((@Stream (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@Stream (a)))) ((fun (n : (@Nat)) (a : Type) (pz : a) => (@SAWCorePrelude.bvStreamShiftL (a) (n)))))) (m))).

Definition ecShiftR : forall (m : (@Num)), forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.PZero (a))) -> ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (m) (a)) :=
  (fun (m : (@Num)) => (@Num_rect ((fun (m : (@Num)) => forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.PZero (a))) -> ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (m) (a)))) ((fun (m : (@Nat)) => (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.PZero (a))) -> ((@SAWCoreVectorsAsCoqVectors.Vec (m) (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@SAWCoreVectorsAsCoqVectors.Vec (m) (a)))) ((fun (n : (@Nat)) (a : Type) (pz : a) => (@SAWCorePrelude.bvShiftR (m) (a) (n) ((@CryptolPrimitives.ecZero (a) (pz))))))))) ((@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.PZero (a))) -> ((@Stream (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@Stream (a)))) ((fun (n : (@Nat)) (a : Type) (pz : a) => (@SAWCorePrelude.bvStreamShiftR (a) (n) ((@CryptolPrimitives.ecZero (a) (pz)))))))) (m))).

Definition ecSShiftR : forall (n : (@Num)), forall (k : (@Num)), ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (k) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)) :=
  (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => forall (k : (@Num)), ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (k) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))) ((fun (n : (@Nat)) => (@CryptolPrimitives.finNumRec ((fun (k : (@Num)) => ((@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (k) (@SAWCoreScaffolding.Bool))) -> (@SAWCoreVectorsAsCoqVectors.Vec (n) (@SAWCoreScaffolding.Bool)))) ((fun (k : (@Nat)) => (@SAWCorePrelude.natCase ((fun (w : (@Nat)) => ((@SAWCorePrelude.bitvector (w))) -> ((@SAWCorePrelude.bitvector (k))) -> (@SAWCorePrelude.bitvector (w)))) ((fun (x : (@SAWCoreVectorsAsCoqVectors.Vec (0) (@SAWCoreScaffolding.Bool))) (i : (@SAWCoreVectorsAsCoqVectors.Vec (k) (@SAWCoreScaffolding.Bool))) => x)) ((fun (w : (@Nat)) (x : (@SAWCoreVectorsAsCoqVectors.Vec ((@Succ (w))) (@SAWCoreScaffolding.Bool))) (i : (@SAWCoreVectorsAsCoqVectors.Vec (k) (@SAWCoreScaffolding.Bool))) => (@SAWCorePrelude.bvSShr (w) (x) ((@SAWCorePrelude.bvToNat (k) (i)))))) (n)))))))).

Definition ecCarry : forall (n : (@Num)), ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool :=
  (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool)) (@SAWCorePrelude.bvCarry)).

Definition ecSCarry : forall (n : (@Num)), ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool :=
  (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool)) ((fun (n : (@Nat)) => (@SAWCorePrelude.natCase ((fun (w : (@Nat)) => ((@SAWCorePrelude.bitvector (w))) -> ((@SAWCorePrelude.bitvector (w))) -> @SAWCoreScaffolding.Bool)) ((fun (_ : (@SAWCoreVectorsAsCoqVectors.Vec (0) (@SAWCoreScaffolding.Bool))) (_ : (@SAWCoreVectorsAsCoqVectors.Vec (0) (@SAWCoreScaffolding.Bool))) => (@SAWCoreScaffolding.error (@SAWCoreScaffolding.Bool) (("invalid SCarry instance")%string)))) (@SAWCorePrelude.bvSCarry) (n))))).

Definition ecRotL : forall (m : (@Num)), forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (m) (a)) :=
  (@CryptolPrimitives.finNumRec2 ((fun (m : (@Num)) (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (m) (a)))) ((fun (m : (@Nat)) (n : (@Nat)) (a : Type) => (@SAWCorePrelude.bvRotateL (m) (a) (n))))).

Definition ecRotR : forall (m : (@Num)), forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (m) (a)) :=
  (@CryptolPrimitives.finNumRec2 ((fun (m : (@Num)) (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (m) (a)))) ((fun (m : (@Nat)) (n : (@Nat)) (a : Type) => (@SAWCorePrelude.bvRotateR (m) (a) (n))))).

Definition ecCat : forall (m : (@Num)), forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (a))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd (m) (n))) (a)) :=
  (@CryptolPrimitives.finNumRec ((fun (m : (@Num)) => forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq (m) (a))) -> ((@CryptolPrimitives.seq (n) (a))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd (m) (n))) (a)))) ((fun (m : (@Nat)) => (@CryptolPrimitives.Num_rect ((fun (n : (@Num)) => forall (a : Type), ((@SAWCoreVectorsAsCoqVectors.Vec (m) (a))) -> ((@CryptolPrimitives.seq (n) (a))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd ((@TCNum (m))) (n))) (a)))) ((fun (n : (@Nat)) (a : Type) => (@SAWCorePrelude.append (m) (n) (a)))) ((fun (a : Type) => (@SAWCorePrelude.streamAppend (a) (m)))))))).

Definition ecSplitAt : forall (m : (@Num)), forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd (m) (n))) (a))) -> (prod ((@CryptolPrimitives.seq (m) (a))) ((@CryptolPrimitives.seq (n) (a)))) :=
  (@CryptolPrimitives.finNumRec ((fun (m : (@Num)) => forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd (m) (n))) (a))) -> (prod ((@CryptolPrimitives.seq (m) (a))) ((@CryptolPrimitives.seq (n) (a)))))) ((fun (m : (@Nat)) => (@CryptolPrimitives.Num_rect ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd ((@TCNum (m))) (n))) (a))) -> (prod ((@SAWCoreVectorsAsCoqVectors.Vec (m) (a))) ((@CryptolPrimitives.seq (n) (a)))))) ((fun (n : (@Nat)) (a : Type) (xs : (@SAWCoreVectorsAsCoqVectors.Vec ((@SAWCorePrelude.addNat (m) (n))) (a))) => (pair ((@SAWCorePrelude.take (a) (m) (n) (xs))) ((@SAWCorePrelude.drop (a) (m) (n) (xs)))))) ((fun (a : Type) (xs : (@Stream (a))) => (pair ((@SAWCorePrelude.streamTake (a) (m) (xs))) ((@SAWCorePrelude.streamDrop (a) (m) (xs)))))))))).

Definition ecJoin : forall (m : (@Num)), forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq (m) ((@CryptolPrimitives.seq (n) (a))))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul (m) (n))) (a)) :=
  (fun (m : (@Num)) => (@Num_rect ((fun (m : (@Num)) => forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq (m) ((@CryptolPrimitives.seq (n) (a))))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul (m) (n))) (a)))) ((fun (m : (@Nat)) => (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => forall (a : Type), ((@SAWCoreVectorsAsCoqVectors.Vec (m) ((@CryptolPrimitives.seq (n) (a))))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul ((@TCNum (m))) (n))) (a)))) ((fun (n : (@Nat)) (a : Type) => (@SAWCorePrelude.join (m) (n) (a))))))) ((@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => forall (a : Type), ((@Stream ((@CryptolPrimitives.seq (n) (a))))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul ((@TCInf)) (n))) (a)))) ((fun (n : (@Nat)) (a : Type) => (@SAWCorePrelude.natCase ((fun (n' : (@Nat)) => ((@Stream ((@SAWCoreVectorsAsCoqVectors.Vec (n') (a))))) -> (@CryptolPrimitives.seq ((@SAWCorePrelude.if0Nat ((@Num)) (n') ((@TCNum (0))) ((@TCInf)))) (a)))) ((fun (s : (@Stream ((@SAWCoreVectorsAsCoqVectors.Vec (0) (a))))) => (@SAWCoreVectorsAsCoqVectors.EmptyVec (a)))) ((fun (n' : (@Nat)) (s : (@Stream ((@SAWCoreVectorsAsCoqVectors.Vec ((@Succ (n'))) (a))))) => (@SAWCorePrelude.streamJoin (a) (n') (s)))) (n)))))) (m))).

Definition ecSplit : forall (m : (@Num)), forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul (m) (n))) (a))) -> (@CryptolPrimitives.seq (m) ((@CryptolPrimitives.seq (n) (a)))) :=
  (fun (m : (@Num)) => (@Num_rect ((fun (m : (@Num)) => forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul (m) (n))) (a))) -> (@CryptolPrimitives.seq (m) ((@CryptolPrimitives.seq (n) (a)))))) ((fun (m : (@Nat)) => (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul ((@TCNum (m))) (n))) (a))) -> (@SAWCoreVectorsAsCoqVectors.Vec (m) ((@CryptolPrimitives.seq (n) (a)))))) ((fun (n : (@Nat)) (a : Type) => (@SAWCorePrelude.split (m) (n) (a))))))) ((@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.seq ((@CryptolPrimitives.tcMul ((@TCInf)) (n))) (a))) -> (@Stream ((@CryptolPrimitives.seq (n) (a)))))) ((fun (n : (@Nat)) (a : Type) => (@SAWCorePrelude.natCase ((fun (n' : (@Nat)) => ((@CryptolPrimitives.seq ((@SAWCorePrelude.if0Nat ((@Num)) (n') ((@TCNum (0))) ((@TCInf)))) (a))) -> (@Stream ((@SAWCoreVectorsAsCoqVectors.Vec (n') (a)))))) ((@SAWCorePrelude.streamConst ((@SAWCoreVectorsAsCoqVectors.Vec (0) (a))))) ((fun (n' : (@Nat)) => (@SAWCorePrelude.streamSplit (a) ((@Succ (n')))))) (n)))))) (m))).

Definition ecReverse : forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq (n) (a))) -> (@CryptolPrimitives.seq (n) (a)) :=
  (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.seq (n) (a))) -> (@CryptolPrimitives.seq (n) (a)))) (@SAWCorePrelude.reverse)).

Definition ecTranspose : forall (m : (@Num)), forall (n : (@Num)), forall (a : Type), ((@CryptolPrimitives.seq (m) ((@CryptolPrimitives.seq (n) (a))))) -> (@CryptolPrimitives.seq (n) ((@CryptolPrimitives.seq (m) (a)))) :=
  (@CryptolPrimitives.finNumRec2 ((fun (m : (@Num)) (n : (@Num)) => forall (a : Type), ((@CryptolPrimitives.seq (m) ((@CryptolPrimitives.seq (n) (a))))) -> (@CryptolPrimitives.seq (n) ((@CryptolPrimitives.seq (m) (a)))))) (@SAWCorePrelude.transpose)).

Definition ecAt : forall (n : (@Num)), forall (a : Type), forall (i : (@Num)), ((@CryptolPrimitives.seq (n) (a))) -> ((@CryptolPrimitives.seq (i) (@SAWCoreScaffolding.Bool))) -> a :=
  (fun (n : (@Num)) (a : Type) (i : (@Num)) => (@Num_rect ((fun (i : (@Num)) => ((@CryptolPrimitives.seq (n) (a))) -> ((@CryptolPrimitives.seq (i) (@SAWCoreScaffolding.Bool))) -> a)) ((fun (i : (@Nat)) => (@Num_rect ((fun (n : (@Num)) => ((@CryptolPrimitives.seq (n) (a))) -> ((@SAWCoreVectorsAsCoqVectors.Vec (i) (@SAWCoreScaffolding.Bool))) -> a)) ((fun (n : (@Nat)) => (@SAWCorePrelude.bvAt (n) (a) (i)))) ((@SAWCorePrelude.bvStreamGet (a) (i))) (n)))) ((@SAWCoreScaffolding.error (((@CryptolPrimitives.seq (n) (a))) -> ((@Stream (@SAWCoreScaffolding.Bool))) -> a) (("Unexpected Fin constraint violation!")%string))) (i))).

Definition ecAtBack : forall (n : (@Num)), forall (a : Type), forall (i : (@Num)), ((@CryptolPrimitives.seq (n) (a))) -> ((@CryptolPrimitives.seq (i) (@SAWCoreScaffolding.Bool))) -> a :=
  (fun (n : (@Num)) (a : Type) (i : (@Num)) (xs : (@Num_rect ((fun (num : (@Num)) => Type)) ((fun (n : (@Nat)) => (@SAWCoreVectorsAsCoqVectors.Vec (n) (a)))) ((@Stream (a))) (n))) => (@CryptolPrimitives.ecAt (n) (a) (i) ((@CryptolPrimitives.ecReverse (n) (a) (xs))))).

Definition ecFromTo : forall (first : (@Num)), forall (last : (@Num)), forall (a : Type), ((@CryptolPrimitives.PLiteral (a))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd ((@TCNum (1))) ((@CryptolPrimitives.tcSub (last) (first))))) (a)) :=
  (@CryptolPrimitives.finNumRec ((fun (first : (@Num)) => forall (last : (@Num)), forall (a : Type), ((@CryptolPrimitives.PLiteral (a))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd ((@TCNum (1))) ((@CryptolPrimitives.tcSub (last) (first))))) (a)))) ((fun (first : (@Nat)) => (@CryptolPrimitives.finNumRec ((fun (last : (@Num)) => forall (a : Type), ((@CryptolPrimitives.PLiteral (a))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd ((@TCNum (1))) ((@CryptolPrimitives.tcSub (last) ((@TCNum (first))))))) (a)))) ((fun (last : (@Nat)) (a : Type) (pa : ((@Nat)) -> a) => (@SAWCoreVectorsAsCoqVectors.gen ((@SAWCorePrelude.addNat (1) ((@SAWCorePrelude.subNat (last) (first))))) (a) ((fun (i : (@Nat)) => (pa ((@SAWCorePrelude.addNat (i) (first))))))))))))).

Definition ecFromThenTo : forall (first : (@Num)), forall (next : (@Num)), forall (last : (@Num)), forall (a : Type), forall (len : (@Num)), ((@CryptolPrimitives.PLiteral (a))) -> ((@CryptolPrimitives.PLiteral (a))) -> ((@CryptolPrimitives.PLiteral (a))) -> (@CryptolPrimitives.seq (len) (a)) :=
  (fun (first : (@Num)) (next : (@Num)) (_ : (@Num)) (a : Type) => (@CryptolPrimitives.finNumRec ((fun (len : (@Num)) => ((@CryptolPrimitives.PLiteral (a))) -> ((@CryptolPrimitives.PLiteral (a))) -> ((@CryptolPrimitives.PLiteral (a))) -> (@CryptolPrimitives.seq (len) (a)))) ((fun (len : (@Nat)) (pa : ((@Nat)) -> a) (_ : ((@Nat)) -> a) (_ : ((@Nat)) -> a) => (@SAWCoreVectorsAsCoqVectors.gen (len) (a) ((fun (i : (@Nat)) => (pa ((@SAWCorePrelude.subNat ((@SAWCorePrelude.addNat ((@CryptolPrimitives.getFinNat (first))) ((@SAWCorePrelude.mulNat (i) ((@CryptolPrimitives.getFinNat (next))))))) ((@SAWCorePrelude.mulNat (i) ((@CryptolPrimitives.getFinNat (first))))))))))))))).

Definition ecInfFrom : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> (@CryptolPrimitives.seq ((@TCInf)) (a)) :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) (x : a) => (@MkStream (a) ((fun (i : (@Nat)) => ((@Rget (_) (pa) (("add")%string) (_) (ltac:(simpl; exact eq_refl))) (x) (((@Rget (_) (pa) (("int")%string) (_) (ltac:(simpl; exact eq_refl))) ((@SAWCorePrelude.natToInt (i)))))))))).

Definition ecInfFromThen : forall (a : Type), ((@CryptolPrimitives.PArith (a))) -> (a) -> (a) -> (@CryptolPrimitives.seq ((@TCInf)) (a)) :=
  (fun (a : Type) (pa : (record ((Fields ((FScons ((@pair (field) (_) (("sub")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("smod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("sdiv")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("neg")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("mul")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("mod")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("lg2")%string) ((a) -> a))) ((FScons ((@pair (field) (_) (("int")%string) ((@SAWCorePrelude.Integer) -> a))) ((FScons ((@pair (field) (_) (("exp")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("div")%string) ((a) -> (a) -> a))) ((FScons ((@pair (field) (_) (("add")%string) ((a) -> (a) -> a))) (FSnil))))))))))))))))))))))))))) (x : a) (y : a) => (@MkStream (a) ((fun (i : (@Nat)) => ((@Rget (_) (pa) (("add")%string) (_) (ltac:(simpl; exact eq_refl))) (x) (((@Rget (_) (pa) (("mul")%string) (_) (ltac:(simpl; exact eq_refl))) (((@Rget (_) (pa) (("sub")%string) (_) (ltac:(simpl; exact eq_refl))) (y) (x))) (((@Rget (_) (pa) (("int")%string) (_) (ltac:(simpl; exact eq_refl))) ((@SAWCorePrelude.natToInt (i)))))))))))).

Definition ecError : forall (a : Type), forall (len : (@Num)), ((@CryptolPrimitives.seq (len) ((@SAWCorePrelude.bitvector (8))))) -> a :=
  (fun (a : Type) (len : (@Num)) (msg : (@Num_rect ((fun (num : (@Num)) => Type)) ((fun (n : (@Nat)) => (@SAWCoreVectorsAsCoqVectors.Vec (n) ((@SAWCorePrelude.bitvector (8)))))) ((@Stream ((@SAWCorePrelude.bitvector (8))))) (len))) => (@SAWCoreScaffolding.error (a) (("encountered call to the Cryptol 'error' function")%string))).

Definition ecRandom : forall (a : Type), ((@SAWCorePrelude.bitvector (32))) -> a :=
  (fun (a : Type) (_ : (@SAWCoreVectorsAsCoqVectors.Vec (32) (@SAWCoreScaffolding.Bool))) => (@SAWCoreScaffolding.error (a) (("Cryptol.random")%string))).

Definition ecTrace : forall (n : (@Num)), forall (a : Type), forall (b : Type), ((@CryptolPrimitives.seq (n) ((@SAWCorePrelude.bitvector (8))))) -> (a) -> (b) -> b :=
  (fun (_ : (@Num)) (_ : Type) (_ : Type) (_ : (@Num_rect ((fun (num : (@Num)) => Type)) ((fun (n : (@Nat)) => (@SAWCoreVectorsAsCoqVectors.Vec (n) ((@SAWCorePrelude.bitvector (8)))))) ((@Stream ((@SAWCorePrelude.bitvector (8))))) (_))) (_ : _) (x : _) => x).

Definition ecUpdate : forall (n : (@Num)), forall (a : Type), forall (w : (@Num)), ((@CryptolPrimitives.seq (n) (a))) -> ((@CryptolPrimitives.seq (w) (@SAWCoreScaffolding.Bool))) -> (a) -> (@CryptolPrimitives.seq (n) (a)) :=
  (fun (n : (@Num)) => (@Num_rect ((fun (n : (@Num)) => forall (a : Type), forall (w : (@Num)), ((@CryptolPrimitives.seq (n) (a))) -> ((@CryptolPrimitives.seq (w) (@SAWCoreScaffolding.Bool))) -> (a) -> (@CryptolPrimitives.seq (n) (a)))) ((fun (n : (@Nat)) (a : Type) => (@CryptolPrimitives.finNumRec ((fun (w : (@Num)) => ((@SAWCoreVectorsAsCoqVectors.Vec (n) (a))) -> ((@CryptolPrimitives.seq (w) (@SAWCoreScaffolding.Bool))) -> (a) -> (@SAWCoreVectorsAsCoqVectors.Vec (n) (a)))) ((fun (w : (@Nat)) => (@SAWCorePrelude.bvUpd (n) (a) (w))))))) ((fun (a : Type) => (@CryptolPrimitives.finNumRec ((fun (w : (@Num)) => ((@Stream (a))) -> ((@CryptolPrimitives.seq (w) (@SAWCoreScaffolding.Bool))) -> (a) -> (@Stream (a)))) ((fun (w : (@Nat)) => (@SAWCorePrelude.bvStreamUpd (a) (w))))))) (n))).

Definition ecUpdateEnd : forall (n : (@Num)), forall (a : Type), forall (w : (@Num)), ((@CryptolPrimitives.seq (n) (a))) -> ((@CryptolPrimitives.seq (w) (@SAWCoreScaffolding.Bool))) -> (a) -> (@CryptolPrimitives.seq (n) (a)) :=
  (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => forall (a : Type), forall (w : (@Num)), ((@CryptolPrimitives.seq (n) (a))) -> ((@CryptolPrimitives.seq (w) (@SAWCoreScaffolding.Bool))) -> (a) -> (@CryptolPrimitives.seq (n) (a)))) ((fun (n : (@Nat)) (a : Type) => (@CryptolPrimitives.finNumRec ((fun (w : (@Num)) => ((@SAWCoreVectorsAsCoqVectors.Vec (n) (a))) -> ((@CryptolPrimitives.seq (w) (@SAWCoreScaffolding.Bool))) -> (a) -> (@SAWCoreVectorsAsCoqVectors.Vec (n) (a)))) ((fun (w : (@Nat)) (xs : (@SAWCoreVectorsAsCoqVectors.Vec (n) (a))) (i : (@SAWCoreVectorsAsCoqVectors.Vec (w) (@SAWCoreScaffolding.Bool))) (y : a) => (@SAWCorePrelude.upd (n) (a) (xs) ((@SAWCorePrelude.subNat ((@SAWCorePrelude.subNat (n) (1))) ((@SAWCorePrelude.bvToNat (w) (i))))) (y)))))))).

Definition ecTrunc : forall (m : (@Num)), forall (n : (@Num)), ((@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd (m) (n))) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)) :=
  (@CryptolPrimitives.finNumRec2 ((fun (m : (@Num)) (n : (@Num)) => ((@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd (m) (n))) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool)))) (@SAWCorePrelude.bvTrunc)).

Definition ecUExt : forall (m : (@Num)), forall (n : (@Num)), ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd (m) (n))) (@SAWCoreScaffolding.Bool)) :=
  (@CryptolPrimitives.finNumRec2 ((fun (m : (@Num)) (n : (@Num)) => ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd (m) (n))) (@SAWCoreScaffolding.Bool)))) (@SAWCorePrelude.bvUExt)).

Definition ecSExt : forall (m : (@Num)), forall (n : (@Num)), ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd (m) (n))) (@SAWCoreScaffolding.Bool)) :=
  (@CryptolPrimitives.finNumRec2 ((fun (m : (@Num)) (n : (@Num)) => ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> (@CryptolPrimitives.seq ((@CryptolPrimitives.tcAdd (m) (n))) (@SAWCoreScaffolding.Bool)))) ((fun (m : (@Nat)) (n : (@Nat)) => (@SAWCorePrelude.natCase ((fun (n' : (@Nat)) => ((@SAWCorePrelude.bitvector (n'))) -> (@SAWCorePrelude.bitvector ((@SAWCorePrelude.addNat (m) (n')))))) ((fun (_ : (@SAWCoreVectorsAsCoqVectors.Vec (0) (@SAWCoreScaffolding.Bool))) => (@SAWCoreVectorsAsCoqVectors.bvNat ((@SAWCorePrelude.addNat (m) (0))) (0)))) ((@SAWCorePrelude.bvSExt (m))) (n))))).

Definition ecSgt : forall (n : (@Num)), ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool :=
  (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool)) (@SAWCorePrelude.bvsgt)).

Definition ecSge : forall (n : (@Num)), ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool :=
  (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool)) (@SAWCorePrelude.bvsge)).

Definition ecSlt : forall (n : (@Num)), ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool :=
  (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool)) (@SAWCorePrelude.bvslt)).

Definition ecSle : forall (n : (@Num)), ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool :=
  (@CryptolPrimitives.finNumRec ((fun (n : (@Num)) => ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> ((@CryptolPrimitives.seq (n) (@SAWCoreScaffolding.Bool))) -> @SAWCoreScaffolding.Bool)) (@SAWCorePrelude.bvsle)).

Axiom replicate_False : forall (n : (@Nat)), (@Eq ((@SAWCorePrelude.bitvector (n))) ((@SAWCorePrelude.replicate (n) (@SAWCoreScaffolding.Bool) (@SAWCoreScaffolding.False))) ((@SAWCoreVectorsAsCoqVectors.bvNat (n) (0)))) .

Axiom subNat_0 : forall (n : (@Nat)), (@Eq ((@Nat)) ((@SAWCorePrelude.subNat (n) (0))) (n)) .

End CryptolPrimitives.
