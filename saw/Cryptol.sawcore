--------------------------------------------------------------------------------
-- Cryptol primitives for SAWCore

module Cryptol where

import Prelude;

--------------------------------------------------------------------------------
-- Additional operations on Prelude types

widthNat :: Nat -> Nat;
subNat :: Nat -> Nat -> Nat;

mapPair :: (a b c d :: sort 0) -> (a -> b) -> (c -> d) -> #(a, c) -> #(b, d);
mapPair _ _ _ _ f g (x, y) = (f x, g y);

zipWithPair :: (a1 b1 c1 a2 b2 c2 :: sort 0) -> (a1 -> b1 -> c1) -> (a2 -> b2 -> c2) -> #(a1, a2) -> #(b1, b2) -> #(c1, c2);
zipWithPair _ _ _ _ _ _ f1 f2 (x1, x2) (y1, y2) = (f1 x1 y1, f2 x2 y2);

--------------------------------------------------------------------------------
-- Extended natural numbers

data Num :: sort 0 where {
    TCNum :: Nat -> Num;
    TCInf :: Num;
  }

tcWidth :: Num -> Num;
tcWidth (TCNum n) = TCNum (widthNat n);
tcWidth TCInf = TCInf;

tcLg2 :: Num -> Num;

tcAdd :: Num -> Num -> Num;
tcAdd (TCNum x) (TCNum y) = TCNum (addNat x y);
tcAdd (TCNum _) TCInf = TCInf;
tcAdd TCInf _ = TCInf;

tcSub :: Num -> Num -> Num;
tcSub (TCNum x) (TCNum y) = TCNum (subNat x y);
-- TODO: other cases

tcMul :: Num -> Num -> Num;
tcMul (TCNum x) (TCNum y) = TCNum (mulNat x y);
tcMul (TCNum x) TCInf = ite Num (equalNat 0 x) (TCNum 0) TCInf;
tcMul TCInf (TCNum y) = ite Num (equalNat 0 y) (TCNum 0) TCInf;
tcMul TCInf TCInf = TCInf;

tcDiv :: Num -> Num -> Num;
tcMod :: Num -> Num -> Num;
tcExp :: Num -> Num -> Num;

tcMin :: Num -> Num -> Num;
tcMin (TCNum x) (TCNum y) = TCNum (minNat x y);
tcMin (TCNum x) TCInf = TCNum x;
tcMin TCInf (TCNum y) = TCNum y;
tcMin TCInf TCInf = TCInf;

tcMax :: Num -> Num -> Num;

tcLenFromThen :: Num -> Num -> Num -> Num;
tcLenFromThenTo :: Num -> Num -> Num -> Num;

--------------------------------------------------------------------------------
-- Possibly unbounded sequence indexes

data Index :: Num -> sort 0 where {
    IndexNum :: (n :: Nat) -> Fin n -> Index (TCNum n);
    IndexInf :: Nat -> Index TCInf;
  }

unIndexNum :: (n :: Nat) -> Index (TCNum n) -> Fin n;
unIndexNum _ (IndexNum _ i) = i;

unIndexInf :: Index TCInf -> Nat;
unIndexInf (IndexInf i) = i;

indexMinL :: (m n :: Num) -> Index (tcMin m n) -> Index m;
--indexMinL (TCNum m) (TCNum n) i = ...
indexMinL (TCNum m) TCInf i = i;
indexMinL TCInf (TCNum n) i = IndexInf (finFront n (unIndexNum n i));
indexMinL TCInf TCInf i = i;

indexMinR :: (m n :: Num) -> Index (tcMin m n) -> Index n;
--indexMinR (TCNum m) (TCNum n) i = ...
indexMinR (TCNum m) TCInf i = IndexInf (finFront m (unIndexNum m i));
indexMinR TCInf (TCNum n) i = i;
indexMinR TCInf TCInf i = i;

indexSplit :: (m n :: Num) -> Index (tcMul m n) -> #(Index m, Index n);

indexFst :: (m n :: Num) -> Index (tcMul m n) -> Index m;
indexFst (TCNum m) (TCNum n) i = IndexNum m (finFst m n (unIndexNum (mulNat m n) i));
-- TODO: more cases

indexSnd :: (m n :: Num) -> Index (tcMul m n) -> Index n;
indexSnd (TCNum m) (TCNum n) i = IndexNum n (finSnd m n (unIndexNum (mulNat m n) i));
-- TODO: more cases

--------------------------------------------------------------------------------
-- Possibly infinite sequences

data Seq :: Num -> sort 0 -> sort 0 where {
    SeqNum :: (n :: Nat) -> (a :: sort 0) -> Vec n a -> Seq (TCNum n) a;
    SeqInf :: (a :: sort 0) -> (Nat -> a) -> Seq TCInf a;
  }

unSeqNum :: (n :: Nat) -> (a :: sort 0) -> Seq (TCNum n) a -> Vec n a;
unSeqNum _ _ (SeqNum _ _ v) = v;

unSeqInf :: (a :: sort 0) -> Seq TCInf a -> Nat -> a;
unSeqInf _ (SeqInf _ f) = f;

make :: (n :: Num) -> (a :: sort 0) -> (Index n -> a) -> Seq n a;
make (TCNum n) a f = SeqNum n a (Prelude.generate n a (\(i :: Fin n) -> f (IndexNum n i)));
make TCInf a f = SeqInf a (\(i :: Nat) -> f (IndexInf i));

peek :: (n :: Num) -> (a :: sort 0) -> Seq n a -> Index n -> a;
peek (TCNum n) a v i = Prelude.get n a (unSeqNum n a v) (unIndexNum n i);
peek TCInf a v i = unSeqInf a v (unIndexInf i);

constSeq :: (n :: Num) -> (a :: sort 0) -> a -> Seq n a;
constSeq (TCNum n) a x = SeqNum n a (replicate n a x);
constSeq TCInf a x = SeqInf a (\(_::Nat) -> x);

bvToSeq :: (n :: Nat) -> bitvector n -> Seq (TCNum n) Bool;
bvToSeq n x = SeqNum n Bool x;

bvOfSeq :: (n :: Nat) -> Seq (TCNum n) Bool -> bitvector n;
bvOfSeq n x = unSeqNum n Bool x;

--------------------------------------------------------------------------------
-- Types

data KType :: sort 0 where {
    TCBit :: KType;
    TCSeq :: Num -> KType -> KType;
    TCFun :: KType -> KType -> KType;
    TCPair :: KType -> KType -> KType;
  }

ty :: KType -> sort 0;
ty TCBit = Bool;
ty (TCSeq n a) = Seq n (ty a);
ty (TCFun a b) = ty a -> ty b;
ty (TCPair a b) = #(ty a, ty b);

--------------------------------------------------------------------------------
-- Predicate symbols

PEqual :: Num -> Num -> sort 0;
PNeq   :: Num -> Num -> sort 0;
PGeq   :: Num -> Num -> sort 0;

data PFin :: Num -> sort 0 where {
    PFinNum :: (n :: Nat) -> PFin (TCNum n);
  }

pfinWidth :: (n :: Num) -> PFin n -> PFin (tcWidth n);
pfinWidth _ (PFinNum n) = PFinNum (widthNat n);

pfinSub :: (m n :: Num) -> PFin m -> PFin n -> PFin (tcSub m n);
pfinSub _ _ (PFinNum m) (PFinNum n) = PFinNum (subNat m n);

-- PHas Selector

data PArith :: KType -> sort 0 where {
    PArithWord :: (n :: Num) -> PFin n -> PArith (TCSeq n TCBit);
    PArithSeq :: (n :: Num) -> (a :: KType) -> PArith a -> PArith (TCSeq n a);
    PArithPair :: (a b :: KType) -> PArith a -> PArith b -> PArith (TCPair a b);
  }

data PCmp :: KType -> sort 0 where {
    PCmpBit :: PCmp TCBit;
    PCmpSeq :: (n :: Num) -> (a :: KType) -> PFin n -> PCmp a -> PCmp (TCSeq n a);
    PCmpPair :: (a b :: KType) -> PCmp a -> PCmp b -> PCmp (TCPair a b);
  }

theNat :: (m :: Num) -> PFin m -> Nat;
--theNat _ (Instance_PFin_TCNum n) = n;

theVec :: (m :: Num) -> (a :: sort 0) -> (p :: PFin m) -> Seq m a -> Vec (theNat m p) a;
--theVec _ a (Instance_PFin_TCNum n) xs = vecOfSeq a n xs;

--------------------------------------------------------------------------------
-- Auxiliary functions

eProofApp :: (a :: sort 0) -> a;
eCast :: (a b :: KType) -> ty a -> ty b;

eList :: (a :: KType) -> (n :: Nat) -> Vec n (ty a) -> Seq (TCNum n) (ty a);
eList a n v = SeqNum n (ty a) v;

eListSel :: (a :: KType) -> (n :: Num) -> Seq n (ty a) -> Nat -> ty a;

eIf :: (a :: KType) -> Bool -> ty a -> ty a -> ty a;
eIf a = ite (ty a);

--------------------------------------------------------------------------------
-- List comprehensions

-- TODO: use Prelude one
uncurry :: (a b c :: KType) -> (ty a -> ty b -> ty c) -> (#(ty a, ty b) -> ty c);
uncurry a b c f = (\(x :: #(ty a, ty b)) -> f (x.1) (x.2));

from :: (a b :: KType) -> (m n :: Num) -> Seq m (ty a) -> (ty a -> Seq n (ty b)) -> Seq (tcMul m n) #(ty a, ty b);
from a b m n xs f =
  make (tcMul m n) #(ty a, ty b)
    (\(i :: Index (tcMul m n)) ->
      (peek m (ty a) xs (indexFst m n i),
       peek n (ty b) (f (peek m (ty a) xs (indexFst m n i))) (indexSnd m n i)));

single :: (a :: KType) -> ty a -> Seq (TCNum 1) (ty a);
single a x = make (TCNum 1) (ty a) (\(i :: Index (TCNum 1)) -> x);

mlet :: (a b :: KType) -> (n :: Num) -> ty a -> (ty a -> Seq n (ty b)) -> Seq n #(ty a, ty b);
mlet a b n x f = make n #(ty a, ty b) (\(i :: Index n) -> (x, peek n (ty b) (f x) i));

zip :: (a b :: KType) -> (m n :: Num) -> Seq m (ty a) -> Seq n (ty b) -> Seq (tcMin m n) #(ty a, ty b);
zip a b m n xs ys =
  make (tcMin m n) #(ty a, ty b)
    (\(i :: Index (tcMin m n)) ->
      (peek m (ty a) xs (indexMinL m n i), peek n (ty b) ys (indexMinR m n i)));

map :: (a b :: KType) -> (n :: Num) -> (ty a -> ty b) -> Seq n (ty a) -> Seq n (ty b);
map a b n f xs = make n (ty b) (\(i :: Index n) -> f (peek n (ty a) xs i));

--------------------------------------------------------------------------------
-- Arith functions

bvBinary :: (n :: Nat) -> (bitvector n -> bitvector n -> bitvector n)
  -> Seq (TCNum n) Bool -> Seq (TCNum n) Bool -> Seq (TCNum n) Bool;
bvBinary n f xs ys = bvToSeq n (f (bvOfSeq n xs) (bvOfSeq n ys));

seqBinary :: (n :: Num) -> (a :: KType) -> (ty a -> ty a -> ty a) -> Seq n (ty a) -> Seq n (ty a) -> Seq n (ty a);
seqBinary n a f xs ys = make n (ty a) (\(i :: Index n) -> f (peek n (ty a) xs i) (peek n (ty a) ys i));

pairBinary :: (a b :: KType) -> (ty a -> ty a -> ty a) -> (ty b -> ty b -> ty b) -> #(ty a, ty b) -> #(ty a, ty b) -> #(ty a, ty b);
pairBinary a b f g x y = (f x.1 y.1, g x.2 y.2);

arithBinary :: ((n :: Nat) -> bitvector n -> bitvector n -> bitvector n)
         -> (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
arithBinary bvOp _ (PArithWord _ (PFinNum n)) = bvBinary n (bvOp n);
arithBinary bvOp _ (PArithSeq n a pa) = seqBinary n a (arithBinary bvOp a pa);
arithBinary bvOp _ (PArithPair a b pa pb) =
  pairBinary a b (arithBinary bvOp a pa) (arithBinary bvOp b pb);

--------------------------------------------------------------------------------
-- Primitive Cryptol functions

ecDemote :: (val bits :: Num) -> PFin val -> PFin bits -> PGeq bits (tcWidth val) -> Seq bits Bool;
ecDemote _ _ (PFinNum val) (PFinNum bits) _ = bvToSeq bits (bvNat bits val);

-- Arith
ecPlus  :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecPlus = arithBinary bvAdd;

ecMinus :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMinus = arithBinary bvSub;

ecMul :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMul = arithBinary bvMul;

ecDiv   :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMod   :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecExp   :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecLg2   :: (a :: KType) -> PArith a -> ty a -> ty a;
ecNeg   :: (a :: KType) -> PArith a -> ty a -> ty a;

-- Cmp
ecLt    :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecGt    :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecLtEq  :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecGtEq  :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;

ecEq :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecEq _ PCmpBit = boolEq;
--ecEq _ (PCmpSeq n a pn pa) = allSeq n 
ecEq _ (PCmpPair a b pa pb) =
  (\(x :: #(ty a, ty b)) -> \(y :: #(ty a, ty b)) -> and (ecEq a pa x.1 y.1) (ecEq b pb x.2 y.2));

ecNotEq :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecNotEq a pa x y = not (ecEq a pa x y);

ecFunEq    :: (a b :: KType) -> PCmp b -> (ty a -> ty b) -> (ty a -> ty b) -> ty a -> Bool;
ecFunEq a b pb f g x = ecEq b pb (f x) (g x);

ecFunNotEq :: (a b :: KType) -> PCmp b -> (ty a -> ty b) -> (ty a -> ty b) -> ty a -> Bool;
ecFunNotEq a b pb f g x = ecNotEq b pb (f x) (g x);

ecMin :: (a :: KType) -> PCmp a -> ty a -> ty a -> ty a;
ecMax :: (a :: KType) -> PCmp a -> ty a -> ty a -> ty a;

-- Logic
ecAnd   :: (a :: KType) -> ty a -> ty a -> ty a;
ecAnd TCBit = and;
ecAnd (TCSeq n a) = seqBinary n a (ecAnd a);
--ecAnd (TCFun a b) = 
ecAnd (TCPair a b) = pairBinary a b (ecAnd a) (ecAnd b);

ecOr :: (a :: KType) -> ty a -> ty a -> ty a;
ecOr TCBit = or;
ecOr (TCSeq n a) = seqBinary n a (ecOr a);
--ecOr (TCFun a b) = 
ecOr (TCPair a b) = pairBinary a b (ecOr a) (ecOr b);

ecXor :: (a :: KType) -> ty a -> ty a -> ty a;
ecXor TCBit = xor;
ecXor (TCSeq n a) = seqBinary n a (ecXor a);
--ecXor (TCFun a b) = 
ecXor (TCPair a b) = pairBinary a b (ecXor a) (ecXor b);

ecCompl :: (a :: KType) -> ty a -> ty a;
ecCompl TCBit = not;
ecCompl (TCSeq n a) = map a a n (ecCompl a);
--ecCompl (TCFun a b) = 
--ecCompl (TCPair a b) = 

ecZero  :: (a :: KType) -> ty a;
ecZero TCBit = False;
ecZero (TCSeq n a) = constSeq n (ty a) (ecZero a);
ecZero (TCFun a b) = (\(_::ty a) -> ecZero b);
ecZero (TCPair a b) = (ecZero a, ecZero b);

-- Sequences
ecShiftL :: (m n :: Num) -> (a :: KType) -> Seq m (ty a) -> Seq n Bool -> Seq m (ty a);
ecShiftR :: (m n :: Num) -> (a :: KType) -> Seq m (ty a) -> Seq n Bool -> Seq m (ty a);
ecRotL   :: (m n :: Num) -> (a :: KType) -> Seq m (ty a) -> Seq n Bool -> Seq m (ty a);
ecRotR   :: (m n :: Num) -> (a :: KType) -> Seq m (ty a) -> Seq n Bool -> Seq m (ty a);

ecCat :: (m n :: Num) -> (a :: KType) -> PFin m -> Seq m (ty a) -> Seq n (ty a) -> Seq (tcAdd m n) (ty a);
ecSplitAt :: (m n :: Num) -> (a :: KType) -> PFin m -> Seq (tcAdd m n) (ty a) -> #(Seq m (ty a), Seq n (ty a));
ecJoin    :: (m n :: Num) -> (a :: KType) -> PFin n -> Seq m (Seq n (ty a)) -> Seq (tcMul m n) (ty a);
ecSplit   :: (m n :: Num) -> (a :: KType) -> PFin n -> Seq (tcMul m n) (ty a) -> Seq m (Seq n (ty a));

ecReverse   :: (n :: Num) -> (a :: KType) -> PFin n -> Seq n (ty a) -> Seq n (ty a);

ecTranspose :: (m n :: Num) -> (a :: KType) -> Seq m (Seq n (ty a)) -> Seq n (Seq m (ty a));
ecTranspose m n a xss =
  make n (Seq m (ty a)) (\(j::Index n) ->
    make m (ty a) (\(i::Index m) -> peek n (ty a) (peek m (Seq n (ty a)) xss i) j));

ecAt :: (n :: Num) -> (a :: KType) -> (m :: Num) -> Seq n (ty a) -> Seq m Bool -> ty a;
ecAtRange :: (n :: Num) -> (a :: KType) -> (m i :: Num) -> PFin i -> Seq n (ty a) -> Seq m (Seq i Bool) -> Seq m (ty a);
ecAtBack :: (n :: Num) -> (a :: KType) -> (m :: Num) -> PFin n -> Seq n (ty a) -> Seq m Bool -> (ty a);
ecAtRangeBack :: (n :: Num) -> (a :: KType) -> (m i :: Num) -> PFin n -> Seq n (ty a) -> Seq m (Seq i Bool) -> Seq m (ty a);

-- Static word sequences
ecFromThen :: (first next bits len :: Num) -> PFin first -> PFin next -> PFin bits
           -> PGeq bits (tcWidth first) -> PGeq bits (tcWidth next)
           -> PEqual (tcLenFromThen first next bits) len
           -> Seq len (Seq bits Bool);

ecFromTo :: (first last bits :: Num) -> PFin last -> PFin bits
         -> PGeq last first -> PGeq bits (tcWidth last)
         -> Seq (tcAdd (TCNum 1) (tcSub last first)) (Seq bits Bool);

-- Infinite word sequences
ecInfFrom :: (n :: Num) -> PFin n -> Seq n Bool -> Seq TCInf (Seq n Bool);
ecInfFrom _ (PFinNum n) (SeqNum _ _ w) =
  SeqInf (Seq (TCNum n) Bool) (\(i :: Nat) -> SeqNum n Bool (bvAdd n w (bvNat n i)));

ecInfFromThen :: (n :: Num) -> PFin n -> Seq n Bool -> Seq n Bool -> Seq TCInf (Seq n Bool);

-- Run-time error
ecError :: (a :: KType) -> (len :: Num) -> PFin len -> Seq len (Seq (TCNum 8) Bool) -> ty a;

-- Polynomials
ecPMul :: (a b :: Num) -> PFin a -> PFin b -> Seq a Bool -> Seq b Bool
       -> Seq (tcSub (tcMax (TCNum 1) (tcAdd a b)) (TCNum 1)) Bool;

ecPDiv :: (a b :: Num) -> PFin a -> PFin b
       -> Seq a Bool -> Seq b Bool -> Seq a Bool;

ecPMod :: (a b :: Num) -> PFin a -> PFin b
       -> Seq a Bool -> Seq (tcAdd (TCNum 1) b) Bool -> Seq b Bool;

-- Random values
ecRandom :: (a :: KType) -> Seq (TCNum 32) Bool -> ty a;


--------------------------------------------------------------------------------
-- Extra functions that appear after rewriting

bvOfSeq_bvToSeq ::
  (n :: Nat) -> (x :: bitvector n) -> Eq (bitvector n) (bvOfSeq n (bvToSeq n x)) x;

peek_make ::
  (n :: Num) -> (a :: sort 0) -> (f :: Index n -> a) -> (i :: Index n)
  -> Eq a (peek n a (make n a f) i) (f i);

--------------------------------------------------------------------------------
-- Rewrite rules

replicate_False :: (n :: Nat) -> Eq (bitvector n) (replicate n Bool False) (bvNat n 0);

eCast_same :: (a :: KType) -> (x :: ty a) -> Eq (ty a) (eCast a a x) x;

subNat_0 :: (n :: Nat) -> Eq Nat (subNat n 0) n;

-- TODO: implement these rules more generally with conversions:
subNat_5_1 :: Eq Nat (subNat 5 1) 4;
widthNat_4 :: Eq Nat (widthNat 4) 3;
widthNat_5 :: Eq Nat (widthNat 5) 3;

--------------------------------------------------------------------------------
