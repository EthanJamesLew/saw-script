--------------------------------------------------------------------------------
-- Cryptol primitives for SAWCore

module Cryptol where

import Prelude;

--------------------------------------------------------------------------------
-- Additional operations on Prelude types

{-
pairMap :: (a1 b1 a2 b2 :: sort 0) -> (a1 -> b1) -> (a2 -> b2) ->
           #(a1, a2) -> #(b1, b2);
pairMap a1 _ a2 _ f g xy = (f (fst a1 a2 xy), g (snd a1 a2 xy));

pairMap2 :: (a1 b1 c1 a2 b2 c2 :: sort 0) ->
            (a1 -> b1 -> c1) -> (a2 -> b2 -> c2) ->
            #(a1, a2) -> #(b1, b2) -> #(c1, c2);
pairMap2 a1 b1 _ a2 b2 _ f1 f2 x12 y12 =
  (f1 (fst a1 a2 x12) (fst b1 b2 y12), f2 (snd a1 a2 x12) (snd b1 b2 y12));
-}

compose :: (a b c :: sort 0) -> (b -> c) -> (a -> b) -> (a -> c);
compose _ _ _ f g x = f (g x);

bvExp :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
bvExp n x y = foldr Bool (bitvector n) n
  (\ (b :: Bool) -> \ (a :: bitvector n) ->
    ite (bitvector n) b (bvMul n x (bvMul n a a)) (bvMul n a a))
  (bvNat n 1)
  (reverse n Bool y);


--------------------------------------------------------------------------------
-- Extended natural numbers

data Num :: sort 0 where {
    TCNum :: Nat -> Num;
    TCInf :: Num;
  }

Num_rec :: (p:: Num -> sort 1) -> ((n::Nat) -> p (TCNum n)) -> p TCInf ->
           (n::Num) -> p n;
Num_rec p f1 f2 (TCNum n) = f1 n;
Num_rec p f1 f2 TCInf = f2;

tcWidth :: Num -> Num;
tcWidth n = Num_rec (\ (n::Num) -> Num)
                    (\ (x::Nat) -> TCNum (widthNat x)) TCInf n;

-- Build a binary function on Nums by lifting a binary function on Nats (the
-- first argument) and using additional cases for: when the first argument is a
-- Nat and the second is infinite; when the second is a Nat and the first is
-- infinite; and when both are infinite
binaryNumFun :: (Nat -> Nat -> Nat) -> (Nat -> Num) -> (Nat -> Num) -> Num ->
                Num -> Num -> Num;
binaryNumFun f1 f2 f3 f4 num1 num2 =
  Num_rec (\ (num1'::Num) -> Num)
          (\ (n1::Nat) ->
             Num_rec (\ (num2'::Num) -> Num)
                     (\ (n2::Nat) -> TCNum (f1 n1 n2))
                     (f2 n1) num2)
          (Num_rec (\ (num2'::Num) -> Num) f3 f4 num2)
          num1;

-- Build a trinary function on Nums by lifting a trinary function on Nats, with
-- a single default case if any of the Nums is infinite
trinaryNumFun :: (Nat -> Nat -> Nat -> Nat) -> Num ->
                 Num -> Num -> Num -> Num;
trinaryNumFun f1 f2 num1 num2 num3 =
  Num_rec
    (\ (num1'::Num) -> Num)
    (\ (n1::Nat) ->
       Num_rec
         (\ (num2'::Num) -> Num)
         (\ (n2::Nat) ->
            Num_rec
              (\ (num3'::Num) -> Num)
              (\ (n3::Nat) -> TCNum (f1 n1 n2 n3))
              f2 num3)
         f2 num2)
    f2 num1;

tcAdd :: Num -> Num -> Num;
tcAdd =
  binaryNumFun addNat (\ (x::Nat) -> TCInf) (\ (y::Nat) -> TCInf) TCInf;

tcSub :: Num -> Num -> Num;
tcSub =
  binaryNumFun subNat
               -- x - infinity = 0
               (\ (x::Nat) -> TCNum 0)
               -- infinity - y = infinity
               (\ (y::Nat) -> TCInf)
               -- infinity - infinity = 0
               (TCNum 0);

tcMul :: Num -> Num -> Num;
tcMul =
  binaryNumFun mulNat
               (\ (x::Nat) -> ite__def Num (equalNat 0 x) (TCNum 0) TCInf)
               (\ (y::Nat) -> ite__def Num (equalNat 0 y) (TCNum 0) TCInf)
               TCInf;

tcDiv :: Num -> Num -> Num;
tcDiv =
  binaryNumFun (\ (x::Nat) -> \ (y::Nat) -> (divModNat x y).1)
               (\ (x::Nat) -> TCNum 0)
               (\ (y::Nat) -> TCInf)
               -- infinity / infinity = 1
               (TCNum 1);

tcMod :: Num -> Num -> Num;
tcMod =
  binaryNumFun (\ (x::Nat) -> \ (y::Nat) -> (divModNat x y).2)
               (\ (x::Nat) -> TCNum 0)
               -- infinity % y = 0, since y*infinity + 0 = infinity
               (\ (y::Nat) -> TCNum 0)
               -- infinity % infinity = 0
               (TCNum 0);

tcExp :: Num -> Num -> Num;
tcExp =
  binaryNumFun expNat
               (\ (x::Nat) ->
                  ite__def Num (equalNat 0 x) (TCNum 0)
                  (ite__def Num (equalNat 1 x) (TCNum 1) TCInf))
               (\ (y::Nat) ->
                  ite Num (equalNat 0 y) (TCNum 1) TCInf)
               TCInf;

tcMin :: Num -> Num -> Num;
tcMin =
  binaryNumFun minNat (\ (x::Nat) -> TCNum x) (\ (y::Nat) -> TCNum y) TCInf;

tcMax :: Num -> Num -> Num;
tcMax =
  binaryNumFun maxNat (\ (x::Nat) -> TCInf) (\ (y::Nat) -> TCInf) TCInf;

tcLenFromThen_Nat :: Nat -> Nat -> Nat -> Nat;
tcLenFromThen_Nat x y w =
  tcLenFromThenTo_Nat x y (ite__def Nat (ltNat x y) (subNat (expNat 2 w) 1) 0);

tcLenFromThenTo_Nat :: Nat -> Nat -> Nat -> Nat;
tcLenFromThenTo_Nat x y z =
  ite__def Nat (ltNat x y)
    (ite__def Nat (ltNat z x) 0
              (addNat (divNat (subNat z x) (subNat y x)) 1)) -- increasing
    (ite__def Nat (ltNat x z) 0
              (addNat (divNat (subNat x z) (subNat x y)) 1)); -- decreasing

tcLenFromThen :: Num -> Num -> Num -> Num;
tcLenFromThen = trinaryNumFun tcLenFromThen_Nat TCInf;

tcLenFromThenTo :: Num -> Num -> Num -> Num;
tcLenFromThenTo = trinaryNumFun tcLenFromThenTo_Nat TCInf;


--------------------------------------------------------------------------------
-- Possibly infinite sequences

seq :: Num -> sort 0 -> sort 0;
seq num a =
  Num_rec (\ (num::Num) -> sort 0) (\ (n::Nat) -> Vec n a) (Stream a) num;

seqMap :: (a b :: sort 0) -> (n :: Num) -> (a -> b) -> seq n a -> seq n b;
seqMap a b num f =
  Num_rec (\ (n::Num) -> seq n a -> seq n b) (map a b f) (streamMap a b f) num;

seqConst :: (n :: Num) -> (a :: sort 0) -> a -> seq n a;
seqConst =
  Num_rec (\ (n::Num) -> (a :: sort 0) -> a -> seq n a) replicate streamConst;


--------------------------------------------------------------------------------
-- Auxiliary functions

eListSel :: (a :: sort 0) -> (n :: Num) -> seq n a -> Nat -> a;
eListSel a =
  Num_rec (\ (num::Num) -> seq num a -> Nat -> a)
          (\ (n::Nat) -> at n a) (streamGet a);


--------------------------------------------------------------------------------
-- List comprehensions

from :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> (a -> seq n b) ->
        seq (tcMul m n) #(a, b);
from a b =
  Num_rec
    (\ (m::Num) -> (n :: Num) -> seq m a -> (a -> seq n b) ->
                   seq (tcMul m n) #(a, b))
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> Vec m a -> (a -> seq n b) ->
                        seq (tcMul (TCNum m) n) #(a, b))
         -- Case 1: (TCNum m, TCNum n)
         (\ (n::Nat) ->
            \ (xs :: Vec m a) ->
            \ (k :: a -> Vec n b) ->
              join m n #(a, b)
                   (map a (Vec n #(a, b))
                        (\ (x :: a) ->
                           map b #(a, b) (\ (y :: b) -> (x, y)) n (k x))
                        m xs))
         -- Case 2: n = (TCNum m, TCInf)
         (natCase
            (\ (m'::Nat) -> (Vec m' a -> (a -> Stream b) ->
               seq (ite__def Num (equalNat 0 m') (TCNum 0) TCInf) #(a, b)))
            (\ (xs :: Vec 0 a) ->
             \ (k :: a -> Stream b) -> EmptyVec #(a, b))
            (\ (m' :: Nat) ->
             \ (xs :: Vec (Succ m') a) ->
             \ (k :: a -> Stream b) ->
               (\ (x :: a) -> streamMap b #(a, b) (\ (y::b) -> (x, y)) (k x))
               (at (Succ m') a xs 0))
            m))
    (Num_rec
       (\ (n::Num) -> Stream a -> (a -> seq n b) -> seq (tcMul TCInf n) #(a, b))
       -- Case 3: (TCInf, TCNum n)
       (\ (n::Nat) ->
          natCase
            (\ (n'::Nat) -> (Stream a -> (a -> Vec n' b) ->
                seq (ite__def Num (equalNat 0 n') (TCNum 0) TCInf) #(a, b)))
            (\ (xs :: Stream a) ->
             \ (k :: a -> Vec 0 b) -> EmptyVec #(a, b))
            (\ (n' :: Nat) ->
             \ (xs :: Stream a) ->
             \ (k :: a -> Vec (Succ n') b) ->
               streamJoin
                 #(a, b) n'
                 (streamMap
                    a (Vec (Succ n') #(a, b))
                    (\ (x::a) ->
                       map b #(a, b) (\ (y::b) -> (x, y)) (Succ n') (k x))
                    xs))
            n)
       -- Case 4: (TCInf, TCInf)
       (\ (xs :: Stream a) ->
        \ (k :: a -> Stream b) ->
          (\ (x :: a) -> streamMap b #(a, b) (\ (y :: b) -> (x, y)) (k x))
          (streamGet a xs 0)));


mlet :: (a b :: sort 0) -> (n :: Num) -> a -> (a -> seq n b) -> seq n #(a, b);
mlet a b =
  Num_rec
    (\ (n::Num) -> a -> (a -> seq n b) -> seq n #(a, b))
    (\ (n::Nat) -> \ (x::a) -> \ (f::a -> Vec n b) ->
       map b #(a, b) (\ (y :: b) -> (x, y)) n (f x))
    (\ (x::a) -> \ (f::a -> Stream b) ->
       streamMap b #(a, b) (\ (y :: b) -> (x, y)) (f x));

seqZip :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> seq n b ->
          seq (tcMin m n) #(a, b);
seqZip a b =
  Num_rec
    (\ (m::Num) -> (n::Num) -> seq m a -> seq n b -> seq (tcMin m n) #(a, b))
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> Vec m a -> seq n b -> seq (tcMin (TCNum m) n) #(a, b))
         (\ (n::Nat) -> zip a b m n)
         (\ (xs::Vec m a) -> \ (ys::Stream b) ->
            gen m #(a, b) (\ (i :: Nat) -> (at m a xs i, streamGet b ys i))))
    (Num_rec
       (\ (n::Num) -> Stream a -> seq n b -> seq (tcMin TCInf n) #(a, b))
       (\ (n::Nat) ->
        \ (xs::Stream a) -> \ (ys::Vec n b) ->
          gen n #(a, b) (\ (i :: Nat) -> (streamGet a xs i, at n b ys i)))
       (streamMap2 a b #(a, b) (\ (x::a) -> \ (y::b) -> (x, y))));


--------------------------------------------------------------------------------
-- Arith and Logic functions

seqBinary :: (n :: Num) -> (a :: sort 0) -> (a -> a -> a) ->
             seq n a -> seq n a -> seq n a;
seqBinary num a f =
  Num_rec
    (\ (n::Num) -> seq n a -> seq n a -> seq n a)
    (\ (n::Nat) -> zipWith a a a f n)
    (streamMap2 a a a f)
    num;

unitUnary :: #() -> #();
unitUnary _ = ();

emptyUnary :: #{} -> #{};
emptyUnary _ = {};

unitBinary :: #() -> #() -> #();
unitBinary _ _ = ();

pairUnary :: (a b :: sort 0) -> (a -> a) -> (b -> b) -> #(a | b) -> #(a | b);
pairUnary a b f g xy = (f (fst a b xy) | g (snd a b xy));

pairBinary :: (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b)
           -> #(a | b) -> #(a | b) -> #(a | b);
pairBinary a b f g x12 y12 = (f (fst a b x12) (fst a b y12) |
                              g (snd a b x12) (snd a b y12));

emptyBinary :: #{} -> #{} -> #{};
emptyBinary _ _ = {};

fieldUnary :: (s :: String) -> (a b :: sort 0) -> (a -> a) -> (b -> b)
         -> #{ (s) :: a | b } -> #{ (s) :: a | b };
fieldUnary s _ _ f g { (_) = x | y } = { (s) = f x | g y };

fieldBinary :: (s :: String) -> (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b)
            -> #{ (s) :: a | b } -> #{ (s) :: a | b } -> #{ (s) :: a | b };
fieldBinary s a b f g { (_) = x1 | x2 } { (_) = y1 | y2 } = { (s) = f x1 y1 | g x2 y2 };

funBinary :: (a b :: sort 0) -> (b -> b -> b) -> (a -> b) -> (a -> b) -> (a -> b);
funBinary a b op f g x = op (f x) (g x);

errorUnary :: (a :: sort 0) -> a -> a;
errorUnary a _ = error a "invalid class instance";

errorBinary :: (a :: sort 0) -> a -> a -> a;
errorBinary a _ _ = error a "invalid class instance";

--------------------------------------------------------------------------------
-- Comparisons

boolCmp :: Bool -> Bool -> Bool -> Bool;
boolCmp x y k = ite__def Bool x (and y k) (or y k);

bvCmp :: (n :: Nat) -> bitvector n -> bitvector n -> Bool -> Bool;
bvCmp n x y k = or (bvult n x y) (and (bvEq n x y) k);

bvSCmp :: (n :: Nat) -> bitvector n -> bitvector n -> Bool -> Bool;
bvSCmp n x y k = or (bvslt n x y) (and (bvEq n x y) k);

vecCmp :: (n :: Nat) -> (a :: sort 0) -> (a -> a -> Bool -> Bool)
       -> (Vec n a -> Vec n a -> Bool -> Bool);
vecCmp n a f xs ys k =
  foldr (Bool -> Bool) Bool n (\(f :: Bool -> Bool) -> f) k
    (zipWith a a (Bool -> Bool) f n xs ys);

unitCmp :: #() -> #() -> Bool -> Bool;
unitCmp _ _ _ = False;

emptyCmp :: #{} -> #{} -> Bool -> Bool;
emptyCmp _ _ _ = False;

pairCmp :: (a b :: sort 0) -> (a -> a -> Bool -> Bool) -> (b -> b -> Bool -> Bool)
        -> #(a | b) -> #(a | b) -> Bool -> Bool;
pairCmp a b f g x12 y12 k =
  f (fst a b x12) (fst a b y12) (g (snd a b x12) (snd a b y12) k);

fieldCmp :: (s :: String) -> (a b :: sort 0)
         -> (a -> a -> Bool -> Bool) -> (b -> b -> Bool -> Bool)
         -> #{ (s) :: a | b } -> #{ (s) :: a | b } -> Bool -> Bool;
fieldCmp s a b f g { (_) = x1 | x2 } { (_) = y1 | y2 } k = f x1 y1 (g x2 y2 k);

errorCmp :: (a :: sort 0) -> a -> a -> Bool -> Bool;
errorCmp _ _ _ _ = error Bool "invalid Cmp instance";

--------------------------------------------------------------------------------
-- Dictionaries and overloading

Dict :: sort 0 -> sort 0;
Dict a =
  #{ and  :: a -> a -> a
   , or   :: a -> a -> a
   , xor  :: a -> a -> a
   , not  :: a -> a
   , zero :: a
   , cmp  :: a -> a -> Bool -> Bool
   , scmp :: a -> a -> Bool -> Bool
   , add  :: a -> a -> a
   , sub  :: a -> a -> a
   , mul  :: a -> a -> a
   , div  :: a -> a -> a
   , mod  :: a -> a -> a
   , exp  :: a -> a -> a
   , lg2  :: a -> a
   , neg  :: a -> a
   , sdiv :: a -> a -> a
   , smod :: a -> a -> a
   };

DictBit :: Dict Bool;
DictBit =
  { and  = and
  , or   = or
  , xor  = xor
  , not  = not
  , zero = False
  , cmp  = boolCmp
  , scmp = errorCmp Bool
  , add = errorBinary Bool
  , sub = errorBinary Bool
  , mul = errorBinary Bool
  , div = errorBinary Bool
  , mod = errorBinary Bool
  , exp = errorBinary Bool
  , lg2 = errorUnary Bool
  , neg = errorUnary Bool
  , sdiv = errorBinary Bool
  , smod = errorBinary Bool
  };

DictVec :: (a :: sort 0) -> Dict a -> (n :: Nat) -> Dict (Vec n a);
DictVec a pa n =
  { and  = zipWith a a a pa.and n
  , or   = zipWith a a a pa.or  n
  , xor  = zipWith a a a pa.xor n
  , not  = map a a pa.not n
  , zero = replicate n a pa.zero
  , cmp  = vecCmp n a pa.cmp
  , scmp = vecCmp n a pa.scmp
  , add = zipWith a a a pa.add n
  , sub = zipWith a a a pa.sub n
  , mul = zipWith a a a pa.mul n
  , div = zipWith a a a pa.div n
  , mod = zipWith a a a pa.mod n
  , exp = zipWith a a a pa.exp n
  , lg2 = map a a pa.lg2 n
  , neg = map a a pa.neg n
  , sdiv = zipWith a a a pa.sdiv n
  , smod = zipWith a a a pa.smod n
  };

DictStream :: (a :: sort 0) -> Dict a -> Dict (Stream a);
DictStream a pa =
  { and  = streamMap2 a a a pa.and
  , or   = streamMap2 a a a pa.or
  , xor  = streamMap2 a a a pa.xor
  , not  = streamMap a a pa.not
  , zero = streamConst a pa.zero
  , cmp  = errorCmp (Stream a)
  , scmp = errorCmp (Stream a)
  , add = streamMap2 a a a pa.add
  , sub = streamMap2 a a a pa.sub
  , mul = streamMap2 a a a pa.mul
  , div = streamMap2 a a a pa.div
  , mod = streamMap2 a a a pa.mod
  , exp = streamMap2 a a a pa.exp
  , lg2 = streamMap a a pa.lg2
  , neg = streamMap a a pa.neg
  , sdiv = streamMap2 a a a pa.sdiv
  , smod = streamMap2 a a a pa.smod
  };

DictWord :: (n :: Nat) -> Dict (Vec n Bool);
DictWord n =
  { and  = bvAnd n
  , or   = bvOr  n
  , xor  = bvXor n
  , not  = bvNot n
  , zero = bvNat n 0
  , cmp  = bvCmp n
  , scmp = bvSCmp n
  , add = bvAdd n
  , sub = bvSub n
  , mul = bvMul n
  , div = bvUDiv n
  , mod = bvURem n
  , exp = bvExp n
  , lg2 = bvLg2 n
  , neg = bvNeg n
  , sdiv = natCase (\(w::Nat) -> bitvector w -> bitvector w -> bitvector w)
           (errorBinary (bitvector 0)) bvSDiv n
  , smod = natCase (\(w::Nat) -> bitvector w -> bitvector w -> bitvector w)
           (errorBinary (bitvector 0)) bvSRem n
  };

DictFun :: (a b :: sort 0) -> Dict b -> Dict (a -> b);
DictFun a b pb =
  { and  = funBinary a b pb.and
  , or   = funBinary a b pb.or
  , xor  = funBinary a b pb.xor
  , not  = compose a b b pb.not
  , zero = (\(_ :: a) -> pb.zero)
  , cmp  = errorCmp (a -> b)
  , scmp = errorCmp (a -> b)
  , add = funBinary a b pb.add
  , sub = funBinary a b pb.sub
  , mul = funBinary a b pb.mul
  , div = funBinary a b pb.div
  , mod = funBinary a b pb.mod
  , exp = funBinary a b pb.exp
  , lg2 = compose a b b pb.lg2
  , neg = compose a b b pb.neg
  , sdiv = funBinary a b pb.sdiv
  , smod = funBinary a b pb.smod
  };

DictUnit :: Dict #();
DictUnit =
  { and  = unitBinary
  , or   = unitBinary
  , xor  = unitBinary
  , not  = unitUnary
  , zero = ()
  , cmp  = unitCmp
  , scmp = unitCmp
  , add = unitBinary
  , sub = unitBinary
  , mul = unitBinary
  , div = unitBinary
  , mod = unitBinary
  , exp = unitBinary
  , lg2 = unitUnary
  , neg = unitUnary
  , sdiv = unitBinary
  , smod = unitBinary
  };

DictPair :: (a b :: sort 0) -> Dict a -> Dict b -> Dict #(a | b);
DictPair a b pa pb =
  { and  = pairBinary a b pa.and pb.and
  , or   = pairBinary a b pa.or  pb.or
  , xor  = pairBinary a b pa.xor pb.xor
  , not  = pairUnary a b pa.not pb.not
  , zero = (pa.zero | pb.zero)
  , cmp  = pairCmp a b pa.cmp pb.cmp
  , scmp = pairCmp a b pa.scmp pb.scmp
  , add = pairBinary a b pa.add pb.add
  , sub = pairBinary a b pa.sub pb.sub
  , mul = pairBinary a b pa.mul pb.mul
  , div = pairBinary a b pa.div pb.div
  , mod = pairBinary a b pa.mod pb.mod
  , exp = pairBinary a b pa.exp pb.exp
  , lg2 = pairUnary a b pa.lg2 pb.lg2
  , neg = pairUnary a b pa.neg pb.neg
  , sdiv = pairBinary a b pa.sdiv pb.sdiv
  , smod = pairBinary a b pa.smod pb.smod
  };

DictEmpty :: Dict #{};
DictEmpty =
  { and  = emptyBinary
  , or   = emptyBinary
  , xor  = emptyBinary
  , not  = emptyUnary
  , zero = {}
  , cmp  = emptyCmp
  , scmp = emptyCmp
  , add = emptyBinary
  , sub = emptyBinary
  , mul = emptyBinary
  , div = emptyBinary
  , mod = emptyBinary
  , exp = emptyBinary
  , lg2 = emptyUnary
  , neg = emptyUnary
  , sdiv = emptyBinary
  , smod = emptyBinary
  };

DictField :: (s :: String) -> (a b :: sort 0) -> Dict a -> Dict b -> Dict #{ (s) :: a | b };
DictField s a b pa pb =
  { and  = fieldBinary s a b pa.and pb.and
  , or   = fieldBinary s a b pa.or  pb.or
  , xor  = fieldBinary s a b pa.xor pb.xor
  , not  = fieldUnary s a b pa.not pb.not
  , zero = { (s) = pa.zero | pb.zero }
  , cmp  = fieldCmp s a b pa.cmp pb.cmp
  , scmp = fieldCmp s a b pa.scmp pb.scmp
  , add = fieldBinary s a b pa.add pb.add
  , sub = fieldBinary s a b pa.sub pb.sub
  , mul = fieldBinary s a b pa.mul pb.mul
  , div = fieldBinary s a b pa.div pb.div
  , mod = fieldBinary s a b pa.mod pb.mod
  , exp = fieldBinary s a b pa.exp pb.exp
  , lg2 = fieldUnary s a b pa.lg2 pb.lg2
  , neg = fieldUnary s a b pa.neg pb.neg
  , sdiv = fieldBinary s a b pa.sdiv pb.sdiv
  , smod = fieldBinary s a b pa.smod pb.smod
  };

Ops :: sort 0 -> sort 0;
Ops a = #{ this :: Dict a, vec :: (n :: Nat) -> Dict (Vec n a) };

OpsBit :: Ops Bool;
OpsBit = { this = DictBit, vec = DictWord };

OpsSeq :: (n :: Num) -> (a :: sort 0) -> Ops a -> Ops (seq n a);
OpsSeq (TCNum n) a pa =
  { this = pa.vec n
  , vec = DictVec (Vec n a) (pa.vec n) };
OpsSeq TCInf a pa =
  { this = DictStream a pa.this
  , vec = DictVec (Stream a) (DictStream a pa.this) };

OpsFun :: (a b :: sort 0) -> Ops b -> Ops (a -> b);
OpsFun a b pb =
  { this = DictFun a b pb.this
  , vec = DictVec (a -> b) (DictFun a b pb.this) };

OpsUnit :: Ops #();
OpsUnit = { this = DictUnit, vec = DictVec #() DictUnit };

OpsPair :: (a b :: sort 0) -> Ops a -> Ops b -> Ops #(a | b);
OpsPair a b pa pb =
  { this = DictPair a b pa.this pb.this
  , vec = DictVec #(a | b) (DictPair a b pa.this pb.this) };

OpsEmpty :: Ops #{};
OpsEmpty = { this = DictEmpty, vec = DictVec #{} DictEmpty };

OpsField :: (s :: String) -> (a b :: sort 0) -> Ops a -> Ops b -> Ops #{ (s) :: a | b };
OpsField s a b pa pb =
  { this = DictField s a b pa.this pb.this
  , vec = DictVec #{ (s) :: a | b } (DictField s a b pa.this pb.this) };

--------------------------------------------------------------------------------
-- Primitive Cryptol functions

ecDemote :: (val bits :: Num) -> seq bits Bool;
ecDemote valnum bitsnum =
  Num_rec (\ (bits::Num) -> seq bits Bool)
          (\ (bits::Nat) ->
             Num_rec (\ (val::Num) -> Vec bits Bool)
                     (\ (val::Nat) -> bvNat bits val)
                     -- Dummy case (this used to be undefined anyway): treat
                     -- infinity mod 2^bits as 0 (but it doesn't matter)
                     (bvNat bits 0) valnum)
          -- Dummy case (this used to be undefined anyway): return the infinite
          -- stream of 0s (i.e., Falses)
          (streamConst Bool False)
          bitsnum;

-- Arith
ecPlus :: (a :: sort 0) -> Ops a -> a -> a -> a;
ecPlus a pa = pa.this.add;

ecMinus :: (a :: sort 0) -> Ops a -> a -> a -> a;
ecMinus a pa = pa.this.sub;

ecMul :: (a :: sort 0) -> Ops a -> a -> a -> a;
ecMul a pa = pa.this.mul;

ecDiv :: (a :: sort 0) -> Ops a -> a -> a -> a;
ecDiv a pa = pa.this.div;

ecMod :: (a :: sort 0) -> Ops a -> a -> a -> a;
ecMod a pa = pa.this.mod;

ecExp :: (a :: sort 0) -> Ops a -> a -> a -> a;
ecExp a pa = pa.this.exp;

ecLg2 :: (a :: sort 0) -> Ops a -> a -> a;
ecLg2 a pa = pa.this.lg2;

ecNeg :: (a :: sort 0) -> Ops a -> a -> a;
ecNeg a pa = pa.this.neg;

ecSDiv :: (a :: sort 0) -> Ops a -> a -> a -> a;
ecSDiv a pa = pa.this.sdiv;

ecSMod :: (a :: sort 0) -> Ops a -> a -> a -> a;
ecSMod a pa = pa.this.smod;

-- Cmp
ecLt :: (a :: sort 0) -> Ops a -> a -> a -> Bool;
ecLt a pa x y = pa.this.cmp x y False;

ecGt :: (a :: sort 0) -> Ops a -> a -> a -> Bool;
ecGt a pa x y = ecLt a pa y x;

ecLtEq  :: (a :: sort 0) -> Ops a -> a -> a -> Bool;
ecLtEq a pa x y = not (ecLt a pa y x);

ecGtEq  :: (a :: sort 0) -> Ops a -> a -> a -> Bool;
ecGtEq a pa x y = not (ecLt a pa x y);

ecSLt :: (a :: sort 0) -> Ops a -> a -> a -> Bool;
ecSLt a pa x y = pa.this.scmp x y False;

ecEq :: (a :: sort 0) -> Ops a -> a -> a -> Bool;
ecEq a _ = eq a;

ecNotEq :: (a :: sort 0) -> Ops a -> a -> a -> Bool;
ecNotEq a pa x y = not (ecEq a pa x y);

ecFunEq :: (a :: sort 0) -> Ops a -> (b :: sort 0) -> Ops b -> (a -> b) -> (a -> b) -> a -> Bool;
ecFunEq a _ b pb f g x = ecEq b pb (f x) (g x);

ecFunNotEq :: (a :: sort 0) -> Ops a -> (b :: sort 0) -> Ops b -> (a -> b) -> (a -> b) -> a -> Bool;
ecFunNotEq a _ b pb f g x = ecNotEq b pb (f x) (g x);

-- Logic

ecAnd :: (a :: sort 0) -> Ops a -> a -> a -> a;
ecAnd a pa = pa.this.and;

ecOr :: (a :: sort 0) -> Ops a -> a -> a -> a;
ecOr a pa = pa.this.or;

ecXor :: (a :: sort 0) -> Ops a -> a -> a -> a;
ecXor a pa = pa.this.xor;

ecCompl :: (a :: sort 0) -> Ops a -> a -> a;
ecCompl a pa = pa.this.not;

ecZero :: (a :: sort 0) -> Ops a -> a;
ecZero a pa = pa.this.zero;

-- Sequences

ecShiftL :: (m n :: Num) -> (a :: sort 0) -> Ops a -> seq m a -> seq n Bool ->
            seq m a;
ecShiftL =
  Num_rec
    (\ (m::Num) -> (n::Num) -> (a :: sort 0) -> Ops a -> seq m a ->
       seq n Bool -> seq m a)
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> (a :: sort 0) -> Ops a -> Vec m a -> seq n Bool ->
            Vec m a)
         -- Case for (TCNum m, TCNum n)
         (\ (n::Nat) -> \ (a::sort 0) -> \ (pa::Ops a) ->
            bvShiftL m a n (ecZero a pa))
         -- Error case for (TCNum m, infinity)
         (\ (a::sort 0) -> \ (pa::Ops a) -> \ (v::Vec m a) ->
          \ (s::Stream Bool) ->
            error (Vec m a) "invalid ShiftL instance"))
    (Num_rec
       (\ (n::Num) -> (a::sort 0) -> Ops a -> Stream a -> seq n Bool ->
          Stream a)
       -- Case for (infinity, TCNum n)
       (\ (n::Nat) -> \ (a::sort 0) -> \ (pa::Ops a) ->
          bvStreamShiftL a n)
       -- Error case for (infinity, infinity)
       (\ (a::sort 0) -> \ (pa::Ops a) -> \ (s1::Stream a) ->
        \ (s2 :: Stream Bool) ->
          error (Stream a) "invalid ShiftL instance"));

ecShiftR :: (m n :: Num) -> (a :: sort 0) -> Ops a -> seq m a -> seq n Bool ->
            seq m a;
ecShiftR =
  Num_rec
    (\ (m::Num) -> (n::Num) -> (a :: sort 0) -> Ops a -> seq m a ->
       seq n Bool -> seq m a)
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> (a :: sort 0) -> Ops a -> Vec m a -> seq n Bool ->
            Vec m a)
         -- Case for (TCNum m, TCNum n)
         (\ (n::Nat) -> \ (a::sort 0) -> \ (pa::Ops a) ->
            bvShiftR m a n (ecZero a pa))
         -- Error case for (TCNum m, infinity)
         (\ (a::sort 0) -> \ (pa::Ops a) -> \ (v::Vec m a) ->
          \ (s::Stream Bool) ->
            error (Vec m a) "invalid ShiftL instance"))
    (Num_rec
       (\ (n::Num) -> (a::sort 0) -> Ops a -> Stream a -> seq n Bool ->
          Stream a)
       -- Case for (infinity, TCNum n)
       (\ (n::Nat) -> \ (a::sort 0) -> \ (pa::Ops a) ->
          bvStreamShiftR a n (ecZero a pa))
       -- Error case for (infinity, infinity)
       (\ (a::sort 0) -> \ (pa::Ops a) -> \ (s1::Stream a) ->
        \ (s2 :: Stream Bool) ->
          error (Stream a) "invalid ShiftL instance"));

ecSShiftR :: (n k :: Num) -> seq n Bool -> seq k Bool -> seq n Bool;
ecSShiftR =
  Num_rec
    (\ (n::Num) -> (k::Num) -> seq n Bool -> seq k Bool -> seq n Bool)
    (\ (n::Nat) ->
       Num_rec
         (\ (k::Num) -> Vec n Bool -> seq k Bool -> Vec n Bool)
         -- Case for (TCNum n, TCNum k)
         (\ (k::Nat) ->
            natCase
              (\ (w :: Nat) -> bitvector w -> bitvector k -> bitvector w)
              (\ (x :: bitvector 0) -> \ (i :: bitvector k) -> x)
              (\ (w :: Nat) -> \ (x :: bitvector (Succ w)) ->
               \ (i :: bitvector k) -> bvSShr w x (bvToNat k i))
              n)
         -- Error case for (TCNum n, infinity)
         (\ (v::Vec n Bool) -> \ (s::Stream Bool) ->
            error (Vec n Bool) "invalid SShiftR instance"))
    -- Error case for (infinity, any m)
    (\ (k::Num) -> \ (s1::Stream Bool) -> \ (s2::seq k Bool) ->
       error (Stream Bool) "invalid SShiftR instance");

ecCarry :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecCarry =
  Num_rec (\ (n::Num) -> seq n Bool -> seq n Bool -> Bool)
          bvCarry
          -- Error case for infinity
          (\ (s1::Stream Bool) -> \ (s2::Stream Bool) ->
             error Bool "invalid Carry instance");

ecSCarry :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSCarry =
  Num_rec
    (\ (n::Num) -> seq n Bool -> seq n Bool -> Bool)
    (\ (n::Nat) ->
       natCase
         (\ (w :: Nat) -> bitvector w -> bitvector w -> Bool)
         (\ (_ :: bitvector 0) (_ :: bitvector 0) ->
            error Bool "invalid SCarry instance")
         bvSCarry n)
    (\ (_::Stream Bool) -> \ (_::Stream Bool) ->
       error Bool "invalid SCarry instance");

ecRotL :: (m n :: Num) -> (a :: sort 0) -> Ops a -> seq m a -> seq n Bool ->
          seq m a;
ecRotL =
  Num_rec
    (\ (m::Num) -> (n::Num) -> (a::sort 0) -> Ops a -> seq m a -> seq n Bool ->
       seq m a)
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> (a::sort 0) -> Ops a -> Vec m a -> seq n Bool ->
            Vec m a)
         (\ (n::Nat) -> \ (a::sort 0) -> \ (ops::Ops a) -> bvRotateL m a n)
         -- Error case for (TCNum m, infinity)
         (\ (a::sort 0) -> \ (ops::Ops a) -> \ (v::Vec m a) ->
          \ (s::Stream Bool) ->
          error (Vec m a) "invalid RotL instance"))
    -- Error case for n = infinity
    (\ (n::Num) -> \ (a::sort 0) -> \ (ops::Ops a) -> \ (s1::Stream a) ->
     \ (s2::seq n Bool) ->
     error (Stream a) "invalid RotL instance");


ecRotR :: (m n :: Num) -> (a :: sort 0) -> Ops a -> seq m a -> seq n Bool ->
          seq m a;
ecRotR =
  Num_rec
    (\ (m::Num) -> (n::Num) -> (a::sort 0) -> Ops a -> seq m a -> seq n Bool ->
       seq m a)
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> (a::sort 0) -> Ops a -> Vec m a -> seq n Bool ->
            Vec m a)
         (\ (n::Nat) -> \ (a::sort 0) -> \ (ops::Ops a) -> bvRotateR m a n)
         -- Error case for (TCNum m, infinity)
         (\ (a::sort 0) -> \ (ops::Ops a) -> \ (v::Vec m a) ->
          \ (s::Stream Bool) ->
          error (Vec m a) "invalid RotR instance"))
    -- Error case for n = infinity
    (\ (n::Num) -> \ (a::sort 0) -> \ (ops::Ops a) -> \ (s1::Stream a) ->
     \ (s2::seq n Bool) ->
     error (Stream a) "invalid RotR instance");

ecCat :: (m n :: Num) -> (a :: sort 0) -> Ops a -> seq m a -> seq n a ->
         seq (tcAdd m n) a;
ecCat =
  Num_rec
    (\ (m::Num) -> (n::Num) -> (a::sort 0) -> Ops a -> seq m a -> seq n a ->
       seq (tcAdd m n) a)
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> (a::sort 0) -> Ops a -> Vec m a -> seq n a ->
            seq (tcAdd (TCNum m) n) a)
         (\ (n::Nat) -> \ (a::sort 0) -> \ (ops::Ops a) -> append m n a)
         (\ (a::sort 0) -> \ (ops::Ops a) -> streamAppend a m))
    -- Error case for m = infinity
    (\ (n::Num) -> \ (a::sort 0) -> \ (ops::Ops a) -> \ (s1::Stream a) ->
     \ (s2::seq n a) ->
     error (seq (tcAdd TCInf n) a) "invalid Cat instance");

ecSplitAt :: (m n :: Num) -> (a :: sort 0) -> Ops a -> seq (tcAdd m n) a ->
             #(seq m a, seq n a);
ecSplitAt =
  Num_rec
    (\ (m::Num) -> (n::Num) -> (a::sort 0) -> Ops a -> seq (tcAdd m n) a ->
       #(seq m a, seq n a))
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> (a::sort 0) -> Ops a -> seq (tcAdd (TCNum m) n) a ->
            #(Vec m a, seq n a))
         -- The case (TCNum n, TCNum m)
         (\ (n::Nat) -> \ (a::sort 0) -> \ (ops::Ops a) ->
          \ (xs:: Vec (addNat m n) a) ->
            (take a m n xs, drop a m n xs))
         -- The case (TCNum m, infinity)
         (\ (a::sort 0) -> \ (ops::Ops a) -> \ (xs:: Stream a) ->
            (streamTake a m xs, streamDrop a m xs)))
    -- Error case for m = infinity
    (\ (n::Num) -> \ (a::sort 0) -> \ (ops::Ops a) ->
     \ (xs:: seq (tcAdd TCInf n) a) ->
       error #(Stream a, seq n a) "invalid SplitAt instance");

ecJoin :: (m n :: Num) -> (a :: sort 0) -> Ops a -> seq m (seq n a) ->
          seq (tcMul m n) a;
ecJoin =
  Num_rec
    (\ (m::Num) -> (n::Num) -> (a::sort 0) -> Ops a -> seq m (seq n a) ->
       seq (tcMul m n) a)
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> (a::sort 0) -> Ops a -> Vec m (seq n a) ->
            seq (tcMul (TCNum m) n) a)
         -- Case for (TCNum m, TCNum n)
         (\ (n::Nat) -> \ (a::sort 0) -> \ (_::Ops a) ->
            join m n a)
         -- Error case for (TCNum m, TCInf)
         (\ (a::sort 0) -> \ (_::Ops a) -> \ (_::Vec m (Stream a)) ->
            error (seq (tcMul (TCNum m) TCInf) a) "invalid Join instance"))
    (Num_rec
       (\ (n::Num) -> (a::sort 0) -> Ops a -> Stream (seq n a) ->
          seq (tcMul TCInf n) a)
       -- Case for (TCInf, TCNum n)
       (\ (n::Nat) -> \ (a::sort 0) -> \ (_::Ops a) ->
          natCase
            (\ (n'::Nat) -> Stream (Vec n' a) ->
               seq (ite__def Num (equalNat 0 n') (TCNum 0) TCInf) a)
            (\ (s::Stream (Vec 0 a)) -> EmptyVec a)
            (\ (n'::Nat) -> \ (s::Stream (Vec (Succ n') a)) ->
               streamJoin a n' s)
            n)
       -- Error case for (TCInf, TCInf)
       (\ (a::sort 0) -> \ (_::Ops a) -> \ (_::Stream (Stream a)) ->
          error (Stream a) "invalid Join instance"));

ecSplit :: (m n :: Num) -> (a :: sort 0) -> Ops a -> seq (tcMul m n) a ->
           seq m (seq n a);
ecSplit (TCNum m) (TCNum n) a _ = split m n a;
ecSplit TCInf (TCNum n) a _ =
  natCase
  (\(n :: Nat) ->
    seq (ite__def Num (equalNat 0 n) (TCNum 0) TCInf) a -> Stream (Vec n a))
  (streamConst (Vec 0 a)) (\(n :: Nat) -> streamSplit a (Succ n)) n;

ecReverse :: (n :: Num) -> (a :: sort 0) -> Ops a -> seq n a -> seq n a;
ecReverse (TCNum n) a _ = reverse n a;

ecTranspose :: (m n :: Num) -> (a :: sort 0) -> Ops a -> seq m (seq n a) -> seq n (seq m a);
ecTranspose (TCNum m) (TCNum n) a _ = transpose m n a;
-- TODO: other cases

ecAt :: (n :: Num) -> (a :: sort 0) -> Ops a -> (i :: Num) -> seq n a -> seq i Bool -> a;
ecAt (TCNum n) a _ (TCNum i) = bvAt n a i;
ecAt TCInf a _ (TCNum i) = bvStreamGet a i;

ecAtRange :: (n :: Num) -> (a :: sort 0) -> Ops a -> (m i :: Num) -> seq n a ->
             seq m (seq i Bool) -> seq m a;
ecAtRange n a pa m i xs = seqMap (seq i Bool) a m (ecAt n a pa i xs);

ecAtBack :: (n :: Num) -> (a :: sort 0) -> Ops a -> (i :: Num) -> seq n a ->
            seq i Bool -> a;
ecAtBack n a pa i xs = ecAt n a pa i (ecReverse n a pa xs);

ecAtRangeBack :: (n :: Num) -> (a :: sort 0) -> Ops a -> (m i :: Num) ->
                 seq n a -> seq m (seq i Bool) -> seq m a;
ecAtRangeBack n a pa m i xs = seqMap (seq i Bool) a m (ecAtBack n a pa i xs);

-- Static word sequences
ecFromThen :: (first next bits len :: Num) -> seq len (seq bits Bool);
ecFromThen (TCNum first) (TCNum next) (TCNum bits) (TCNum len) =
  gen len (Vec bits Bool)
    (\(i :: Nat) -> bvAdd bits (bvNat bits first)
                          (bvMul bits (bvSub bits (bvNat bits next) (bvNat bits first))
			              (bvNat bits i)));

ecFromTo :: (first last bits :: Num)
         -> seq (tcAdd (TCNum 1) (tcSub last first)) (seq bits Bool);
ecFromTo (TCNum first) (TCNum last) (TCNum bits) =
  gen (addNat 1 (subNat last first)) (Vec bits Bool)
    (\(i :: Nat) -> bvNat bits (addNat i first));

ecFromThenTo :: (first next last bits len :: Num) -> seq len (seq bits Bool);
ecFromThenTo (TCNum first) (TCNum next) _ (TCNum bits) (TCNum len) =
  gen len (Vec bits Bool)
    (\(i :: Nat) ->
      bvNat bits (subNat (addNat first (mulNat i next)) (mulNat i first)));

-- Infinite word sequences
ecInfFrom :: (n :: Num) -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFrom (TCNum n) w = MkStream (bitvector n) (\(i :: Nat) -> bvAdd n w (bvNat n i));

ecInfFromThen :: (n :: Num) -> seq n Bool -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFromThen (TCNum n) first next =
  MkStream (bitvector n) (\(i :: Nat) ->
    bvAdd n first (bvMul n (bvSub n next first) (bvNat n i)));

-- Run-time error
primitive cryError :: (a :: sort 0) -> (n :: Nat) -> Vec n (bitvector 8) -> a;

ecError :: (a :: sort 0) -> Ops a -> (len :: Num) -> seq len (bitvector 8) -> a;
ecError a _ (TCNum n) = cryError a n;

-- Polynomials
ecPMul :: (a b :: Num) -> seq a Bool -> seq b Bool
       -> seq (tcSub (tcMax (TCNum 1) (tcAdd a b)) (TCNum 1)) Bool;
ecPMul (TCNum a) (TCNum b) = bvPMul a b;

ecPDiv :: (a b :: Num) -> seq a Bool -> seq b Bool -> seq a Bool;
ecPDiv (TCNum a) (TCNum b) = bvPDiv a b;

ecPMod :: (a b :: Num) -> seq a Bool -> seq (tcAdd (TCNum 1) b) Bool -> seq b Bool;
ecPMod (TCNum a) (TCNum b) = bvPMod a b;

-- Random values
ecRandom :: (a :: sort 0) -> Ops a -> bitvector 32 -> a;
ecRandom a _ _ = error a "Cryptol.random";

-- Trace function; simply return the final argument
ecTrace :: (n :: Num) -> (a :: sort 0) -> Ops a -> (b :: sort 0) -> Ops b -> seq n (bitvector 8) -> a -> b -> b;
ecTrace _ _ _ _ _ _ _ x = x;

--------------------------------------------------------------------------------
-- Extra primitives

-- Array update
ecUpdate :: (n :: Num) -> (a :: sort 0) -> Ops a -> (w :: Num)
  -> seq n a -> seq w Bool -> a -> seq n a;
ecUpdate (TCNum n) a _ (TCNum w) = bvUpd n a w;
ecUpdate TCInf     a _ (TCNum w) = bvStreamUpd a w;

ecUpdateEnd :: (n :: Num) -> (a :: sort 0) -> Ops a -> (w :: Num)
  -> seq n a -> seq w Bool -> a -> seq n a;
ecUpdateEnd (TCNum n) a _ (TCNum w) xs i y = upd n a xs (subNat (subNat n 1) (bvToNat w i)) y;

-- Bitvector truncation
ecTrunc :: (m n :: Num) -> seq (tcAdd m n) Bool -> seq n Bool;
ecTrunc (TCNum m) (TCNum n) = bvTrunc m n;

-- Zero extension
ecUExt :: (m n :: Num) -> seq n Bool -> seq (tcAdd m n) Bool;
ecUExt (TCNum m) (TCNum n) = bvUExt m n;
{-
-- Sign extension
ecSExt :: (m n :: Num) -> seq (tcAdd n (TCNum 1)) Bool -> seq (tcAdd m (tcAdd n (TCNum 1))) Bool;
ecSExt (TCNum m) (TCNum n) = bvSExt m n;

-- Signed integer division
ecSDiv :: (n :: Num) -> seq (tcAdd n (TCNum 1)) Bool
  -> seq (tcAdd n (TCNum 1)) Bool -> seq (tcAdd n (TCNum 1)) Bool;
ecSDiv (TCNum n) = bvSDiv n;

-- Signed integer remainder
ecSRem :: (n :: Num) -> seq (tcAdd n (TCNum 1)) Bool
  -> seq (tcAdd n (TCNum 1)) Bool -> seq (tcAdd n (TCNum 1)) Bool;
ecSRem (TCNum n) = bvSRem n;
-}
-- Signed greater-than
ecSgt :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSgt (TCNum n) = bvsgt n;

-- Signed greater-or-equal
ecSge :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSge (TCNum n) = bvsge n;

-- Signed less-than
ecSlt :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSlt (TCNum n) = bvslt n;

-- Signed less-or-equal
ecSle :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSle (TCNum n) = bvsle n;

-- Prelude.bvSShr

--------------------------------------------------------------------------------
-- Rewrite rules

axiom replicate_False :: (n :: Nat) -> Eq (bitvector n) (replicate n Bool False) (bvNat n 0);

axiom subNat_0 :: (n :: Nat) -> Eq Nat (subNat n 0) n;

axiom demote_add_distr
  :: (w :: Nat)
  -> (x y :: Num)
  -> Eq (bitvector w)
        (ecDemote (tcAdd x y) (TCNum w))
        (bvAdd w (ecDemote x (TCNum w)) (ecDemote y (TCNum w)));

--------------------------------------------------------------------------------
