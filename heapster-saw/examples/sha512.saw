enable_experimental;
env <- heapster_init_env "SHA512" "sha512.bc";

// heapster_set_debug_level env 1;

heapster_define_perm env "int64" " " "llvmptr 64" "exists x:bv 64.eq(llvmword(x))";
heapster_define_perm env "int8" " " "llvmptr 8" "exists x:bv 8.eq(llvmword(x))";

/*
heapster_assume_fun env "llvm.memcpy.p0i8.p0i8.i64"
  "(len:bv 64). arg0:array(W,0,<len,*8,fieldsh(int64<>)), \
              \ arg1:array(W,0,<len,*8,fieldsh(int64<>)), \
              \ arg2:eq(llvmword(len)), arg3:true -o \
              \ arg0:array(W,0,<len,*8,fieldsh(int64<>)), \
              \ arg1:array(W,0,<len,*8,fieldsh(int64<>))"
  "\\ (len : Vec 64 Bool) (x y : BVVec 64 len (Vec 64 Bool)) -> \
    \ returnM (BVVec 64 len (Vec 64 Bool) * BVVec 64 len (Vec 64 Bool)) (y, y)";

// heapster_assume_fun env "llvm.objectsize.i64.p0i8" "().empty -o empty" "returnM #() ()";
// 
// heapster_assume_fun env "__memcpy_chk"
//   "(len:bv 64). arg0:byte_array<W,len>, arg1:byte_array<W,len>, arg2:eq(llvmword (len)) -o \
//               \ arg0:byte_array<W,len>, arg1:byte_array<W,len>"
//   "\\ (len:Vec 64 Bool) (_ src : BVVec 64 len (Vec 8 Bool)) -> \
//     \ returnM (BVVec 64 len (Vec 8 Bool) * BVVec 64 len (Vec 8 Bool)) (src, src)";
*/

heapster_assume_fun env "SIMPL1_CRYPTO_load_u64_be"
  "(). arg0:ptr((W,0) |-> int64<>) -o \
     \ arg0:ptr((W,0) |-> int64<>), ret:int64<>"
  "\\ (x : Vec 64 Bool) -> returnM (Vec 64 Bool * Vec 64 Bool) (x,x)";

heapster_typecheck_fun env "sha512_block_data_order_simpl1"
  "(num:bv 64). arg0:array(W,0,<1,*8,fieldsh(int64<>)), \
              \ arg1:array(W,0,<2*num,*8,fieldsh(int64<>)), \
              \ arg2:eq(llvmword(num)) -o \
              \ arg0:array(W,0,<1,*8,fieldsh(int64<>)), \
              \ arg1:array(W,0,<2*num,*8,fieldsh(int64<>)), \
              \ arg2:true, ret:true";

heapster_export_coq env "sha512_gen.v";