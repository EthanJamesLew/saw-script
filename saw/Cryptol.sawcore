--------------------------------------------------------------------------------
-- Cryptol primitives for SAWCore

module Cryptol where

import Prelude;

--------------------------------------------------------------------------------
-- Additional operations on Prelude types

{-
pairMap :: (a1 b1 a2 b2 :: sort 0) -> (a1 -> b1) -> (a2 -> b2) ->
           #(a1, a2) -> #(b1, b2);
pairMap a1 _ a2 _ f g xy = (f (fst a1 a2 xy), g (snd a1 a2 xy));

pairMap2 :: (a1 b1 c1 a2 b2 c2 :: sort 0) ->
            (a1 -> b1 -> c1) -> (a2 -> b2 -> c2) ->
            #(a1, a2) -> #(b1, b2) -> #(c1, c2);
pairMap2 a1 b1 _ a2 b2 _ f1 f2 x12 y12 =
  (f1 (fst a1 a2 x12) (fst b1 b2 y12), f2 (snd a1 a2 x12) (snd b1 b2 y12));
-}

compose :: (a b c :: sort 0) -> (b -> c) -> (a -> b) -> (a -> c);
compose _ _ _ f g x = f (g x);

bvExp :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
bvExp n x y = foldr Bool (bitvector n) n
  (\ (b :: Bool) -> \ (a :: bitvector n) ->
    ite (bitvector n) b (bvMul n x (bvMul n a a)) (bvMul n a a))
  (bvNat n 1)
  (reverse n Bool y);


--------------------------------------------------------------------------------
-- Extended natural numbers

data Num :: sort 0 where {
    TCNum :: Nat -> Num;
    TCInf :: Num;
  }

Num_rec :: (p:: Num -> sort 1) -> ((n::Nat) -> p (TCNum n)) -> p TCInf ->
           (n::Num) -> p n;
Num_rec p f1 f2 (TCNum n) = f1 n;
Num_rec p f1 f2 TCInf = f2;

-- Helper function: take a Num that we expect to be finite, and extract its Nat,
-- raising an error if that Num is not finite
getFinNat :: (n::Num) -> Nat;
getFinNat =
  Num_rec (\ (n::Num) -> Nat) (\ (n::Nat) -> n)
          (error Nat "Unexpected Fin constraint violation!");

-- Helper function: destruct a Num that we expect to be finite
finNumRec :: (p:: Num -> sort 1) -> ((n::Nat) -> p (TCNum n)) ->
             (n::Num) -> p n;
finNumRec p f =
  Num_rec p f (error (p TCInf) "Unexpected Fin constraint violation!");

-- Helper function: destruct two Nums that we expect to be finite
finNumRec2 :: (p:: Num -> Num -> sort 1) ->
              ((m n::Nat) -> p (TCNum m) (TCNum n)) ->
              (m n::Num) -> p m n;
finNumRec2 p f =
  finNumRec
    (\ (m::Num) -> (n::Num) -> p m n)
    (\ (m::Nat) -> finNumRec (p (TCNum m)) (f m));

-- Build a binary function on Nums by lifting a binary function on Nats (the
-- first argument) and using additional cases for: when the first argument is a
-- Nat and the second is infinite; when the second is a Nat and the first is
-- infinite; and when both are infinite
binaryNumFun :: (Nat -> Nat -> Nat) -> (Nat -> Num) -> (Nat -> Num) -> Num ->
                Num -> Num -> Num;
binaryNumFun f1 f2 f3 f4 num1 num2 =
  Num_rec (\ (num1'::Num) -> Num)
          (\ (n1::Nat) ->
             Num_rec (\ (num2'::Num) -> Num)
                     (\ (n2::Nat) -> TCNum (f1 n1 n2))
                     (f2 n1) num2)
          (Num_rec (\ (num2'::Num) -> Num) f3 f4 num2)
          num1;

-- Build a trinary function on Nums by lifting a trinary function on Nats, with
-- a single default case if any of the Nums is infinite
trinaryNumFun :: (Nat -> Nat -> Nat -> Nat) -> Num ->
                 Num -> Num -> Num -> Num;
trinaryNumFun f1 f2 num1 num2 num3 =
  Num_rec
    (\ (num1'::Num) -> Num)
    (\ (n1::Nat) ->
       Num_rec
         (\ (num2'::Num) -> Num)
         (\ (n2::Nat) ->
            Num_rec
              (\ (num3'::Num) -> Num)
              (\ (n3::Nat) -> TCNum (f1 n1 n2 n3))
              f2 num3)
         f2 num2)
    f2 num1;



tcWidth :: Num -> Num;
tcWidth = Num_rec (\ (n::Num) -> Num)
                  (\ (x::Nat) -> TCNum (widthNat x)) TCInf;

tcAdd :: Num -> Num -> Num;
tcAdd =
  binaryNumFun addNat (\ (x::Nat) -> TCInf) (\ (y::Nat) -> TCInf) TCInf;

tcSub :: Num -> Num -> Num;
tcSub =
  binaryNumFun subNat
               -- x - infinity = 0
               (\ (x::Nat) -> TCNum 0)
               -- infinity - y = infinity
               (\ (y::Nat) -> TCInf)
               -- infinity - infinity = 0
               (TCNum 0);

tcMul :: Num -> Num -> Num;
tcMul =
  binaryNumFun mulNat
               (\ (x::Nat) -> ite__def Num (equalNat 0 x) (TCNum 0) TCInf)
               (\ (y::Nat) -> ite__def Num (equalNat 0 y) (TCNum 0) TCInf)
               TCInf;

tcDiv :: Num -> Num -> Num;
tcDiv =
  binaryNumFun (\ (x::Nat) -> \ (y::Nat) -> (divModNat x y).1)
               (\ (x::Nat) -> TCNum 0)
               (\ (y::Nat) -> TCInf)
               -- infinity / infinity = 1
               (TCNum 1);

tcMod :: Num -> Num -> Num;
tcMod =
  binaryNumFun (\ (x::Nat) -> \ (y::Nat) -> (divModNat x y).2)
               (\ (x::Nat) -> TCNum 0)
               -- infinity % y = 0, since y*infinity + 0 = infinity
               (\ (y::Nat) -> TCNum 0)
               -- infinity % infinity = 0
               (TCNum 0);

tcExp :: Num -> Num -> Num;
tcExp =
  binaryNumFun expNat
               (\ (x::Nat) ->
                  ite__def Num (equalNat 0 x) (TCNum 0)
                  (ite__def Num (equalNat 1 x) (TCNum 1) TCInf))
               (\ (y::Nat) ->
                  ite Num (equalNat 0 y) (TCNum 1) TCInf)
               TCInf;

tcMin :: Num -> Num -> Num;
tcMin =
  binaryNumFun minNat (\ (x::Nat) -> TCNum x) (\ (y::Nat) -> TCNum y) TCInf;

tcMax :: Num -> Num -> Num;
tcMax =
  binaryNumFun maxNat (\ (x::Nat) -> TCInf) (\ (y::Nat) -> TCInf) TCInf;

ceilDivNat :: Nat -> Nat -> Nat;
ceilDivNat x y = divNat (addNat x (subNat y 1)) y;

ceilModNat :: Nat -> Nat -> Nat;
ceilModNat x y = subNat (mulNat (ceilDivNat x y) y) x;

tcCeilDiv :: Num -> Num -> Num;
tcCeilDiv (TCNum x) (TCNum y) = TCNum (ceilDivNat x y);
-- other cases undefined

tcCeilMod :: Num -> Num -> Num;
tcCeilMod (TCNum x) (TCNum y) = TCNum (ceilModNat x y);
-- other cases undefined

tcLenFromThen_Nat :: Nat -> Nat -> Nat -> Nat;
tcLenFromThen_Nat x y w =
  tcLenFromThenTo_Nat x y (ite__def Nat (ltNat x y) (subNat (expNat 2 w) 1) 0);

tcLenFromThenTo_Nat :: Nat -> Nat -> Nat -> Nat;
tcLenFromThenTo_Nat x y z =
  ite__def Nat (ltNat x y)
    (ite__def Nat (ltNat z x) 0
              (addNat (divNat (subNat z x) (subNat y x)) 1)) -- increasing
    (ite__def Nat (ltNat x z) 0
              (addNat (divNat (subNat x z) (subNat x y)) 1)); -- decreasing

tcLenFromThen :: Num -> Num -> Num -> Num;
tcLenFromThen = trinaryNumFun tcLenFromThen_Nat TCInf;

tcLenFromThenTo :: Num -> Num -> Num -> Num;
tcLenFromThenTo = trinaryNumFun tcLenFromThenTo_Nat TCInf;


--------------------------------------------------------------------------------
-- Possibly infinite sequences

seq :: Num -> sort 0 -> sort 0;
seq num a =
  Num_rec (\ (num::Num) -> sort 0) (\ (n::Nat) -> Vec n a) (Stream a) num;

seqMap :: (a b :: sort 0) -> (n :: Num) -> (a -> b) -> seq n a -> seq n b;
seqMap a b num f =
  Num_rec (\ (n::Num) -> seq n a -> seq n b) (map a b f) (streamMap a b f) num;

seqConst :: (n :: Num) -> (a :: sort 0) -> a -> seq n a;
seqConst =
  Num_rec (\ (n::Num) -> (a :: sort 0) -> a -> seq n a) replicate streamConst;


--------------------------------------------------------------------------------
-- Auxiliary functions

eListSel :: (a :: sort 0) -> (n :: Num) -> seq n a -> Nat -> a;
eListSel a =
  Num_rec (\ (num::Num) -> seq num a -> Nat -> a)
          (\ (n::Nat) -> at n a) (streamGet a);


--------------------------------------------------------------------------------
-- List comprehensions

from :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> (a -> seq n b) ->
        seq (tcMul m n) #(a, b);
from a b =
  Num_rec
    (\ (m::Num) -> (n :: Num) -> seq m a -> (a -> seq n b) ->
                   seq (tcMul m n) #(a, b))
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> Vec m a -> (a -> seq n b) ->
                        seq (tcMul (TCNum m) n) #(a, b))
         -- Case 1: (TCNum m, TCNum n)
         (\ (n::Nat) ->
            \ (xs :: Vec m a) ->
            \ (k :: a -> Vec n b) ->
              join m n #(a, b)
                   (map a (Vec n #(a, b))
                        (\ (x :: a) ->
                           map b #(a, b) (\ (y :: b) -> (x, y)) n (k x))
                        m xs))
         -- Case 2: n = (TCNum m, TCInf)
         (natCase
            (\ (m'::Nat) -> (Vec m' a -> (a -> Stream b) ->
               seq (ite__def Num (equalNat 0 m') (TCNum 0) TCInf) #(a, b)))
            (\ (xs :: Vec 0 a) ->
             \ (k :: a -> Stream b) -> EmptyVec #(a, b))
            (\ (m' :: Nat) ->
             \ (xs :: Vec (Succ m') a) ->
             \ (k :: a -> Stream b) ->
               (\ (x :: a) -> streamMap b #(a, b) (\ (y::b) -> (x, y)) (k x))
               (at (Succ m') a xs 0))
            m))
    (Num_rec
       (\ (n::Num) -> Stream a -> (a -> seq n b) -> seq (tcMul TCInf n) #(a, b))
       -- Case 3: (TCInf, TCNum n)
       (\ (n::Nat) ->
          natCase
            (\ (n'::Nat) -> (Stream a -> (a -> Vec n' b) ->
                seq (ite__def Num (equalNat 0 n') (TCNum 0) TCInf) #(a, b)))
            (\ (xs :: Stream a) ->
             \ (k :: a -> Vec 0 b) -> EmptyVec #(a, b))
            (\ (n' :: Nat) ->
             \ (xs :: Stream a) ->
             \ (k :: a -> Vec (Succ n') b) ->
               streamJoin
                 #(a, b) n'
                 (streamMap
                    a (Vec (Succ n') #(a, b))
                    (\ (x::a) ->
                       map b #(a, b) (\ (y::b) -> (x, y)) (Succ n') (k x))
                    xs))
            n)
       -- Case 4: (TCInf, TCInf)
       (\ (xs :: Stream a) ->
        \ (k :: a -> Stream b) ->
          (\ (x :: a) -> streamMap b #(a, b) (\ (y :: b) -> (x, y)) (k x))
          (streamGet a xs 0)));


mlet :: (a b :: sort 0) -> (n :: Num) -> a -> (a -> seq n b) -> seq n #(a, b);
mlet a b =
  Num_rec
    (\ (n::Num) -> a -> (a -> seq n b) -> seq n #(a, b))
    (\ (n::Nat) -> \ (x::a) -> \ (f::a -> Vec n b) ->
       map b #(a, b) (\ (y :: b) -> (x, y)) n (f x))
    (\ (x::a) -> \ (f::a -> Stream b) ->
       streamMap b #(a, b) (\ (y :: b) -> (x, y)) (f x));

seqZip :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> seq n b ->
          seq (tcMin m n) #(a, b);
seqZip a b =
  Num_rec
    (\ (m::Num) -> (n::Num) -> seq m a -> seq n b -> seq (tcMin m n) #(a, b))
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> Vec m a -> seq n b -> seq (tcMin (TCNum m) n) #(a, b))
         (\ (n::Nat) -> zip a b m n)
         (\ (xs::Vec m a) -> \ (ys::Stream b) ->
            gen m #(a, b) (\ (i :: Nat) -> (at m a xs i, streamGet b ys i))))
    (Num_rec
       (\ (n::Num) -> Stream a -> seq n b -> seq (tcMin TCInf n) #(a, b))
       (\ (n::Nat) ->
        \ (xs::Stream a) -> \ (ys::Vec n b) ->
          gen n #(a, b) (\ (i :: Nat) -> (streamGet a xs i, at n b ys i)))
       (streamMap2 a b #(a, b) (\ (x::a) -> \ (y::b) -> (x, y))));


--------------------------------------------------------------------------------
-- Arith and Logic functions

seqBinary :: (n :: Num) -> (a :: sort 0) -> (a -> a -> a) ->
             seq n a -> seq n a -> seq n a;
seqBinary num a f =
  Num_rec
    (\ (n::Num) -> seq n a -> seq n a -> seq n a)
    (\ (n::Nat) -> zipWith a a a f n)
    (streamMap2 a a a f)
    num;

unitUnary :: #() -> #();
unitUnary _ = ();

emptyUnary :: #{} -> #{};
emptyUnary _ = {};

unitBinary :: #() -> #() -> #();
unitBinary _ _ = ();

pairUnary :: (a b :: sort 0) -> (a -> a) -> (b -> b) -> #(a | b) -> #(a | b);
pairUnary a b f g xy = (f (fst a b xy) | g (snd a b xy));

pairBinary :: (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b)
           -> #(a | b) -> #(a | b) -> #(a | b);
pairBinary a b f g x12 y12 = (f (fst a b x12) (fst a b y12) |
                              g (snd a b x12) (snd a b y12));

emptyBinary :: #{} -> #{} -> #{};
emptyBinary _ _ = {};

fieldUnary :: (s :: String) -> (a b :: sort 0) -> (a -> a) -> (b -> b)
         -> #{ (s) :: a | b } -> #{ (s) :: a | b };
fieldUnary s _ _ f g { (_) = x | y } = { (s) = f x | g y };

fieldBinary :: (s :: String) -> (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b)
            -> #{ (s) :: a | b } -> #{ (s) :: a | b } -> #{ (s) :: a | b };
fieldBinary s a b f g { (_) = x1 | x2 } { (_) = y1 | y2 } = { (s) = f x1 y1 | g x2 y2 };

funBinary :: (a b :: sort 0) -> (b -> b -> b) -> (a -> b) -> (a -> b) -> (a -> b);
funBinary a b op f g x = op (f x) (g x);

errorUnary :: (a :: sort 0) -> a -> a;
errorUnary a _ = error a "invalid class instance";

errorBinary :: (a :: sort 0) -> a -> a -> a;
errorBinary a _ _ = error a "invalid class instance";

--------------------------------------------------------------------------------
-- Comparisons

boolCmp :: Bool -> Bool -> Bool -> Bool;
boolCmp x y k = ite__def Bool x (and y k) (or y k);

integerCmp :: Integer -> Integer -> Bool -> Bool;
integerCmp x y k = or (intLt x y) (and (intEq x y) k);

bvCmp :: (n :: Nat) -> bitvector n -> bitvector n -> Bool -> Bool;
bvCmp n x y k = or (bvult n x y) (and (bvEq n x y) k);

bvSCmp :: (n :: Nat) -> bitvector n -> bitvector n -> Bool -> Bool;
bvSCmp n x y k = or (bvslt n x y) (and (bvEq n x y) k);

vecCmp :: (n :: Nat) -> (a :: sort 0) -> (a -> a -> Bool -> Bool)
       -> (Vec n a -> Vec n a -> Bool -> Bool);
vecCmp n a f xs ys k =
  foldr (Bool -> Bool) Bool n (\ (f :: Bool -> Bool) -> f) k
    (zipWith a a (Bool -> Bool) f n xs ys);

unitCmp :: #() -> #() -> Bool -> Bool;
unitCmp _ _ _ = False;

emptyCmp :: #{} -> #{} -> Bool -> Bool;
emptyCmp _ _ _ = False;

pairCmp :: (a b :: sort 0) -> (a -> a -> Bool -> Bool) -> (b -> b -> Bool -> Bool)
        -> #(a | b) -> #(a | b) -> Bool -> Bool;
pairCmp a b f g x12 y12 k =
  f (fst a b x12) (fst a b y12) (g (snd a b x12) (snd a b y12) k);

fieldCmp :: (s :: String) -> (a b :: sort 0)
         -> (a -> a -> Bool -> Bool) -> (b -> b -> Bool -> Bool)
         -> #{ (s) :: a | b } -> #{ (s) :: a | b } -> Bool -> Bool;
fieldCmp s a b f g { (_) = x1 | x2 } { (_) = y1 | y2 } k = f x1 y1 (g x2 y2 k);

errorCmp :: (a :: sort 0) -> a -> a -> Bool -> Bool;
errorCmp _ _ _ _ = error Bool "invalid Cmp instance";

--------------------------------------------------------------------------------
-- Dictionaries and overloading

-- Zero class

PZero :: sort 0 -> sort 0;
PZero a = #{ zero :: a };

PZeroBit :: PZero Bool;
PZeroBit = { zero = False };

PZeroInteger :: PZero Integer;
PZeroInteger = { zero = natToInt 0 };

PZeroSeq :: (n :: Num) -> (a :: sort 0) -> PZero a -> PZero (seq n a);
PZeroSeq n a pa = { zero = seqConst n a pa.zero };

PZeroSeqBool :: (n :: Num) -> PZero (seq n Bool);
PZeroSeqBool (TCNum n) = { zero = bvNat n 0 };
PZeroSeqBool TCInf = { zero = streamConst Bool False };

PZeroFun :: (a b :: sort 0) -> PZero b -> PZero (a -> b);
PZeroFun a b pb = { zero = (\ (_ :: a) -> pb.zero) };

PZeroUnit :: PZero #();
PZeroUnit = { zero = () };

PZeroPair :: (a b :: sort 0) -> PZero a -> PZero b -> PZero #(a | b);
PZeroPair a b pa pb = { zero = (pa.zero | pb.zero) };

PZeroEmpty :: PZero #{};
PZeroEmpty = { zero = {} };

PZeroField :: (s :: String) -> (a b :: sort 0) -> PZero a -> PZero b -> PZero #{ (s) :: a | b };
PZeroField s a b pa pb = { zero = { (s) = pa.zero | pb.zero } };

-- Logic class

PLogic :: sort 0 -> sort 0;
PLogic a =
  #{ and  :: a -> a -> a
   , or   :: a -> a -> a
   , xor  :: a -> a -> a
   , not  :: a -> a
   };

PLogicBit :: PLogic Bool;
PLogicBit =
  { and  = and
  , or   = or
  , xor  = xor
  , not  = not
  };

PLogicVec :: (n :: Nat) -> (a :: sort 0) -> PLogic a -> PLogic (Vec n a);
PLogicVec n a pa =
  { and  = zipWith a a a pa.and n
  , or   = zipWith a a a pa.or  n
  , xor  = zipWith a a a pa.xor n
  , not  = map a a pa.not n
  };

PLogicStream :: (a :: sort 0) -> PLogic a -> PLogic (Stream a);
PLogicStream a pa =
  { and  = streamMap2 a a a pa.and
  , or   = streamMap2 a a a pa.or
  , xor  = streamMap2 a a a pa.xor
  , not  = streamMap a a pa.not
  };

PLogicSeq :: (n :: Num) -> (a :: sort 0) -> PLogic a -> PLogic (seq n a);
PLogicSeq (TCNum n) = PLogicVec n;
PLogicSeq TCInf = PLogicStream;

PLogicWord :: (n :: Nat) -> PLogic (Vec n Bool);
PLogicWord n =
  { and  = bvAnd n
  , or   = bvOr  n
  , xor  = bvXor n
  , not  = bvNot n
  };

PLogicSeqBool :: (n :: Num) -> PLogic (seq n Bool);
PLogicSeqBool (TCNum n) = PLogicWord n;
PLogicSeqBool TCInf = PLogicStream Bool PLogicBit;

PLogicFun :: (a b :: sort 0) -> PLogic b -> PLogic (a -> b);
PLogicFun a b pb =
  { and  = funBinary a b pb.and
  , or   = funBinary a b pb.or
  , xor  = funBinary a b pb.xor
  , not  = compose a b b pb.not
  };

PLogicUnit :: PLogic #();
PLogicUnit =
  { and  = unitBinary
  , or   = unitBinary
  , xor  = unitBinary
  , not  = unitUnary
  };

PLogicPair :: (a b :: sort 0) -> PLogic a -> PLogic b -> PLogic #(a | b);
PLogicPair a b pa pb =
  { and  = pairBinary a b pa.and pb.and
  , or   = pairBinary a b pa.or  pb.or
  , xor  = pairBinary a b pa.xor pb.xor
  , not  = pairUnary a b pa.not pb.not
  };

PLogicEmpty :: PLogic #{};
PLogicEmpty =
  { and  = emptyBinary
  , or   = emptyBinary
  , xor  = emptyBinary
  , not  = emptyUnary
  };

PLogicField :: (s :: String) -> (a b :: sort 0) -> PLogic a -> PLogic b -> PLogic #{ (s) :: a | b };
PLogicField s a b pa pb =
  { and  = fieldBinary s a b pa.and pb.and
  , or   = fieldBinary s a b pa.or  pb.or
  , xor  = fieldBinary s a b pa.xor pb.xor
  , not  = fieldUnary s a b pa.not pb.not
  };

-- Arith class

PArith :: sort 0 -> sort 0;
PArith a =
  #{ add  :: a -> a -> a
   , sub  :: a -> a -> a
   , mul  :: a -> a -> a
   , div  :: a -> a -> a
   , mod  :: a -> a -> a
   , exp  :: a -> a -> a
   , lg2  :: a -> a
   , neg  :: a -> a
   , sdiv :: a -> a -> a
   , smod :: a -> a -> a
   };

PArithInteger :: PArith Integer;
PArithInteger =
  { add = intAdd
  , sub = intSub
  , mul = intMul
  , div = intDiv
  , mod = intMod
  , exp = errorBinary Integer
  , lg2 = errorUnary Integer
  , neg = intNeg
  , sdiv = errorBinary Integer
  , smod = errorBinary Integer
  };

PArithVec :: (n :: Nat) -> (a :: sort 0) -> PArith a -> PArith (Vec n a);
PArithVec n a pa =
  { add = zipWith a a a pa.add n
  , sub = zipWith a a a pa.sub n
  , mul = zipWith a a a pa.mul n
  , div = zipWith a a a pa.div n
  , mod = zipWith a a a pa.mod n
  , exp = zipWith a a a pa.exp n
  , lg2 = map a a pa.lg2 n
  , neg = map a a pa.neg n
  , sdiv = zipWith a a a pa.sdiv n
  , smod = zipWith a a a pa.smod n
  };

PArithStream :: (a :: sort 0) -> PArith a -> PArith (Stream a);
PArithStream a pa =
  { add = streamMap2 a a a pa.add
  , sub = streamMap2 a a a pa.sub
  , mul = streamMap2 a a a pa.mul
  , div = streamMap2 a a a pa.div
  , mod = streamMap2 a a a pa.mod
  , exp = streamMap2 a a a pa.exp
  , lg2 = streamMap a a pa.lg2
  , neg = streamMap a a pa.neg
  , sdiv = streamMap2 a a a pa.sdiv
  , smod = streamMap2 a a a pa.smod
  };

PArithSeq :: (n :: Num) -> (a :: sort 0) -> PArith a -> PArith (seq n a);
PArithSeq (TCNum n) = PArithVec n;
PArithSeq TCInf = PArithStream;

PArithWord :: (n :: Nat) -> PArith (Vec n Bool);
PArithWord n =
  { add = bvAdd n
  , sub = bvSub n
  , mul = bvMul n
  , div = bvUDiv n
  , mod = bvURem n
  , exp = bvExp n
  , lg2 = bvLg2 n
  , neg = bvNeg n
  , sdiv = natCase (\ (w::Nat) -> bitvector w -> bitvector w -> bitvector w)
           (errorBinary (bitvector 0)) bvSDiv n
  , smod = natCase (\ (w::Nat) -> bitvector w -> bitvector w -> bitvector w)
           (errorBinary (bitvector 0)) bvSRem n
  };

PArithSeqBool :: (n :: Num) -> PArith (seq n Bool);
PArithSeqBool (TCNum n) = PArithWord n;

PArithFun :: (a b :: sort 0) -> PArith b -> PArith (a -> b);
PArithFun a b pb =
  { add = funBinary a b pb.add
  , sub = funBinary a b pb.sub
  , mul = funBinary a b pb.mul
  , div = funBinary a b pb.div
  , mod = funBinary a b pb.mod
  , exp = funBinary a b pb.exp
  , lg2 = compose a b b pb.lg2
  , neg = compose a b b pb.neg
  , sdiv = funBinary a b pb.sdiv
  , smod = funBinary a b pb.smod
  };

PArithUnit :: PArith #();
PArithUnit =
  { add = unitBinary
  , sub = unitBinary
  , mul = unitBinary
  , div = unitBinary
  , mod = unitBinary
  , exp = unitBinary
  , lg2 = unitUnary
  , neg = unitUnary
  , sdiv = unitBinary
  , smod = unitBinary
  };

PArithPair :: (a b :: sort 0) -> PArith a -> PArith b -> PArith #(a | b);
PArithPair a b pa pb =
  { add = pairBinary a b pa.add pb.add
  , sub = pairBinary a b pa.sub pb.sub
  , mul = pairBinary a b pa.mul pb.mul
  , div = pairBinary a b pa.div pb.div
  , mod = pairBinary a b pa.mod pb.mod
  , exp = pairBinary a b pa.exp pb.exp
  , lg2 = pairUnary a b pa.lg2 pb.lg2
  , neg = pairUnary a b pa.neg pb.neg
  , sdiv = pairBinary a b pa.sdiv pb.sdiv
  , smod = pairBinary a b pa.smod pb.smod
  };

PArithEmpty :: PArith #{};
PArithEmpty =
  { add = emptyBinary
  , sub = emptyBinary
  , mul = emptyBinary
  , div = emptyBinary
  , mod = emptyBinary
  , exp = emptyBinary
  , lg2 = emptyUnary
  , neg = emptyUnary
  , sdiv = emptyBinary
  , smod = emptyBinary
  };

PArithField :: (s :: String) -> (a b :: sort 0) -> PArith a -> PArith b -> PArith #{ (s) :: a | b };
PArithField s a b pa pb =
  { add = fieldBinary s a b pa.add pb.add
  , sub = fieldBinary s a b pa.sub pb.sub
  , mul = fieldBinary s a b pa.mul pb.mul
  , div = fieldBinary s a b pa.div pb.div
  , mod = fieldBinary s a b pa.mod pb.mod
  , exp = fieldBinary s a b pa.exp pb.exp
  , lg2 = fieldUnary s a b pa.lg2 pb.lg2
  , neg = fieldUnary s a b pa.neg pb.neg
  , sdiv = fieldBinary s a b pa.sdiv pb.sdiv
  , smod = fieldBinary s a b pa.smod pb.smod
  };

-- Cmp class

PCmp :: sort 0 -> sort 0;
PCmp a = #{ cmp :: a -> a -> Bool -> Bool };

PCmpBit :: PCmp Bool;
PCmpBit = { cmp = boolCmp };

PCmpInteger :: PCmp Integer;
PCmpInteger = { cmp = integerCmp };

PCmpVec :: (n :: Nat) -> (a :: sort 0) -> PCmp a -> PCmp (Vec n a);
PCmpVec n a pa = { cmp = vecCmp n a pa.cmp };

PCmpSeq :: (n :: Num) -> (a :: sort 0) -> PCmp a -> PCmp (seq n a);
PCmpSeq (TCNum n) a pa = PCmpVec n a pa;
PCmpSeq TCInf a pa = { cmp = errorCmp (Stream a) };

PCmpWord :: (n :: Nat) -> PCmp (Vec n Bool);
PCmpWord n = { cmp = bvCmp n };

PCmpSeqBool :: (n :: Num) -> PCmp (seq n Bool);
PCmpSeqBool (TCNum n) = PCmpWord n;
PCmpSeqBool TCInf = { cmp = errorCmp (Stream Bool) };

PCmpUnit :: PCmp #();
PCmpUnit = { cmp = unitCmp };

PCmpPair :: (a b :: sort 0) -> PCmp a -> PCmp b -> PCmp #(a | b);
PCmpPair a b pa pb = { cmp = pairCmp a b pa.cmp pb.cmp };

PCmpEmpty :: PCmp #{};
PCmpEmpty = { cmp = emptyCmp };

PCmpField :: (s :: String) -> (a b :: sort 0) -> PCmp a -> PCmp b -> PCmp #{ (s) :: a | b };
PCmpField s a b pa pb = { cmp = fieldCmp s a b pa.cmp pb.cmp };

-- SignedCmp class

PSignedCmp :: sort 0 -> sort 0;
PSignedCmp a = #{ scmp :: a -> a -> Bool -> Bool };

PSignedCmpVec :: (n :: Nat) -> (a :: sort 0) -> PSignedCmp a -> PSignedCmp (Vec n a);
PSignedCmpVec n a pa = { scmp = vecCmp n a pa.scmp };

PSignedCmpWord :: (n :: Nat) -> PSignedCmp (Vec n Bool);
PSignedCmpWord n = { scmp = bvSCmp n };

PSignedCmpUnit :: PSignedCmp #();
PSignedCmpUnit = { scmp = unitCmp };

PSignedCmpPair :: (a b :: sort 0) -> PSignedCmp a -> PSignedCmp b -> PSignedCmp #(a | b);
PSignedCmpPair a b pa pb = { scmp = pairCmp a b pa.scmp pb.scmp };

PSignedCmpEmpty :: PSignedCmp #{};
PSignedCmpEmpty = { scmp = emptyCmp };

PSignedCmpField :: (s :: String) -> (a b :: sort 0) -> PSignedCmp a -> PSignedCmp b -> PSignedCmp #{ (s) :: a | b };
PSignedCmpField s a b pa pb = { scmp = fieldCmp s a b pa.scmp pb.scmp };

--------------------------------------------------------------------------------
-- Primitive Cryptol functions

ecDemote :: (val bits :: Num) -> seq bits Bool;
ecDemote valnum bitsnum =
  Num_rec (\ (bits::Num) -> seq bits Bool)
          (\ (bits::Nat) ->
             Num_rec (\ (val::Num) -> Vec bits Bool)
                     (\ (val::Nat) -> bvNat bits val)
                     -- Dummy case (this used to be undefined anyway): treat
                     -- infinity mod 2^bits as 0 (but it doesn't matter)
                     (bvNat bits 0) valnum)
          -- Dummy case (this used to be undefined anyway): return the infinite
          -- stream of 0s (i.e., Falses)
          (streamConst Bool False)
          bitsnum;

ecInteger :: (val :: Num) -> Integer;
ecInteger (TCNum val) = natToInt val;

ecToInteger :: (n :: Num) -> seq n Bool -> Integer;
ecToInteger (TCNum n) = bvToInt n;

ecFromInteger :: (n :: Num) -> Integer -> seq n Bool;
ecFromInteger (TCNum n) = intToBv n;

-- Arith
ecPlus :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecPlus a pa = pa.add;

ecMinus :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMinus a pa = pa.sub;

ecMul :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMul a pa = pa.mul;

ecDiv :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecDiv a pa = pa.div;

ecMod :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMod a pa = pa.mod;

ecExp :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecExp a pa = pa.exp;

ecLg2 :: (a :: sort 0) -> PArith a -> a -> a;
ecLg2 a pa = pa.lg2;

ecNeg :: (a :: sort 0) -> PArith a -> a -> a;
ecNeg a pa = pa.neg;

ecSDiv :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecSDiv a pa = pa.sdiv;

ecSMod :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecSMod a pa = pa.smod;

-- Cmp
ecLt :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecLt a pa x y = pa.cmp x y False;

ecGt :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecGt a pa x y = ecLt a pa y x;

ecLtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecLtEq a pa x y = not (ecLt a pa y x);

ecGtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecGtEq a pa x y = not (ecLt a pa x y);

ecSLt :: (a :: sort 0) -> PSignedCmp a -> a -> a -> Bool;
ecSLt a pa x y = pa.scmp x y False;

ecEq :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecEq a _ = eq a;

ecNotEq :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecNotEq a pa x y = not (ecEq a pa x y);

ecFunEq :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;
ecFunEq a b pb f g x = ecEq b pb (f x) (g x);

ecFunNotEq :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;
ecFunNotEq a b pb f g x = ecNotEq b pb (f x) (g x);

-- Logic
ecAnd :: (a :: sort 0) -> PLogic a -> a -> a -> a;
ecAnd a pa = pa.and;

ecOr :: (a :: sort 0) -> PLogic a -> a -> a -> a;
ecOr a pa = pa.or;

ecXor :: (a :: sort 0) -> PLogic a -> a -> a -> a;
ecXor a pa = pa.xor;

ecCompl :: (a :: sort 0) -> PLogic a -> a -> a;
ecCompl a pa = pa.not;

ecZero :: (a :: sort 0) -> PZero a -> a;
ecZero a pa = pa.zero;

-- Sequences
ecShiftL :: (m n :: Num) -> (a :: sort 0) -> PZero a -> seq m a -> seq n Bool ->
            seq m a;
ecShiftL =
  Num_rec
    (\ (m::Num) -> (n::Num) -> (a :: sort 0) -> PZero a -> seq m a ->
       seq n Bool -> seq m a)
    (\ (m::Nat) ->
       finNumRec
         (\ (n::Num) -> (a :: sort 0) -> PZero a -> Vec m a -> seq n Bool ->
            Vec m a)
         -- Case for (TCNum m, TCNum n)
         (\ (n::Nat) -> \ (a::sort 0) -> \ (pz::PZero a) ->
            bvShiftL m a n (ecZero a pz)))
    (finNumRec
       (\ (n::Num) -> (a::sort 0) -> PZero a -> Stream a -> seq n Bool ->
          Stream a)
       -- Case for (infinity, TCNum n)
       (\ (n::Nat) -> \ (a::sort 0) -> \ (pz::PZero a) ->
          bvStreamShiftL a n));

ecShiftR :: (m n :: Num) -> (a :: sort 0) -> PZero a -> seq m a -> seq n Bool ->
            seq m a;
ecShiftR =
  Num_rec
    (\ (m::Num) -> (n::Num) -> (a :: sort 0) -> PZero a -> seq m a ->
       seq n Bool -> seq m a)
    (\ (m::Nat) ->
       finNumRec
         (\ (n::Num) -> (a :: sort 0) -> PZero a -> Vec m a -> seq n Bool ->
            Vec m a)
         -- Case for (TCNum m, TCNum n)
         (\ (n::Nat) -> \ (a::sort 0) -> \ (pz::PZero a) ->
            bvShiftR m a n (ecZero a pz)))
    (finNumRec
       (\ (n::Num) -> (a::sort 0) -> PZero a -> Stream a -> seq n Bool ->
          Stream a)
       -- Case for (infinity, TCNum n)
       (\ (n::Nat) -> \ (a::sort 0) -> \ (pz::PZero a) ->
          bvStreamShiftR a n (ecZero a pz)));

ecSShiftR :: (n k :: Num) -> seq n Bool -> seq k Bool -> seq n Bool;
ecSShiftR =
  finNumRec
    (\ (n::Num) -> (k::Num) -> seq n Bool -> seq k Bool -> seq n Bool)
    (\ (n::Nat) ->
       finNumRec
         (\ (k::Num) -> Vec n Bool -> seq k Bool -> Vec n Bool)
         -- Case for (TCNum n, TCNum k)
         (\ (k::Nat) ->
            natCase
              (\ (w :: Nat) -> bitvector w -> bitvector k -> bitvector w)
              (\ (x :: bitvector 0) -> \ (i :: bitvector k) -> x)
              (\ (w :: Nat) -> \ (x :: bitvector (Succ w)) ->
               \ (i :: bitvector k) -> bvSShr w x (bvToNat k i))
              n));

ecCarry :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecCarry =
  finNumRec (\ (n::Num) -> seq n Bool -> seq n Bool -> Bool) bvCarry;

ecSCarry :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSCarry =
  finNumRec
    (\ (n::Num) -> seq n Bool -> seq n Bool -> Bool)
    (\ (n::Nat) ->
       natCase
         (\ (w :: Nat) -> bitvector w -> bitvector w -> Bool)
         (\ (_ :: bitvector 0) (_ :: bitvector 0) ->
            error Bool "invalid SCarry instance")
         bvSCarry n);

ecRotL :: (m n :: Num) -> (a :: sort 0) -> seq m a -> seq n Bool ->
          seq m a;
ecRotL =
  finNumRec2
    (\ (m::Num) -> \ (n::Num) -> (a::sort 0) -> seq m a -> seq n Bool -> seq m a)
    (\ (m::Nat) -> \ (n::Nat) -> \ (a::sort 0) -> bvRotateL m a n);


ecRotR :: (m n :: Num) -> (a :: sort 0) -> seq m a -> seq n Bool -> seq m a;
ecRotR =
  finNumRec2
    (\ (m::Num) -> \ (n::Num) -> (a::sort 0) -> seq m a -> seq n Bool -> seq m a)
    (\ (m::Nat) -> \ (n::Nat) -> \ (a::sort 0) -> bvRotateR m a n);

ecCat :: (m n :: Num) -> (a :: sort 0) -> seq m a -> seq n a -> seq (tcAdd m n) a;
ecCat =
  finNumRec
    (\ (m::Num) -> (n::Num) -> (a::sort 0) -> seq m a -> seq n a ->
       seq (tcAdd m n) a)
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> (a::sort 0) -> Vec m a -> seq n a ->
            seq (tcAdd (TCNum m) n) a)
         -- Case for (TCNum m, TCNum n)
         (\ (n::Nat) -> \ (a::sort 0) -> append m n a)
         -- Case for (TCNum m, TCInf)
         (\ (a::sort 0) -> streamAppend a m));

ecSplitAt :: (m n :: Num) -> (a :: sort 0) -> seq (tcAdd m n) a ->
             #(seq m a, seq n a);
ecSplitAt =
  finNumRec
    (\ (m::Num) -> (n::Num) -> (a::sort 0) -> seq (tcAdd m n) a ->
       #(seq m a, seq n a))
    (\ (m::Nat) ->
       Num_rec
         (\ (n::Num) -> (a::sort 0) -> seq (tcAdd (TCNum m) n) a ->
            #(Vec m a, seq n a))
         -- The case (TCNum n, TCNum m)
         (\ (n::Nat) -> \ (a::sort 0) -> \ (xs:: Vec (addNat m n) a) ->
            (take a m n xs, drop a m n xs))
         -- The case (TCNum m, infinity)
         (\ (a::sort 0) -> \ (xs:: Stream a) ->
            (streamTake a m xs, streamDrop a m xs)));

ecJoin :: (m n :: Num) -> (a :: sort 0) -> seq m (seq n a) -> seq (tcMul m n) a;
ecJoin =
  Num_rec
    (\ (m::Num) -> (n::Num) -> (a::sort 0) -> seq m (seq n a) ->
       seq (tcMul m n) a)
    (\ (m::Nat) ->
       finNumRec
         (\ (n::Num) -> (a::sort 0) -> Vec m (seq n a) ->
            seq (tcMul (TCNum m) n) a)
         -- Case for (TCNum m, TCNum n)
         (\ (n::Nat) -> \ (a::sort 0) -> join m n a)
         -- No case for (TCNum m, TCInf)
         )
    (finNumRec
       (\ (n::Num) -> (a::sort 0) -> Stream (seq n a) ->
          seq (tcMul TCInf n) a)
       -- Case for (TCInf, TCNum n)
       (\ (n::Nat) -> \ (a::sort 0) ->
          natCase
            (\ (n'::Nat) -> Stream (Vec n' a) ->
               seq (ite__def Num (equalNat 0 n') (TCNum 0) TCInf) a)
            (\ (s::Stream (Vec 0 a)) -> EmptyVec a)
            (\ (n'::Nat) -> \ (s::Stream (Vec (Succ n') a)) ->
               streamJoin a n' s)
            n)
       -- No case for (TCInf, TCInf)
       );

ecSplit :: (m n :: Num) -> (a :: sort 0) -> seq (tcMul m n) a ->
           seq m (seq n a);
ecSplit =
  Num_rec
    (\ (m::Num) -> (n::Num) -> (a::sort 0) -> seq (tcMul m n) a ->
       seq m (seq n a))
    (\ (m::Nat) ->
       finNumRec
         (\ (n::Num) -> (a::sort 0) -> seq (tcMul (TCNum m) n) a ->
            Vec m (seq n a))
         -- Case for (TCNum m, TCNum n)
         (\ (n::Nat) -> \ (a::sort 0) -> split m n a)
         -- No case for (TCNum m, TCInf)
         )
    (finNumRec
       (\ (n::Num) -> (a::sort 0) -> seq (tcMul TCInf n) a -> Stream (seq n a))
       -- Case for (TCInf, TCNum n)
       (\ (n::Nat) -> \ (a::sort 0) ->
          natCase
            (\ (n'::Nat) ->
               seq (ite__def Num (equalNat 0 n') (TCNum 0) TCInf) a ->
               Stream (Vec n' a))
            (streamConst (Vec 0 a))
            (\ (n'::Nat) -> streamSplit a (Succ n'))
            n));

ecReverse :: (n :: Num) -> (a :: sort 0) -> seq n a -> seq n a;
ecReverse =
  finNumRec
    (\ (n::Num) -> (a::sort 0) -> seq n a -> seq n a) reverse;

ecTranspose :: (m n :: Num) -> (a :: sort 0) -> seq m (seq n a) ->
               seq n (seq m a);
ecTranspose =
  finNumRec2
    (\ (m::Num) -> \ (n::Num) -> (a::sort 0) -> seq m (seq n a) ->
       seq n (seq m a))
    transpose;


ecAt :: (n :: Num) -> (a :: sort 0) -> (i :: Num) -> seq n a -> seq i Bool -> a;
ecAt =
  Num_rec
    (\ (n::Num) -> (a::sort 0) -> (i::Num) -> seq n a -> seq i Bool -> a)
    (\ (n::Nat) -> \ (a::sort 0) ->
       finNumRec
         (\ (i::Num) -> Vec n a -> seq i Bool -> a)
         -- Case for (TCNum n, TCNum i)
         (\ (i::Nat) -> bvAt n a i)
         -- No case for (TCNum n, TCInf)
         )
    (\ (a::sort 0) ->
       finNumRec
         (\ (i::Num) -> Stream a -> seq i Bool -> a)
         -- Case for (TCInf, TCNum i)
         (\ (i::Nat) -> bvStreamGet a i)
         -- No case for (TCNum n, TCInf)
         );

ecAtRange :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> seq n a ->
             seq m (seq i Bool) -> seq m a;
ecAtRange n a m i xs = seqMap (seq i Bool) a m (ecAt n a i xs);

ecAtBack :: (n :: Num) -> (a :: sort 0) -> (i :: Num) -> seq n a ->
            seq i Bool -> a;
ecAtBack n a i xs = ecAt n a i (ecReverse n a xs);

ecAtRangeBack :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> seq n a -> seq m (seq i Bool) -> seq m a;
ecAtRangeBack n a m i xs = seqMap (seq i Bool) a m (ecAtBack n a i xs);


-- Static word sequences
ecFromThen :: (first next bits len :: Num) -> seq len (seq bits Bool);
ecFromThen first next =
  finNumRec
    (\ (bits::Num) -> (len::Num) -> seq len (seq bits Bool))
    (\ (bits::Nat) ->
       finNumRec
         (\ (len::Num) -> seq len (Vec bits Bool))
         (\ (len::Nat) ->
            gen len (Vec bits Bool)
                (\ (i :: Nat) ->
                   bvAdd
                     bits
                     (bvNat bits (getFinNat first))
                     (bvMul bits
                            (bvSub bits (bvNat bits (getFinNat next))
                                   (bvNat bits (getFinNat first)))
                            (bvNat bits i)))));

ecFromTo :: (first last bits :: Num) ->
            seq (tcAdd (TCNum 1) (tcSub last first)) (seq bits Bool);
ecFromTo =
  finNumRec
    (\ (first::Num) -> (last::Num) -> (bits::Num) ->
       seq (tcAdd (TCNum 1) (tcSub last first)) (seq bits Bool))
    (\ (first::Nat) ->
       finNumRec
         (\ (last::Num) -> (bits::Num) ->
            seq (tcAdd (TCNum 1) (tcSub last (TCNum first))) (seq bits Bool))
         (\ (last::Nat) ->
            finNumRec
              (\ (bits::Num) ->
                 Vec (addNat 1 (subNat last first)) (seq bits Bool))
              (\ (bits::Nat) ->
                 gen (addNat 1 (subNat last first)) (Vec bits Bool)
                     (\ (i :: Nat) -> bvNat bits (addNat i first)))));

ecFromThenTo :: (first next last bits len :: Num) -> seq len (seq bits Bool);
ecFromThenTo first next _ =
  finNumRec
    (\ (bits::Num) -> (len::Num) -> seq len (seq bits Bool))
    (\ (bits::Nat) ->
       finNumRec
         (\ (len::Num) -> seq len (Vec bits Bool))
         (\ (len::Nat) ->
            gen len (Vec bits Bool)
                (\ (i :: Nat) ->
                   bvNat bits (subNat (addNat (getFinNat first)
                                              (mulNat i (getFinNat next)))
                                      (mulNat i (getFinNat first))))));

-- Infinite word sequences
ecInfFrom :: (n :: Num) -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFrom =
  finNumRec
    (\ (n::Num) -> seq n Bool -> seq TCInf (seq n Bool))
    (\ (n::Nat) -> \ (w::Vec n Bool) ->
       MkStream (bitvector n) (\ (i :: Nat) -> bvAdd n w (bvNat n i)));

ecInfFromThen :: (n :: Num) -> seq n Bool -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFromThen =
  finNumRec
    (\ (n::Num) -> seq n Bool -> seq n Bool -> seq TCInf (seq n Bool))
    (\ (n::Nat) -> \ (first::Vec n Bool) -> \ (next::Vec n Bool) ->
       MkStream (bitvector n)
                (\ (i :: Nat) ->
                   bvAdd n first (bvMul n (bvSub n next first) (bvNat n i))));


-- Run-time error
primitive cryError :: (a :: sort 0) -> (n :: Nat) -> Vec n (bitvector 8) -> a;

ecError :: (a :: sort 0) -> (len :: Num) -> seq len (bitvector 8) -> a;
ecError a =
  finNumRec
    (\ (len::Num) -> seq len (bitvector 8) -> a)
    (\ (len::Nat) -> cryError a len);

-- Polynomials
ecPMul :: (a b :: Num) -> seq (tcAdd (TCNum 1) a) Bool ->
          seq (tcAdd (TCNum 1) b) Bool ->
          seq (tcAdd (TCNum 1) (tcAdd a b)) Bool;
ecPMul =
 finNumRec2
    (\ (a::Num) -> \ (b::Num) -> seq (tcAdd (TCNum 1) a) Bool ->
       seq (tcAdd (TCNum 1) b) Bool ->
       seq (tcAdd (TCNum 1) (tcAdd a b)) Bool)
    bvPMul;

ecPDiv :: (a b :: Num) -> seq a Bool -> seq b Bool -> seq a Bool;
ecPDiv =
  finNumRec2
    (\ (a::Num) -> \ (b::Num) -> seq a Bool -> seq b Bool -> seq a Bool)
    bvPDiv;

ecPMod :: (a b :: Num) -> seq a Bool -> seq (tcAdd (TCNum 1) b) Bool ->
          seq b Bool;
ecPMod =
  finNumRec2
    (\ (a::Num) -> \ (b :: Num) -> seq a Bool -> seq (tcAdd (TCNum 1) b) Bool ->
       seq b Bool)
    bvPMod;

-- Random values
ecRandom :: (a :: sort 0) -> bitvector 32 -> a;
ecRandom a _ = error a "Cryptol.random";

-- Trace function; simply return the final argument
ecTrace :: (n :: Num) -> (a b :: sort 0) -> seq n (bitvector 8) -> a -> b -> b;
ecTrace _ _ _ _ _ x = x;


--------------------------------------------------------------------------------
-- Extra primitives

-- Array update
ecUpdate :: (n :: Num) -> (a :: sort 0) -> (w :: Num) -> seq n a ->
            seq w Bool -> a -> seq n a;
ecUpdate =
  Num_rec
    (\ (n::Num) -> (a :: sort 0) -> (w :: Num) -> seq n a ->
       seq w Bool -> a -> seq n a)
    (\ (n::Nat) -> \ (a::sort 0) ->
       -- Case for (TCNum n, TCNum w)
       finNumRec
         (\ (w::Num) -> Vec n a -> seq w Bool -> a -> Vec n a)
         (\ (w::Nat) -> bvUpd n a w))
    (\ (a::sort 0) ->
       finNumRec
         (\ (w::Num) -> Stream a -> seq w Bool -> a -> Stream a)
         -- Case for (TCInf, TCNum w)
         (\ (w::Nat) -> bvStreamUpd a w));

ecUpdateEnd :: (n :: Num) -> (a :: sort 0) -> (w :: Num) -> seq n a ->
               seq w Bool -> a -> seq n a;
ecUpdateEnd =
  finNumRec
    (\ (n::Num) -> (a :: sort 0) -> (w :: Num) -> seq n a ->
       seq w Bool -> a -> seq n a)
    (\ (n::Nat) -> \ (a::sort 0) ->
       finNumRec
         (\ (w::Num) -> Vec n a -> seq w Bool -> a -> Vec n a)
         (\ (w::Nat) -> \ (xs::Vec n a) -> \ (i::Vec w Bool) -> \ (y::a) ->
            upd n a xs (subNat (subNat n 1) (bvToNat w i)) y));

-- Bitvector truncation
ecTrunc :: (m n :: Num) -> seq (tcAdd m n) Bool -> seq n Bool;
ecTrunc =
  finNumRec2
    (\ (m::Num) -> \ (n::Num) -> seq (tcAdd m n) Bool -> seq n Bool)
    bvTrunc;

-- Zero extension
ecUExt :: (m n :: Num) -> seq n Bool -> seq (tcAdd m n) Bool;
ecUExt =
  finNumRec2 (\ (m::Num) -> \ (n::Num) -> seq n Bool -> seq (tcAdd m n) Bool)
             bvUExt;

{-
-- Sign extension
ecSExt :: (m n :: Num) -> seq (tcAdd n (TCNum 1)) Bool -> seq (tcAdd m (tcAdd n (TCNum 1))) Bool;
ecSExt (TCNum m) (TCNum n) = bvSExt m n;

-- Signed integer division
ecSDiv :: (n :: Num) -> seq (tcAdd n (TCNum 1)) Bool
  -> seq (tcAdd n (TCNum 1)) Bool -> seq (tcAdd n (TCNum 1)) Bool;
ecSDiv (TCNum n) = bvSDiv n;

-- Signed integer remainder
ecSRem :: (n :: Num) -> seq (tcAdd n (TCNum 1)) Bool
  -> seq (tcAdd n (TCNum 1)) Bool -> seq (tcAdd n (TCNum 1)) Bool;
ecSRem (TCNum n) = bvSRem n;
-}

-- Signed greater-than
ecSgt :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSgt =
  finNumRec (\ (n :: Num) -> seq n Bool -> seq n Bool -> Bool) bvsgt;

-- Signed greater-or-equal
ecSge :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSge =
  finNumRec (\ (n :: Num) -> seq n Bool -> seq n Bool -> Bool) bvsge;

-- Signed less-than
ecSlt :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSlt =
  finNumRec (\ (n :: Num) -> seq n Bool -> seq n Bool -> Bool) bvslt;

-- Signed less-or-equal
ecSle :: (n :: Num) -> seq n Bool -> seq n Bool -> Bool;
ecSle =
  finNumRec (\ (n :: Num) -> seq n Bool -> seq n Bool -> Bool) bvsle;

-- Prelude.bvSShr

--------------------------------------------------------------------------------
-- Rewrite rules

axiom replicate_False :: (n :: Nat) -> Eq (bitvector n) (replicate n Bool False) (bvNat n 0);

axiom subNat_0 :: (n :: Nat) -> Eq Nat (subNat n 0) n;

axiom demote_add_distr
  :: (w :: Nat)
  -> (x y :: Num)
  -> Eq (bitvector w)
        (ecDemote (tcAdd x y) (TCNum w))
        (bvAdd w (ecDemote x (TCNum w)) (ecDemote y (TCNum w)));

--------------------------------------------------------------------------------
