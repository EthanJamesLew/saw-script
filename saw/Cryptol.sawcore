--------------------------------------------------------------------------------
-- Cryptol primitives for SAWCore

module Cryptol where

import Prelude;

--------------------------------------------------------------------------------
-- Additional operations on Prelude types

pairMap :: (a1 b1 a2 b2 :: sort 0) -> (a1 -> b1) -> (a2 -> b2) -> #(a1, a2) -> #(b1, b2);
pairMap _ _ _ _ f g (x, y) = (f x, g y);

pairMap2 :: (a1 b1 c1 a2 b2 c2 :: sort 0) -> (a1 -> b1 -> c1) -> (a2 -> b2 -> c2) -> #(a1, a2) -> #(b1, b2) -> #(c1, c2);
pairMap2 _ _ _ _ _ _ f1 f2 (x1, x2) (y1, y2) = (f1 x1 y1, f2 x2 y2);

compose :: (a b c :: sort 0) -> (b -> c) -> (a -> b) -> (a -> c);
compose _ _ _ f g x = f (g x);

fix :: (a :: sort 0) -> (a -> a) -> a;
fix a f = let { x :: a; x = f x; } in x;

bvExp :: (n :: Nat) -> bitvector n -> bitvector n -> bitvector n;
bvExp n x y = foldr Bool (bitvector n) n
  (\ (b :: Bool) -> \ (a :: bitvector n) ->
    ite (bitvector n) b (bvMul n x (bvMul n a a)) (bvMul n a a))
  (bvNat n 1)
  (reverse n Bool y);

--------------------------------------------------------------------------------
-- Extended natural numbers

data Num :: sort 0 where {
    TCNum :: Nat -> Num;
    TCInf :: Num;
  }

tcWidth :: Num -> Num;
tcWidth (TCNum n) = TCNum (widthNat n);
tcWidth TCInf = TCInf;

tcAdd :: Num -> Num -> Num;
tcAdd (TCNum x) (TCNum y) = TCNum (addNat x y);
tcAdd (TCNum _) TCInf = TCInf;
tcAdd TCInf _ = TCInf;

tcSub :: Num -> Num -> Num;
tcSub (TCNum x) (TCNum y) = TCNum (subNat x y);
tcSub TCInf (TCNum _) = TCInf;
-- other cases are undefined

tcMul :: Num -> Num -> Num;
tcMul (TCNum x) (TCNum y) = TCNum (mulNat x y);
tcMul (TCNum x) TCInf = ite Num (equalNat 0 x) (TCNum 0) TCInf;
tcMul TCInf (TCNum y) = ite Num (equalNat 0 y) (TCNum 0) TCInf;
tcMul TCInf TCInf = TCInf;

tcDiv :: Num -> Num -> Num;
tcDiv (TCNum x) (TCNum y) = TCNum ((divModNat x y).1);
tcDiv (TCNum _) TCInf = TCNum Zero;
-- other cases undefined

tcMod :: Num -> Num -> Num;
tcMod (TCNum x) (TCNum y) = TCNum ((divModNat x y).2);
tcMod (TCNum x) TCInf = TCNum x;
-- other cases undefined

tcExp :: Num -> Num -> Num;
tcExp (TCNum Zero) _ = TCNum Zero;
tcExp (TCNum (Succ Zero)) _ = TCNum (Succ Zero);
tcExp _ (TCNum Zero) = TCNum (Succ Zero);
tcExp (TCNum x) (TCNum y) = TCNum (expNat x y);
-- other cases undefined

tcMin :: Num -> Num -> Num;
tcMin (TCNum x) (TCNum y) = TCNum (minNat x y);
tcMin (TCNum x) TCInf = TCNum x;
tcMin TCInf (TCNum y) = TCNum y;
tcMin TCInf TCInf = TCInf;

tcMax :: Num -> Num -> Num;
tcMax (TCNum x) (TCNum y) = TCNum (maxNat x y);
tcMax (TCNum _) TCInf = TCInf;
tcMax TCInf (TCNum _) = TCInf;
tcMax TCInf TCInf = TCInf;

tcLenFromThen_Nat :: Nat -> Nat -> Nat -> Nat;
tcLenFromThen_Nat x y w =
  tcLenFromThenTo_Nat x y (ite Nat (ltNat x y) (subNat (expNat 2 w) 1) 0);

tcLenFromThenTo_Nat :: Nat -> Nat -> Nat -> Nat;
tcLenFromThenTo_Nat x y z =
  ite Nat (ltNat x y)
    (ite Nat (ltNat z x) 0 (addNat (divNat (subNat z x) (subNat y x)) 1)) -- increasing
    (ite Nat (ltNat x z) 0 (addNat (divNat (subNat x z) (subNat x y)) 1)); -- decreasing

tcLenFromThen :: Num -> Num -> Num -> Num;
tcLenFromThen (TCNum x) (TCNum y) (TCNum w) = TCNum (tcLenFromThen_Nat x y w);
-- tcLenFromThen is undefined on TCInf

tcLenFromThenTo :: Num -> Num -> Num -> Num;
tcLenFromThenTo (TCNum x) (TCNum y) (TCNum z) = TCNum (tcLenFromThenTo_Nat x y z);
-- tcLenFromThenTo is undefined on TCInf

--------------------------------------------------------------------------------
-- Possibly infinite sequences

seq :: Num -> sort 0 -> sort 0;
seq (TCNum n) a = Vec n a;
seq TCInf a = Stream a;

seqMap :: (a b :: sort 0) -> (n :: Num) -> (a -> b) -> seq n a -> seq n b;
seqMap a b (TCNum n) f = map a b f n;
seqMap a b TCInf f = streamMap a b f;

seqConst :: (n :: Num) -> (a :: sort 0) -> a -> seq n a;
seqConst (TCNum n) = replicate n;
seqConst TCInf = streamConst;

--------------------------------------------------------------------------------
-- Types

data KType :: sort 0 where {
    TCBit :: KType;
    TCSeq :: Num -> KType -> KType;
    TCFun :: KType -> KType -> KType;
    TCUnit :: KType;
    TCPair :: KType -> KType -> KType;
    TCEmpty :: KType;
    TCField :: String -> KType -> KType -> KType;
  }

ty :: KType -> sort 0;
ty TCBit = Bool;
ty (TCSeq n a) = seq n (ty a);
ty (TCFun a b) = ty a -> ty b;
ty TCUnit = #();
ty (TCPair a b) = #(ty a | ty b);
ty TCEmpty = #{};
ty (TCField s a b) = #{ (s) :: ty a | ty b };

--------------------------------------------------------------------------------
-- Predicate symbols

data PFin :: Num -> sort 0 where {
    PFinNum :: (n :: Nat) -> PFin (TCNum n);
  }

data PArith :: KType -> sort 0 where {
    PArithWord :: (n :: Num) -> PFin n -> PArith (TCSeq n TCBit);
    PArithSeq :: (n :: Num) -> (a :: KType) -> PArith a -> PArith (TCSeq n a);
    PArithFun :: (a b :: KType) -> PArith b -> PArith (TCFun a b);
    PArithUnit :: PArith TCUnit;
    PArithPair :: (a b :: KType) -> PArith a -> PArith b -> PArith (TCPair a b);
    PArithEmpty :: PArith TCEmpty;
    PArithField :: (s :: String) -> (a b :: KType) -> PArith a -> PArith b -> PArith (TCField s a b);
  }

data PCmp :: KType -> sort 0 where {
    PCmpWord :: (n :: Num) -> PFin n -> PCmp (TCSeq n TCBit);
    PCmpBit :: PCmp TCBit;
    PCmpSeq :: (n :: Num) -> (a :: KType) -> PFin n -> PCmp a -> PCmp (TCSeq n a);
    PCmpUnit :: PCmp TCUnit;
    PCmpPair :: (a b :: KType) -> PCmp a -> PCmp b -> PCmp (TCPair a b);
    PCmpEmpty :: PCmp TCEmpty;
    PCmpField :: (s :: String) -> (a b :: KType) -> PCmp a -> PCmp b -> PCmp (TCField s a b);
  }

-- Partial functions to select instances (terms translated from
-- type-correct Cryptol should never hit the undefined cases)

ePFin :: (n :: Num) -> PFin n;
ePFin (TCNum n) = PFinNum n;
-- ePFin TCInf is undefined

ePArith :: (a :: KType) -> PArith a;
--ePArith TCBit = undefined;
ePArith (TCSeq n TCBit) = PArithWord n (ePFin n);
ePArith (TCSeq n (TCSeq m a)) = PArithSeq n (TCSeq m a) (ePArith (TCSeq m a));
ePArith (TCSeq n (TCFun a b)) = PArithSeq n (TCFun a b) (ePArith (TCFun a b));
ePArith (TCSeq n TCUnit) = PArithSeq n TCUnit (ePArith TCUnit);
ePArith (TCSeq n (TCPair a b)) = PArithSeq n (TCPair a b) (ePArith (TCPair a b));
ePArith (TCSeq n TCEmpty) = PArithSeq n TCEmpty (ePArith TCEmpty);
ePArith (TCSeq n (TCField s a b)) = PArithSeq n (TCField s a b) (ePArith (TCField s a b));
ePArith (TCFun a b) = PArithFun a b (ePArith b);
ePArith TCUnit = PArithUnit;
ePArith (TCPair a b) = PArithPair a b (ePArith a) (ePArith b);
ePArith TCEmpty = PArithEmpty;
ePArith (TCField s a b) = PArithField s a b (ePArith a) (ePArith b);

ePCmp :: (a :: KType) -> PCmp a;
ePCmp (TCSeq n TCBit) = PCmpWord n (ePFin n);
ePCmp (TCSeq n (TCSeq m a)) = PCmpSeq n (TCSeq m a) (ePFin n) (ePCmp (TCSeq m a));
--ePCmp (TCSeq n (TCFun a b)) = PCmpSeq n (TCFun a b) (ePFin n) (ePCmp (TCFun a b));
ePCmp (TCSeq n TCUnit) = PCmpSeq n TCUnit (ePFin n) (ePCmp TCUnit);
ePCmp (TCSeq n (TCPair a b)) = PCmpSeq n (TCPair a b) (ePFin n) (ePCmp (TCPair a b));
ePCmp (TCSeq n TCEmpty) = PCmpSeq n TCEmpty (ePFin n) (ePCmp TCEmpty);
ePCmp (TCSeq n (TCField s a b)) = PCmpSeq n (TCField s a b) (ePFin n) (ePCmp (TCField s a b));
ePCmp TCBit = PCmpBit;
--ePCmp (TCFun a b) = undefined;
ePCmp TCUnit = PCmpUnit;
ePCmp (TCPair a b) = PCmpPair a b (ePCmp a) (ePCmp b);
ePCmp TCEmpty = PCmpEmpty;
ePCmp (TCField s a b) = PCmpField s a b (ePCmp a) (ePCmp b);

--------------------------------------------------------------------------------
-- Auxiliary functions

eListSel :: (a :: sort 0) -> (n :: Num) -> seq n a -> Nat -> a;
eListSel a (TCNum n) xs i = at n a xs i;
eListSel a TCInf xs i = streamGet a xs i;

--------------------------------------------------------------------------------
-- List comprehensions

from :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> (a -> seq n b) -> seq (tcMul m n) #(a, b);
from a b (TCNum m) (TCNum n) =
  \ (xs :: Vec m a) ->
  \ (k :: a -> Vec n b) ->
  join m n #(a, b)
  (map a (Vec n #(a, b))
    (\(x :: a) -> map b #(a, b) (\(y :: b) -> (x, y)) n (k x))
    m xs);

from a b (TCNum m) TCInf =
  natCase
    (\ (m'::Nat) -> (Vec m' a -> (a -> Stream b) ->
        seq (ite Num (equalNat 0 m') (TCNum 0) TCInf) #(a, b)))
      (\ (xs :: Vec 0 a) ->
       \ (k :: a -> Stream b) -> EmptyVec #(a, b))
      (\ (m' :: Nat) ->
       \ (xs :: Vec (Succ m') a) ->
       \ (k :: a -> Stream b) ->
        (\ (x :: a) -> streamMap b #(a, b) (\ (y::b) -> (x, y)) (k x))
        (at (Succ m') a xs 0))
      m;

from a b TCInf (TCNum n) =
  natCase
    (\ (n'::Nat) -> (Stream a -> (a -> Vec n' b) ->
        seq (ite Num (equalNat 0 n') (TCNum 0) TCInf) #(a, b)))
      (\ (xs :: Stream a) ->
       \ (k :: a -> Vec 0 b) -> EmptyVec #(a, b))
      (\ (n' :: Nat) ->
       \ (xs :: Stream a) ->
       \ (k :: a -> Vec (Succ n') b) ->
         streamJoin #(a, b) n'
         (streamMap a (Vec (Succ n') #(a, b))
           (\ (x::a) -> map b #(a, b) (\ (y::b) -> (x, y)) (Succ n') (k x))
           xs))
      n;

from a b TCInf TCInf =
  \ (xs :: Stream a) ->
  \ (k :: a -> Stream b) ->
    (\ (x :: a) -> streamMap b #(a, b) (\ (y :: b) -> (x, y)) (k x))
    (streamGet a xs 0);

mlet :: (a b :: sort 0) -> (n :: Num) -> a -> (a -> seq n b) -> seq n #(a, b);
mlet a b (TCNum n) x f = map b #(a, b) (\(y :: b) -> (x, y)) n (f x);
mlet a b TCInf x f = streamMap b #(a, b) (\(y :: b) -> (x, y)) (f x);

seqZip :: (a b :: sort 0) -> (m n :: Num) -> seq m a -> seq n b -> seq (tcMin m n) #(a, b);
seqZip a b (TCNum m) (TCNum n) xs ys = zip a b m n xs ys;
seqZip a b (TCNum m) TCInf xs ys = gen m #(a, b) (\(i :: Nat) -> (at m a xs i, streamGet b ys i));
seqZip a b TCInf (TCNum n) xs ys = gen n #(a, b) (\(i :: Nat) -> (streamGet a xs i, at n b ys i));
seqZip a b TCInf TCInf xs ys = streamMap2 a b #(a, b) (\(x::a) -> \(y::b) -> (x, y)) xs ys;

--------------------------------------------------------------------------------
-- Arith functions

seqBinary :: (n :: Num) -> (a :: sort 0) -> (a -> a -> a) -> seq n a -> seq n a -> seq n a;
seqBinary (TCNum n) a f = zipWith a a a f n;
seqBinary TCInf a f = streamMap2 a a a f;

unitUnary :: #() -> #();
unitUnary _ = ();

emptyUnary :: #{} -> #{};
emptyUnary _ = {};

unitBinary :: #() -> #() -> #();
unitBinary _ _ = ();

pairUnary :: (a b :: sort 0) -> (a -> a) -> (b -> b) -> #(a | b) -> #(a | b);
pairUnary _ _ f g (x | y) = (f x | g y);

pairBinary :: (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b)
           -> #(a | b) -> #(a | b) -> #(a | b);
pairBinary a b f g (x1 | x2) (y1 | y2) = (f x1 y1 | g x2 y2);

emptyBinary :: #{} -> #{} -> #{};
emptyBinary _ _ = {};

fieldUnary :: (s :: String) -> (a b :: sort 0) -> (a -> a) -> (b -> b)
         -> #{ (s) :: a | b } -> #{ (s) :: a | b };
fieldUnary s _ _ f g { (_) = x | y } = { (s) = f x | g y };

fieldBinary :: (s :: String) -> (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b)
            -> #{ (s) :: a | b } -> #{ (s) :: a | b } -> #{ (s) :: a | b };
fieldBinary s a b f g { (_) = x1 | x2 } { (_) = y1 | y2 } = { (s) = f x1 y1 | g x2 y2 };

funBinary :: (a b :: sort 0) -> (b -> b -> b) -> (a -> b) -> (a -> b) -> (a -> b);
funBinary a b op f g x = op (f x) (g x);

arithUnary :: ((n :: Nat) -> bitvector n -> bitvector n)
           -> (a :: KType) -> PArith a -> ty a -> ty a;
arithUnary bvOp _ (PArithWord _ (PFinNum n)) = bvOp n;
arithUnary bvOp _ (PArithSeq n a pa) = seqMap (ty a) (ty a) n (arithUnary bvOp a pa);
arithUnary bvOp _ (PArithFun a b pb) = compose (ty a) (ty b) (ty b) (arithUnary bvOp b pb);
arithUnary bvOp _ PArithUnit = unitUnary;
arithUnary bvOp _ (PArithPair a b pa pb) =
  pairUnary (ty a) (ty b) (arithUnary bvOp a pa) (arithUnary bvOp b pb);
arithUnary bvOp _ PArithEmpty = emptyUnary;
arithUnary bvOp _ (PArithField s a b pa pb) =
  fieldUnary s (ty a) (ty b) (arithUnary bvOp a pa) (arithUnary bvOp b pb);

arithBinary :: ((n :: Nat) -> bitvector n -> bitvector n -> bitvector n)
            -> (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
arithBinary bvOp _ (PArithWord _ (PFinNum n)) = bvOp n;
arithBinary bvOp _ (PArithSeq n a pa) = seqBinary n (ty a) (arithBinary bvOp a pa);
arithBinary bvOp _ (PArithFun a b pb) = funBinary (ty a) (ty b) (arithBinary bvOp b pb);
arithBinary bvOp _ PArithUnit = unitBinary;
arithBinary bvOp _ (PArithPair a b pa pb) =
  pairBinary (ty a) (ty b) (arithBinary bvOp a pa) (arithBinary bvOp b pb);
arithBinary bvOp _ PArithEmpty = emptyBinary;
arithBinary bvOp _ (PArithField s a b pa pb) =
  fieldBinary s (ty a) (ty b) (arithBinary bvOp a pa) (arithBinary bvOp b pb);

logicBinary :: ((n :: Nat) -> bitvector n -> bitvector n -> bitvector n)
            -> (Bool -> Bool -> Bool)
            -> (a :: KType) -> ty a -> ty a -> ty a;
logicBinary bvOp bitOp TCBit = bitOp;
logicBinary bvOp bitOp (TCFun a b) = funBinary (ty a) (ty b) (logicBinary bvOp bitOp b);
logicBinary bvOp bitOp TCUnit = unitBinary;
logicBinary bvOp bitOp (TCPair a b) =
  pairBinary (ty a) (ty b) (logicBinary bvOp bitOp a) (logicBinary bvOp bitOp b);
logicBinary bvOp bitOp TCEmpty = emptyBinary;
logicBinary bvOp bitOp (TCField s a b) =
  fieldBinary s (ty a) (ty b) (logicBinary bvOp bitOp a) (logicBinary bvOp bitOp b);
logicBinary bvOp bitOp (TCSeq (TCNum n) TCBit) = bvOp n;
logicBinary bvOp bitOp (TCSeq TCInf TCBit) = streamMap2 Bool Bool Bool bitOp;
logicBinary bvOp bitOp (TCSeq n (TCSeq m a)) =
   seqBinary n (seq m (ty a)) (logicBinary bvOp bitOp (TCSeq m a));
logicBinary bvOp bitOp (TCSeq n (TCFun a b)) =
   seqBinary n (ty a -> ty b) (logicBinary bvOp bitOp (TCFun a b));
logicBinary bvOp bitOp (TCSeq n TCUnit) = seqBinary n #() unitBinary;
logicBinary bvOp bitOp (TCSeq n (TCPair a b)) =
   seqBinary n #(ty a | ty b) (logicBinary bvOp bitOp (TCPair a b));
logicBinary bvOp bitOp (TCSeq n TCEmpty) = seqBinary n #{} emptyBinary;
logicBinary bvOp bitOp (TCSeq n (TCField s a b)) =
   seqBinary n (ty (TCField s a b)) (logicBinary bvOp bitOp (TCField s a b));

--------------------------------------------------------------------------------
-- Comparisons

boolCmp :: Bool -> Bool -> Bool -> Bool;
boolCmp x y k = ite Bool x (and y k) (or y k);

bvCmp :: (n :: Nat) -> bitvector n -> bitvector n -> Bool -> Bool;
bvCmp n x y k = or (bvult n x y) (and (bvEq n x y) k);

vecCmp :: (n :: Nat) -> (a :: sort 0) -> (a -> a -> Bool -> Bool)
       -> (Vec n a -> Vec n a -> Bool -> Bool);
vecCmp n a f xs ys k =
  foldr (Bool -> Bool) Bool n (\(f :: Bool -> Bool) -> f) k
    (zipWith a a (Bool -> Bool) f n xs ys);

unitCmp :: #() -> #() -> Bool -> Bool;
unitCmp _ _ _ = False;

emptyCmp :: #{} -> #{} -> Bool -> Bool;
emptyCmp _ _ _ = False;

pairCmp :: (a b :: sort 0) -> (a -> a -> Bool -> Bool) -> (b -> b -> Bool -> Bool)
        -> #(a | b) -> #(a | b) -> Bool -> Bool;
pairCmp a b f g (x1 | x2) (y1 | y2) k = f x1 y1 (g x2 y2 k);

fieldCmp :: (s :: String) -> (a b :: sort 0)
         -> (a -> a -> Bool -> Bool) -> (b -> b -> Bool -> Bool)
         -> #{ (s) :: a | b } -> #{ (s) :: a | b } -> Bool -> Bool;
fieldCmp s a b f g { (_) = x1 | x2 } { (_) = y1 | y2 } k = f x1 y1 (g x2 y2 k);

cmpLt :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool -> Bool;
cmpLt _ (PCmpWord _ (PFinNum n)) = bvCmp n;
cmpLt _ PCmpBit = boolCmp;
cmpLt _ (PCmpSeq _ a (PFinNum n) pa) = vecCmp n (ty a) (cmpLt a pa);
cmpLt _ PCmpUnit = unitCmp;
cmpLt _ (PCmpPair a b pa pb) = pairCmp (ty a) (ty b) (cmpLt a pa) (cmpLt b pb);
cmpLt _ PCmpEmpty = emptyCmp;
cmpLt _ (PCmpField s a b pa pb) = fieldCmp s (ty a) (ty b) (cmpLt a pa) (cmpLt b pb);

--------------------------------------------------------------------------------
-- Primitive Cryptol functions

ecDemote :: (val bits :: Num) -> PFin val -> PFin bits -> seq bits Bool;
ecDemote _ _ (PFinNum val) (PFinNum bits) = bvNat bits val;

-- Arith
ecPlus :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecPlus = arithBinary bvAdd;

ecMinus :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMinus = arithBinary bvSub;

ecMul :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMul = arithBinary bvMul;

ecDiv :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecDiv = arithBinary bvUDiv;

ecMod :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecMod = arithBinary bvURem;

ecExp :: (a :: KType) -> PArith a -> ty a -> ty a -> ty a;
ecExp = arithBinary bvExp;

ecLg2 :: (a :: KType) -> PArith a -> ty a -> ty a;
ecLg2 = arithUnary bvLg2;

ecNeg :: (a :: KType) -> PArith a -> ty a -> ty a;
ecNeg = arithUnary bvNeg;

-- Cmp
ecLt :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecLt a pa x y = cmpLt a pa x y False;

ecGt :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecGt a pa x y = ecLt a pa y x;

ecLtEq  :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecLtEq a pa x y = not (ecLt a pa y x);

ecGtEq  :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecGtEq a pa x y = not (ecLt a pa x y);

ecEq :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecEq a _ = eq (ty a);

ecNotEq :: (a :: KType) -> PCmp a -> ty a -> ty a -> Bool;
ecNotEq a pa x y = not (ecEq a pa x y);

ecFunEq :: (a b :: KType) -> PCmp b -> (ty a -> ty b) -> (ty a -> ty b) -> ty a -> Bool;
ecFunEq a b pb f g x = ecEq b pb (f x) (g x);

ecFunNotEq :: (a b :: KType) -> PCmp b -> (ty a -> ty b) -> (ty a -> ty b) -> ty a -> Bool;
ecFunNotEq a b pb f g x = ecNotEq b pb (f x) (g x);

-- Logic

ecAnd :: (a :: KType) -> ty a -> ty a -> ty a;
ecAnd = logicBinary bvAnd and;

ecOr :: (a :: KType) -> ty a -> ty a -> ty a;
ecOr = logicBinary bvOr or;

ecXor :: (a :: KType) -> ty a -> ty a -> ty a;
ecXor = logicBinary bvXor xor;

ecCompl :: (a :: KType) -> ty a -> ty a;
ecCompl TCBit = not;
ecCompl (TCFun a b) = compose (ty a) (ty b) (ty b) (ecCompl b);
ecCompl TCUnit = unitUnary;
ecCompl (TCPair a b) = pairUnary (ty a) (ty b) (ecCompl a) (ecCompl b);
ecCompl TCEmpty = emptyUnary;
ecCompl (TCField s a b) = fieldUnary s (ty a) (ty b) (ecCompl a) (ecCompl b);
ecCompl (TCSeq (TCNum n) TCBit) = bvNot n;
ecCompl (TCSeq TCInf TCBit) = streamMap Bool Bool not;
ecCompl (TCSeq n (TCSeq m a)) = seqMap (seq m (ty a)) (seq m (ty a)) n (ecCompl (TCSeq m a));
ecCompl (TCSeq n (TCFun a b)) = seqMap (ty a -> ty b) (ty a -> ty b) n (ecCompl (TCFun a b));
ecCompl (TCSeq n TCUnit) = seqMap #() #() n unitUnary;
ecCompl (TCSeq n (TCPair a b)) = seqMap #(ty a | ty b) #(ty a | ty b) n (ecCompl (TCPair a b));
ecCompl (TCSeq n TCEmpty) = seqMap #{} #{} n emptyUnary;
ecCompl (TCSeq n (TCField s a b)) = seqMap (ty (TCField s a b)) (ty (TCField s a b)) n (ecCompl (TCField s a b));

ecZero :: (a :: KType) -> ty a;
ecZero TCBit = False;
ecZero (TCFun a b) = (\(_::ty a) -> ecZero b);
ecZero TCUnit = ();
ecZero (TCPair a b) = (ecZero a | ecZero b);
ecZero TCEmpty = {};
ecZero (TCField s a b) = { (s) = ecZero a | ecZero b };
ecZero (TCSeq (TCNum n) TCBit) = bvNat n 0;
ecZero (TCSeq TCInf TCBit) = streamConst Bool False;
ecZero (TCSeq n (TCSeq m a)) = seqConst n (seq m (ty a)) (ecZero (TCSeq m a));
ecZero (TCSeq n (TCFun a b)) = seqConst n (ty a -> ty b) (ecZero (TCFun a b));
ecZero (TCSeq n TCUnit) = seqConst n #() ();
ecZero (TCSeq n (TCPair a b)) = seqConst n #(ty a | ty b) (ecZero (TCPair a b));
ecZero (TCSeq n TCEmpty) = seqConst n #{} {};
ecZero (TCSeq n (TCField s a b)) = seqConst n #{ (s) :: ty a | ty b } (ecZero (TCField s a b));

-- Sequences
ecShiftL :: (m n :: Num) -> (a :: KType) -> PFin n -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecShiftL (TCNum m) _ a (PFinNum n) = bvShiftL m (ty a) n (ecZero a);
ecShiftL TCInf _ a (PFinNum n) = bvStreamShiftL (ty a) n;

ecShiftR :: (m n :: Num) -> (a :: KType) -> PFin n -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecShiftR (TCNum m) _ a (PFinNum n) = bvShiftR m (ty a) n (ecZero a);
ecShiftR TCInf _ a (PFinNum n) = bvStreamShiftR (ty a) n (ecZero a);

ecRotL :: (m n :: Num) -> (a :: KType) -> PFin m -> PFin n -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecRotL _ _ a (PFinNum m) (PFinNum n) = bvRotateL m (ty a) n;

ecRotR :: (m n :: Num) -> (a :: KType) -> PFin m -> PFin n -> seq m (ty a) -> seq n Bool -> seq m (ty a);
ecRotR _ _ a (PFinNum m) (PFinNum n) = bvRotateR m (ty a) n;

ecCat :: (m n :: Num) -> (a :: KType) -> PFin m -> seq m (ty a) -> seq n (ty a) -> seq (tcAdd m n) (ty a);
ecCat _ (TCNum n) a (PFinNum m) = append m n (ty a);
ecCat _ TCInf a (PFinNum m) = streamAppend (ty a) m;

ecSplitAt :: (m n :: Num) -> (a :: KType) -> PFin m -> seq (tcAdd m n) (ty a) -> #(seq m (ty a), seq n (ty a));
ecSplitAt _ (TCNum n) a (PFinNum m) xs = (take (ty a) m n xs, drop (ty a) m n xs);
ecSplitAt _ TCInf a (PFinNum m) xs = (streamTake (ty a) m xs, streamDrop (ty a) m xs);

ecJoin :: (m n :: Num) -> (a :: KType) -> PFin n -> seq m (seq n (ty a)) -> seq (tcMul m n) (ty a);
ecJoin (TCNum m) _ a (PFinNum n) = join m n (ty a);
ecJoin TCInf _ a (PFinNum n) =
  natCase
    (\ (n'::Nat) -> Stream (Vec n' (ty a)) -> seq (ite Num (equalNat 0 n') (TCNum 0) TCInf) (ty a))
      (\ (s::Stream (Vec 0 (ty a))) -> EmptyVec (ty a))
      (\ (n'::Nat) -> \ (s::Stream (Vec (Succ n') (ty a))) -> streamJoin (ty a) n' s)
      n;

ecSplit :: (m n :: Num) -> (a :: KType) -> PFin n -> seq (tcMul m n) (ty a) -> seq m (seq n (ty a));
ecSplit (TCNum m) _ a (PFinNum n) = split m n (ty a);
ecSplit TCInf _ a (PFinNum n) =
  natCase
  (\(n :: Nat) -> seq (ite Num (equalNat 0 n) (TCNum 0) TCInf) (ty a) -> Stream (Vec n (ty a)))
  (streamConst (Vec 0 (ty a))) (\(n :: Nat) -> streamSplit (ty a) (Succ n)) n;

ecReverse :: (n :: Num) -> (a :: KType) -> PFin n -> seq n (ty a) -> seq n (ty a);
ecReverse _ a (PFinNum n) = reverse n (ty a);

ecTranspose :: (m n :: Num) -> (a :: KType) -> seq m (seq n (ty a)) -> seq n (seq m (ty a));
ecTranspose (TCNum m) (TCNum n) a = transpose m n (ty a);
-- TODO: other cases

ecAt :: (n :: Num) -> (a :: KType) -> (i :: Num) -> PFin i -> seq n (ty a) -> seq i Bool -> ty a;
ecAt (TCNum n) a _ (PFinNum i) = bvAt n (ty a) i;
ecAt TCInf a _ (PFinNum i) = bvStreamGet (ty a) i;

ecAtRange :: (n :: Num) -> (a :: KType) -> (m i :: Num) -> PFin i -> seq n (ty a) -> seq m (seq i Bool) -> seq m (ty a);
ecAtRange n a m i pi xs = seqMap (seq i Bool) (ty a) m (ecAt n a i pi xs);

ecAtBack :: (n :: Num) -> (a :: KType) -> (i :: Num) -> PFin n -> PFin i -> seq n (ty a) -> seq i Bool -> ty a;
ecAtBack n a i pn pi xs = ecAt n a i pi (ecReverse n a pn xs);

ecAtRangeBack :: (n :: Num) -> (a :: KType) -> (m i :: Num) -> PFin n -> PFin i -> seq n (ty a) -> seq m (seq i Bool) -> seq m (ty a);
ecAtRangeBack n a m i pn pi xs = seqMap (seq i Bool) (ty a) m (ecAtBack n a i pn pi xs);

-- Static word sequences
ecFromThen :: (first next bits len :: Num) -> PFin first -> PFin next -> PFin bits
           -> seq len (seq bits Bool);
ecFromThen _ _ _ (TCNum len) (PFinNum first) (PFinNum next) (PFinNum bits) =
  gen len (Vec bits Bool)
    (\(i :: Nat) -> bvAdd bits (bvNat bits first)
                          (bvMul bits (bvSub bits (bvNat bits next) (bvNat bits first))
			              (bvNat bits i)));

ecFromTo :: (first last bits :: Num) -> PFin last -> PFin bits
         -> seq (tcAdd (TCNum 1) (tcSub last first)) (seq bits Bool);
ecFromTo (TCNum first) _ _ (PFinNum last) (PFinNum bits) =
  gen (addNat 1 (subNat last first)) (Vec bits Bool)
    (\(i :: Nat) -> bvNat bits (addNat i first));

ecFromThenTo :: (first next last bits len :: Num) -> PFin first -> PFin next -> PFin last -> PFin bits
             -> seq len (seq bits Bool);
ecFromThenTo _ _ _ _ (TCNum len) (PFinNum first) (PFinNum next) _ (PFinNum bits) =
  gen len (Vec bits Bool)
    (\(i :: Nat) ->
      bvNat bits (subNat (addNat first (mulNat i next)) (mulNat i first)));

-- Infinite word sequences
ecInfFrom :: (n :: Num) -> PFin n -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFrom _ (PFinNum n) w = MkStream (bitvector n) (\(i :: Nat) -> bvAdd n w (bvNat n i));

ecInfFromThen :: (n :: Num) -> PFin n -> seq n Bool -> seq n Bool -> seq TCInf (seq n Bool);
ecInfFromThen _ (PFinNum n) first next =
  MkStream (bitvector n) (\(i :: Nat) ->
    bvAdd n first (bvMul n (bvSub n next first) (bvNat n i)));

-- Run-time error
primitive ecError :: (a :: KType) -> (len :: Num) -> PFin len -> seq len (bitvector 8) -> ty a;

-- Polynomials
ecPMul :: (a b :: Num) -> PFin a -> PFin b -> seq a Bool -> seq b Bool
       -> seq (tcSub (tcMax (TCNum 1) (tcAdd a b)) (TCNum 1)) Bool;
ecPMul _ _ (PFinNum a) (PFinNum b) = bvPMul a b;

ecPDiv :: (a b :: Num) -> PFin a -> PFin b
       -> seq a Bool -> seq b Bool -> seq a Bool;
ecPDiv _ _ (PFinNum a) (PFinNum b) = bvPDiv a b;

ecPMod :: (a b :: Num) -> PFin a -> PFin b
       -> seq a Bool -> seq (tcAdd (TCNum 1) b) Bool -> seq b Bool;
ecPMod _ _ (PFinNum a) (PFinNum b) = bvPMod a b;

-- Random values
primitive ecRandom :: (a :: KType) -> bitvector 32 -> ty a;


--------------------------------------------------------------------------------
-- Rewrite rules

axiom replicate_False :: (n :: Nat) -> Eq (bitvector n) (replicate n Bool False) (bvNat n 0);

axiom unsafeCoerce_same :: (a :: sort 0) -> (x :: a) -> Eq a (unsafeCoerce a a x) x;

axiom subNat_0 :: (n :: Nat) -> Eq Nat (subNat n 0) n;

-- TODO: implement these rules more generally with conversions:
axiom subNat_5_1 :: Eq Nat (subNat 5 1) 4;
axiom widthNat_4 :: Eq Nat (widthNat 4) 3;
axiom widthNat_5 :: Eq Nat (widthNat 5) 3;

--------------------------------------------------------------------------------
