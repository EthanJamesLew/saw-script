enable_experimental;
env <- heapster_init_env "interp" "interp.bc";

/***
 *** Types
 ***/

// Integer types
heapster_define_perm env "int64" " " "llvmptr 64" "exists x:bv 64.eq(llvmword(x))";
heapster_define_perm env "int32" " " "llvmptr 32" "exists x:bv 32.eq(llvmword(x))";
heapster_define_perm env "int8" " " "llvmptr 8" "exists x:bv 8.eq(llvmword(x))";
heapster_define_perm env "int1" " " "llvmptr 1" "exists x:bv 1.eq(llvmword(x))";

heapster_define_llvmshape env "u64" 64 "" "fieldsh(int64<>)";
heapster_define_llvmshape env "u32" 64 "" "fieldsh(32,int32<>)";
heapster_define_llvmshape env "u8" 64 "" "fieldsh(8,int8<>)";

heapster_define_llvmshape env "usize" 64 "" "fieldsh(int64<>)";
heapster_define_llvmshape env "char" 64 "" "fieldsh(32,int32<>)";

// bool type
heapster_define_llvmshape env "bool" 64 "" "fieldsh(1,int1<>)";

// Box type
heapster_define_llvmshape env "Box" 64 "T:llvmshape 64" "ptrsh(T)";

// The Option type
heapster_define_rust_type env "pub enum Option<X> { None, Some (X) }";

// Result type
heapster_define_rust_type env "pub enum Result<X,Y> { Ok (X), Err (Y) }";

// The String type
heapster_define_llvmshape env "String" 64 ""
  "exsh cap:bv 64. ptrsh(arraysh(<cap,*1,fieldsh(8,int8<>))); \
                 \ fieldsh(int64<>);fieldsh(eq(llvmword(cap)))";

// Opaque type for Vec<T>
heapster_define_opaque_llvmshape env "Vec" 64
  "T:llvmshape 64" "24"
  "\\ (T:sort 0) -> List T";

// Iter type: we define this as a sequence of two LLVM values, which have opaque
// permissions; this allows Iter to be laid out as a pair of LLVM values while
// still having an opaque "view" of those values
heapster_define_opaque_perm env "Iter_fld1" "T:llvmshape 64"
  "llvmptr 64" "\\ (T:sort 0) -> List T";
heapster_define_opaque_perm env "Iter_fld2" "" "llvmptr 64" "#()";
heapster_define_llvmshape env "Iter" 64 "l:lifetime, T:llvmshape 64"
  "fieldsh(Iter_fld1<T>);fieldsh(Iter_fld2<>)";

// Rev type: A simple wrapper around a type, so we define it for real
heapster_define_rust_type env "pub struct Rev<T> { iter: T, }";

// Var type
heapster_define_rust_type env "pub struct Var(String);";

// FunName type
heapster_define_rust_type env "pub struct FunName(String);";

// PrimOp2 type
heapster_define_rust_type env
  "pub enum PrimOp2 { AddOp, MulOp }";

heapster_define_rust_type env
  "pub enum Expr { \
    \ LitExpr(u64), \
    \ VarExpr(Var), \
    \ Apply2Expr(PrimOp2, Box<Expr>, Box<Expr>) }";

heapster_define_rust_type env
  "pub enum Stmt { \
    \ Return(Var), \
    \ Skip, \
    \ Assign(Var,Expr), \
    \ IfStmt(Expr,Box<Stmt>,Box<Stmt>), \
    \ WhileStmt(Expr,Box<Stmt>), \
    \ CallStmt(FunName, Vec<Expr>) }";

heapster_define_rust_type env
  "pub enum Error { \
   \ UnboundVar(Var), \
   \ UnknownFun(FunName), \
   \ Unimplemented, \
   \ WrongNumberOfArgs, }";

heapster_define_rust_type env
  "pub struct FunDef (Vec<Var>,Stmt);";

heapster_define_rust_type env
  "pub struct Env { var_map: Vec<(Var, u64)>, \
                  \ fun_map: Vec<(FunName, FunDef)>, }";


/***
 *** Assumed Functions
 ***/

// llvm.uadd.with.overflow.i64
heapster_assume_fun env "llvm.uadd.with.overflow.i64"
  "(). arg0:int64<>, arg1:int64<> -o ret:struct(int64<>,int1<>)"
  "\\ (x y:Vec 64 Bool) -> \
    \ returnM (Vec 64 Bool * Vec 1 Bool) (bvAdd 64 x y, single Bool (bvCarry 64 x y))";

// llvm.expect.i1
heapster_assume_fun env "llvm.expect.i1"
  "().arg0:int1<>, arg1:int1<> -o ret:int1<>" "\\ (x y:Vec 1 Bool) -> returnM (Vec 1 Bool) x";


// memcpy
heapster_assume_fun env "llvm.memcpy.p0i8.p0i8.i64"
  "(rw:rwmodality, l1:lifetime, l2:lifetime, sh:llvmshape 64, \
   \ b:llvmblock 64, len:bv 64). \
  \ arg0:[l1]memblock(W,0,len,sh), arg1:[l2]memblock(rw,0,len,eqsh(len,b)), \
  \ arg2:eq(llvmword(len)) -o \
  \ arg0:[l1]memblock(W,0,len,eqsh(len,b)), arg1:[l2]memblock(rw,0,len,eqsh(len,b))"
  "\\ (X:sort 0) (len:Vec 64 Bool) (x:X) (_:#()) -> returnM (#() * #()) ((),())";

// Var::clone
var_clone_sym <- heapster_find_symbol env
  "$LT$interp..Var$u20$as$u20$core..clone..Clone$GT$5clone";
heapster_assume_fun_rename_prim env var_clone_sym "var_clone"
  "<'a> fn (x:&'a Var) -> Var";

// Vec<(Var, Value)>::deref
vec_var_deref_sym <- heapster_find_symbol_with_type env
  "core..ops..deref..Deref$GT$5deref"
  "{ [0 x { %Var, i64 }]*, i64 }(%\"alloc::vec::Vec<(Var, u64)>\"*)";
heapster_assume_fun_rename_prim env vec_var_deref_sym "vec_var_deref"
  "<'a> fn (&'a Vec<(Var, u64)>) -> &'a[(Var, u64)]";

// &[(Var, Value)]::iter
slice_var_iter_sym <- heapster_find_symbol_with_type env
  "core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter"
  "{ i64*, i64* }([0 x { %Var, i64 }]*, i64)";
heapster_assume_fun_rename_prim env slice_var_iter_sym "slice_var_iter"
  "<'a> fn (&'a[(Var, u64)]) -> Iter<'a, (Var, u64)>";

// NOTE: Unfortunately there are two symbols with the same type for rev,
// so we need to just use the full hash for searching
// Iter<'a, (Var, Value)>::rev
/*
iter_var_rev_sym <- heapster_find_symbol env
  "core4iter6traits8iterator8Iterator3rev17h4b2583a4d05f0facE";
heapster_assume_fun_rename_prim env iter_var_rev_sym "iter_var_rev"
  "<'a> fn (Iter<'a, (Var, u64)>) -> Rev<Iter<'a, (Var, u64)>>";
*/

// Vec<(Var, Value)>::new
vec_new_sym <- heapster_find_symbol env "Vec$LT$T$GT$3new";
heapster_assume_fun_rename_prim env vec_new_sym "vec_new"
  "<> fn () -> Vec<(Var, u64)>";

// Vec<(Var, Value)>::push
vec_push_sym <- heapster_find_symbol env "4push";
heapster_assume_fun_rename_prim env vec_push_sym "vec_push"
  "<'a> fn(&'a mut Vec<(Var, u64)>, (Var, u64))";

// Vec<(FunName, FunDef)>::clone
vec_clone_sym <- heapster_find_symbol_with_type env
  "core..clone..Clone$GT$5clone"
  "void(%\"alloc::vec::Vec<(FunName, FunDef)>\"*, %\"alloc::vec::Vec<(FunName, FunDef)>\"*)";
heapster_assume_fun_rename_prim env vec_clone_sym "vec_clone"
  "<'a> fn (&'a Vec<(FunName, FunDef)>) -> Vec<(FunName, FunDef)>";

// Vec<(FunName, FunDef)>::deref
vec_fun_deref_sym <- heapster_find_symbol_with_type env
  "core..ops..deref..Deref$GT$5deref"
  "{ [0 x { %FunName, %FunDef }]*, i64 }(%\"alloc::vec::Vec<(FunName, FunDef)>\"*)";
heapster_assume_fun_rename_prim env vec_fun_deref_sym "vec_fun_deref"
  "<'a> fn (&'a Vec<(FunName, FunDef)>) -> &'a[(FunName, FunDef)]";

// &[(FunName, FunDef)]::iter
slice_fun_iter_sym <- heapster_find_symbol_with_type env
  "core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter"
  "{ i64*, i64* }([0 x { %FunName, %FunDef }]*, i64)";
heapster_assume_fun_rename_prim env slice_fun_iter_sym "slice_fun_iter"
  "<'a> fn (&'a[(FunName, FunDef)]) -> Iter<'a, (FunName, FunDef)>";

// NOTE: Unfortunately there are two symbols with the same type for rev,
// so we need to just use the full hash for searching
// Iter<'a, (FunName, FunDef)>::rev
/*
iter_fun_rev_sym <- heapster_find_symbol env
  "core4iter6traits8iterator8Iterator3rev17h221acc9c965305cbE";
heapster_assume_fun_rename_prim env iter_fun_rev_sym "iter_fun_rev"
  "<'a> fn (Iter<'a, (FunName, FunDef)>) -> Rev<Iter<'a, (FunName, FunDef)>>";
*/

// TODO: Are these lifetimes right?
// &Var::eq
var_eq_sym <- heapster_find_symbol_with_type env
  "PartialEq$LT$$RF$B$GT$$u20$for$u20$$RF$A$GT$2eq"
  "i1(%Var**, %Var**)";
heapster_assume_fun_rename_prim env var_eq_sym "var_eq"
  "<'a, 'b, 'c> fn (&'b&'a Var, &'c&'a Var) -> bool";

// TODO: Are these lifetimes right?
// &FunName::eq
fun_eq_sym <- heapster_find_symbol_with_type env
  "PartialEq$LT$$RF$B$GT$$u20$for$u20$$RF$A$GT$2eq"
  "i1(%FunName**, %FunName**)";
heapster_assume_fun_rename_prim env fun_eq_sym "fun_eq"
  "<'a, 'b, 'c> fn (&'b&'a FunName, &'c&'a FunName) -> bool";

// Result<u64, Error>::drop_in_place
res_drop_in_place_sym <- heapster_find_symbol_with_type env
  "core3ptr68drop_in_place$LT$core..result..Result$LT$u64$C$interp..Error"
  "void(%\"core::result::Result<u64, Error>\"*)";
heapster_assume_fun_rename_prim env res_drop_in_place_sym "res_drop_in_place"
  "<> fn(Result<u64, Error>)";

/***
 *** Type-checked Functions
 ***/

fresh_env_from_env_sym <- heapster_find_symbol env "18fresh_env_from_env";
heapster_typecheck_fun_rename env fresh_env_from_env_sym "fresh_env_from_env"
  "<'a> fn (&'a Env) -> Env";

// TODO: See above note on the `eq` implementation
ref_ref_eq_var_sym <- heapster_find_symbol_with_type env
  "10ref_ref_eq"
  "i1(%Var*, %Var**)";
heapster_typecheck_fun_rename env ref_ref_eq_var_sym "ref_ref_eq_var"
  "<'a, 'b, 'c> fn (&'a Var, &'b&'c Var) -> bool";

// TODO: See above note on the `eq` implementation
ref_ref_eq_fun_sym <- heapster_find_symbol_with_type env
  "10ref_ref_eq"
  "i1(%FunName*, %FunName**)";
heapster_typecheck_fun_rename env ref_ref_eq_fun_sym "ref_ref_eq_fun"
  "<'a, 'b, 'c> fn (&'a FunName, &'b&'c FunName) -> bool";

env_lookup_sym <- heapster_find_symbol env "10env_lookup17";
heapster_typecheck_fun_rename env env_lookup_sym "env_lookup"
  "<'a,'b> fn (env : &'a Env, x : &'b Var) -> Result<u64,Error>";

env_update_sym <- heapster_find_symbol env "10env_update";
heapster_typecheck_fun_rename env env_update_sym "env_update"
  "<'a,'b> fn (&'a mut Env, &'b Var, u64)";

fun_lookup_sym <- heapster_find_symbol env "10fun_lookup17";
heapster_typecheck_fun_rename env fun_lookup_sym "fun_lookup"
  "<'a, 'b> fn (&'a Env, &'b FunName) -> Result<&'a FunDef, Error>";

eval_primop2_sym <- heapster_find_symbol env "12eval_primop2";
heapster_typecheck_fun_rename env eval_primop2_sym "eval_primop2"
  "<'a> fn (&'a PrimOp2, u64, u64) -> u64";

eval_expr_sym <- heapster_find_symbol env "9eval_expr";
heapster_typecheck_fun_rename env eval_expr_sym "eval_expr"
  "<'a, 'b> fn(&'a Env, &'b Expr) -> Result<u64, Error>";

eval_stmt_sym <- heapster_find_symbol env "9eval_stmt";
heapster_typecheck_fun_rename env eval_stmt_sym "eval_stmt"
  "<'a, 'b> fn (&'a mut Env, &'b Stmt) -> Result<u64, Error>";

/***
 *** Export to Coq
 ***/

heapster_export_coq env "interp_gen.v";
