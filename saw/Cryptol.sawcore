--------------------------------------------------------------------------------
-- Cryptol primitives for SAWCore

module Cryptol where

import Prelude;

--------------------------------------------------------------------------------
-- Additional operations on type Nat

widthNat :: Nat -> Nat;
subNat :: Nat -> Nat -> Nat;

--------------------------------------------------------------------------------
-- Extended natural numbers

data Num :: sort 0 where {
    TCNum :: Nat -> Num;
    TCInf :: Num;
  }

tcWidth :: Num -> Num;
tcWidth (TCNum n) = TCNum (widthNat n);
tcWidth TCInf = TCInf;

tcLg2 :: Num -> Num;

tcAdd :: Num -> Num -> Num;
tcAdd (TCNum x) (TCNum y) = TCNum (addNat x y);
tcAdd (TCNum _) TCInf = TCInf;
tcAdd TCInf _ = TCInf;

tcSub :: Num -> Num -> Num;
tcSub (TCNum x) (TCNum y) = TCNum (subNat x y);
-- TODO: other cases

tcMul :: Num -> Num -> Num;
tcMul (TCNum x) (TCNum y) = TCNum (mulNat x y);
tcMul (TCNum x) TCInf = ite Num (equalNat 0 x) (TCNum 0) TCInf;
tcMul TCInf (TCNum y) = ite Num (equalNat 0 y) (TCNum 0) TCInf;
tcMul TCInf TCInf = TCInf;

tcDiv :: Num -> Num -> Num;
tcMod :: Num -> Num -> Num;
tcExp :: Num -> Num -> Num;

tcMin :: Num -> Num -> Num;
tcMin (TCNum x) (TCNum y) = TCNum (minNat x y);
tcMin (TCNum x) TCInf = TCNum x;
tcMin TCInf (TCNum y) = TCNum y;
tcMin TCInf TCInf = TCInf;

tcMax :: Num -> Num -> Num;

tcLenFromThen :: Num -> Num -> Num -> Num;
tcLenFromThenTo :: Num -> Num -> Num -> Num;

--------------------------------------------------------------------------------
-- Possibly unbounded sequence indexes

data Index :: Num -> sort 0 where {
    IndexNum :: (n :: Nat) -> Fin n -> Index (TCNum n);
    IndexInf :: Nat -> Index TCInf;
  }

unIndexNum :: (n :: Nat) -> Index (TCNum n) -> Fin n;
unIndexNum _ (IndexNum _ i) = i;

unIndexInf :: Index TCInf -> Nat;
unIndexInf (IndexInf i) = i;

indexMinL :: (m n :: Num) -> Index (tcMin m n) -> Index m;
--indexMinL (TCNum m) (TCNum n) i = ...
indexMinL (TCNum m) TCInf i = i;
indexMinL TCInf (TCNum n) i = IndexInf (finFront n (unIndexNum n i));
indexMinL TCInf TCInf i = i;

indexMinR :: (m n :: Num) -> Index (tcMin m n) -> Index n;
--indexMinR (TCNum m) (TCNum n) i = ...
indexMinR (TCNum m) TCInf i = IndexInf (finFront m (unIndexNum m i));
indexMinR TCInf (TCNum n) i = i;
indexMinR TCInf TCInf i = i;

indexSplit :: (m n :: Num) -> Index (tcMul m n) -> #(Index m, Index n);

indexFst :: (m n :: Num) -> Index (tcMul m n) -> Index m;
indexFst (TCNum m) (TCNum n) i = IndexNum m (finFst m n (unIndexNum (mulNat m n) i));
-- TODO: more cases

indexSnd :: (m n :: Num) -> Index (tcMul m n) -> Index n;
indexSnd (TCNum m) (TCNum n) i = IndexNum n (finSnd m n (unIndexNum (mulNat m n) i));
-- TODO: more cases

--------------------------------------------------------------------------------
-- Possibly infinite sequences

data Seq :: Num -> sort 0 -> sort 0 where {
    SeqNum :: (n :: Nat) -> (a :: sort 0) -> Vec n a -> Seq (TCNum n) a;
    SeqInf :: (a :: sort 0) -> (Nat -> a) -> Seq TCInf a;
  }

unSeqNum :: (n :: Nat) -> (a :: sort 0) -> Seq (TCNum n) a -> Vec n a;
unSeqNum _ _ (SeqNum _ _ v) = v;

unSeqInf :: (a :: sort 0) -> Seq TCInf a -> Nat -> a;
unSeqInf _ (SeqInf _ f) = f;

make :: (n :: Num) -> (a :: sort 0) -> (Index n -> a) -> Seq n a;
make (TCNum n) a f = SeqNum n a (Prelude.generate n a (\(i :: Fin n) -> f (IndexNum n i)));
make TCInf a f = SeqInf a (\(i :: Nat) -> f (IndexInf i));

peek :: (n :: Num) -> (a :: sort 0) -> Seq n a -> Index n -> a;
peek (TCNum n) a v i = Prelude.get n a (unSeqNum n a v) (unIndexNum n i);
peek TCInf a v i = unSeqInf a v (unIndexInf i);

bvToSeq :: (n :: Nat) -> bitvector n -> Seq (TCNum n) Bool;
bvToSeq n x = SeqNum n Bool x;

bvOfSeq :: (n :: Nat) -> Seq (TCNum n) Bool -> bitvector n;
bvOfSeq n x = unSeqNum n Bool x;

--------------------------------------------------------------------------------
-- Predicate symbols

PEqual :: Num -> Num -> sort 0;
PNeq   :: Num -> Num -> sort 0;
PGeq   :: Num -> Num -> sort 0;

data PFin :: Num -> sort 0 where {
    PFinNum :: (n :: Nat) -> PFin (TCNum n);
  }

pfinWidth :: (n :: Num) -> PFin n -> PFin (tcWidth n);
pfinWidth _ (PFinNum n) = PFinNum (widthNat n);

pfinSub :: (m n :: Num) -> PFin m -> PFin n -> PFin (tcSub m n);
pfinSub _ _ (PFinNum m) (PFinNum n) = PFinNum (subNat m n);

-- PHas Selector

data PArith :: sort 0 -> sort 0 where {
    PArithWord :: (n :: Num) -> PFin n -> PArith (Seq n Bool);
    PArithSeq :: (n :: Num) -> (a :: sort 0) -> PArith a -> PArith (Seq n a);
    PArithPair :: (a b :: sort 0) -> PArith a -> PArith b -> PArith #(a, b);
  }

data PCmp :: sort 0 -> sort 0 where {
    PCmpBit :: PCmp Bool;
    PCmpSeq :: (n :: Num) -> (a :: sort 0) -> PFin n -> PCmp a -> PCmp (Seq n a);
    PCmpPair :: (a b :: sort 0) -> PCmp a -> PCmp b -> PCmp #(a, b);
  }

theNat :: (m :: Num) -> PFin m -> Nat;
--theNat _ (Instance_PFin_TCNum n) = n;

theVec :: (m :: Num) -> (a :: sort 0) -> (p :: PFin m) -> Seq m a -> Vec (theNat m p) a;
--theVec _ a (Instance_PFin_TCNum n) xs = vecOfSeq a n xs;

--------------------------------------------------------------------------------
-- Auxiliary functions

eProofApp :: (a :: sort 0) -> a;
eCast :: (a b :: sort 0) -> a -> b;

eList :: (a :: sort 0) -> (n :: Nat) -> Vec n a -> Seq (TCNum n) a;
eList a n v = SeqNum n a v;

eListSel :: (a :: sort 0) -> (n :: Num) -> Seq n a -> Nat -> a;
eIf :: (a :: sort 0) -> Bool -> a -> a -> a;

--------------------------------------------------------------------------------
-- List comprehensions

-- TODO: use Prelude one
uncurry :: (a b c :: sort 0) -> (a -> b -> c) -> (#(a, b) -> c);
uncurry a b c f = (\(x :: #(a, b)) -> f (x.1) (x.2));

from :: (a b :: sort 0) -> (m n :: Num) -> Seq m a -> (a -> Seq n b) -> Seq (tcMul m n) #(a, b);
from a b m n xs f =
  make (tcMul m n) #(a, b)
    (\(i :: Index (tcMul m n)) ->
      (peek m a xs (indexFst m n i),
       peek n b (f (peek m a xs (indexFst m n i))) (indexSnd m n i)));

single :: (a :: sort 0) -> a -> Seq (TCNum 1) a;
single a x = make (TCNum 1) a (\(i :: Index (TCNum 1)) -> x);

mlet :: (a b :: sort 0) -> (n :: Num) -> a -> (a -> Seq n b) -> Seq n #(a, b);
mlet a b n x f = make n #(a, b) (\(i :: Index n) -> (x, peek n b (f x) i));

zip :: (a b :: sort 0) -> (m n :: Num) -> Seq m a -> Seq n b -> Seq (tcMin m n) #(a, b);
zip a b m n xs ys =
  make (tcMin m n) #(a, b)
    (\(i :: Index (tcMin m n)) ->
      (peek m a xs (indexMinL m n i), peek n b ys (indexMinR m n i)));

map :: (a b :: sort 0) -> (n :: Num) -> (a -> b) -> Seq n a -> Seq n b;
map a b n f xs = make n b (\(i :: Index n) -> f (peek n a xs i));

--------------------------------------------------------------------------------
-- Arith functions

bvBinary :: (n :: Nat) -> (bitvector n -> bitvector n -> bitvector n)
  -> Seq (TCNum n) Bool -> Seq (TCNum n) Bool -> Seq (TCNum n) Bool;
bvBinary n f xs ys = bvToSeq n (f (bvOfSeq n xs) (bvOfSeq n ys));

seqBinary :: (n :: Num) -> (a :: sort 0) -> (a -> a -> a) -> Seq n a -> Seq n a -> Seq n a;
seqBinary n a f xs ys = make n a (\(i :: Index n) -> f (peek n a xs i) (peek n a ys i));

pairBinary :: (a b :: sort 0) -> (a -> a -> a) -> (b -> b -> b) -> #(a, b) -> #(a, b) -> #(a, b);
pairBinary a b f g x y = (f x.1 y.1, g x.2 y.2);

arithBinary :: ((n :: Nat) -> bitvector n -> bitvector n -> bitvector n)
         -> (a :: sort 0) -> PArith a -> a -> a -> a;
arithBinary bvOp _ (PArithWord _ (PFinNum n)) = bvBinary n (bvOp n);
arithBinary bvOp _ (PArithSeq n a pa) = seqBinary n a (arithBinary bvOp a pa);
arithBinary bvOp _ (PArithPair a b pa pb) =
  pairBinary a b (arithBinary bvOp a pa) (arithBinary bvOp b pb);

--------------------------------------------------------------------------------
-- Primitive Cryptol functions

ecDemote :: (val bits :: Num) -> PFin val -> PFin bits -> PGeq bits (tcWidth val) -> Seq bits Bool;
ecDemote _ _ (PFinNum val) (PFinNum bits) _ = bvToSeq bits (bvNat bits val);

-- Arith
ecPlus  :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecPlus = arithBinary bvAdd;

ecMinus :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMinus = arithBinary bvSub;

ecMul :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMul = arithBinary bvMul;

ecDiv   :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecMod   :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecExp   :: (a :: sort 0) -> PArith a -> a -> a -> a;
ecLg2   :: (a :: sort 0) -> PArith a -> a -> a;
ecNeg   :: (a :: sort 0) -> PArith a -> a -> a;

-- Cmp
ecLt    :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecGt    :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecLtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecGtEq  :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;

ecEq :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;
ecEq _ PCmpBit = boolEq;
--ecEq _ (PCmpSeq n a pn pa) = allSeq n 
ecEq _ (PCmpPair a b pa pb) =
  (\(x :: #(a, b)) -> \(y :: #(a, b)) -> and (ecEq a pa x.1 y.1) (ecEq b pb x.2 y.2));

ecNotEq :: (a :: sort 0) -> PCmp a -> a -> a -> Bool;

ecFunEq    :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;
ecFunEq a b pb f g x = ecEq b pb (f x) (g x);

ecFunNotEq :: (a b :: sort 0) -> PCmp b -> (a -> b) -> (a -> b) -> a -> Bool;
ecFunNotEq a b pb f g x = ecNotEq b pb (f x) (g x);

ecMin :: (a :: sort 0) -> PCmp a -> a -> a -> a;
ecMax :: (a :: sort 0) -> PCmp a -> a -> a -> a;

-- Logic
ecAnd   :: (a :: sort 0) -> a -> a -> a;
ecOr    :: (a :: sort 0) -> a -> a -> a;
ecXor   :: (a :: sort 0) -> a -> a -> a;
ecCompl :: (a :: sort 0) -> a -> a;
ecZero  :: (a :: sort 0) -> a;

-- Sequences
ecShiftL :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;
ecShiftR :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;
ecRotL   :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;
ecRotR   :: (m n :: Num) -> (a :: sort 0) -> Seq m a -> Seq n Bool -> Seq m a;

ecCat :: (m n :: Num) -> (a :: sort 0) -> PFin m -> Seq m a -> Seq n a -> Seq (tcAdd m n) a;
ecSplitAt :: (m n :: Num) -> (a :: sort 0) -> PFin m -> Seq (tcAdd m n) a -> #(Seq m a, Seq n a);
ecJoin    :: (m n :: Num) -> (a :: sort 0) -> PFin n -> Seq m (Seq n a) -> Seq (tcMul m n) a;
ecSplit   :: (m n :: Num) -> (a :: sort 0) -> PFin n -> Seq (tcMul m n) a -> Seq m (Seq n a);

ecReverse   :: (n :: Num) -> (a :: sort 0) -> PFin n -> Seq n a -> Seq n a;
ecTranspose :: (m n :: Num) -> (a :: sort 0) -> Seq m (Seq n a) -> Seq n (Seq m a);

ecAt :: (n :: Num) -> (a :: sort 0) -> (m :: Num) -> Seq n a -> Seq m Bool -> a;
ecAtRange :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> PFin i -> Seq n a -> Seq m (Seq i Bool) -> Seq m a;
ecAtBack :: (n :: Num) -> (a :: sort 0) -> (m :: Num) -> PFin n -> Seq n a -> Seq m Bool -> a;
ecAtRangeBack :: (n :: Num) -> (a :: sort 0) -> (m i :: Num) -> PFin n -> Seq n a -> Seq m (Seq i Bool) -> Seq m a;

-- Static word sequences
ecFromThen :: (first next bits len :: Num) -> PFin first -> PFin next -> PFin bits
           -> PGeq bits (tcWidth first) -> PGeq bits (tcWidth next)
           -> PEqual (tcLenFromThen first next bits) len
           -> Seq len (Seq bits Bool);

ecFromTo :: (first last bits :: Num) -> PFin last -> PFin bits
         -> PGeq last first -> PGeq bits (tcWidth last)
         -> Seq (tcAdd (TCNum 1) (tcSub last first)) (Seq bits Bool);

-- Infinite word sequences
ecInfFrom :: (n :: Num) -> PFin n -> Seq n Bool -> Seq TCInf (Seq n Bool);
ecInfFrom _ (PFinNum n) (SeqNum _ _ w) =
  SeqInf (Seq (TCNum n) Bool) (\(i :: Nat) -> SeqNum n Bool (bvAdd n w (bvNat n i)));

ecInfFromThen :: (n :: Num) -> PFin n -> Seq n Bool -> Seq n Bool -> Seq TCInf (Seq n Bool);

-- Run-time error
ecError :: (a :: sort 0) -> (len :: Num) -> PFin len -> Seq len (Seq (TCNum 8) Bool) -> a;

-- Polynomials
ecPMul :: (a b :: Num) -> PFin a -> PFin b -> Seq a Bool -> Seq b Bool
       -> Seq (tcSub (tcMax (TCNum 1) (tcAdd a b)) (TCNum 1)) Bool;

ecPDiv :: (a b :: Num) -> PFin a -> PFin b
       -> Seq a Bool -> Seq b Bool -> Seq a Bool;

ecPMod :: (a b :: Num) -> PFin a -> PFin b
       -> Seq a Bool -> Seq (tcAdd (TCNum 1) b) Bool -> Seq b Bool;

-- Random values
ecRandom :: (a :: sort 0) -> Seq (TCNum 32) Bool -> a;


--------------------------------------------------------------------------------
-- Extra functions that appear after rewriting

bvOfSeq_bvToSeq ::
  (n :: Nat) -> (x :: bitvector n) -> Eq (bitvector n) (bvOfSeq n (bvToSeq n x)) x;

peek_make ::
  (n :: Num) -> (a :: sort 0) -> (f :: Index n -> a) -> (i :: Index n)
  -> Eq a (peek n a (make n a f) i) (f i);

--------------------------------------------------------------------------------
-- Rewrite rules


-- Num operations

-- Boolean operations
ecAnd_Bool :: Eq (Bool -> Bool -> Bool) (ecAnd Bool) and;
ecOr_Bool :: Eq (Bool -> Bool -> Bool) (ecOr Bool) or;

-- Bitvector operations
ecCompl_Seq_TCNum_Bool :: (n :: Nat) -> (x :: Seq (TCNum n) Bool)
  -> Eq (Seq (TCNum n) Bool) (ecCompl (Seq (TCNum n) Bool) x) (bvToSeq n (bvNot n (bvOfSeq n x)));

ecEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ecEq (Seq (TCNum n) Bool) p x y) (bvEq n (bvOfSeq n x) (bvOfSeq n y));

ecGtEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ecGtEq (Seq (TCNum n) Bool) p x y) (bvuge n (bvOfSeq n x) (bvOfSeq n y));

ecLt_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ecLt (Seq (TCNum n) Bool) p x y) (bvult n (bvOfSeq n x) (bvOfSeq n y));

ecLtEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ecLtEq (Seq (TCNum n) Bool) p x y) (bvule n (bvOfSeq n x) (bvOfSeq n y));

ecNotEq_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PCmp (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq Bool (ecNotEq (Seq (TCNum n) Bool) p x y) (bvNe n (bvOfSeq n x) (bvOfSeq n y));

ecMinus_Seq_TCNum_Bool :: (n :: Nat) -> (p :: PArith (Seq (TCNum n) Bool)) -> (x y :: Seq (TCNum n) Bool)
  -> Eq (Seq (TCNum n) Bool) (ecMinus (Seq (TCNum n) Bool) p x y) (bvToSeq n (bvSub n (bvOfSeq n x) (bvOfSeq n y)));

ecZero_Seq_TCNum_Bool :: (n :: Nat) -> Eq (Seq (TCNum n) Bool) (ecZero (Seq (TCNum n) Bool)) (bvToSeq n (bvNat n 0));

--

eCast_same :: (a :: sort 0) -> (x :: a) -> Eq a (eCast a a x) x;

Seq_TCNum :: (n :: Nat) -> (a :: sort 0) -> Eq (sort 0) (Seq (TCNum n) a) (Vec n a);
Seq_TCNum_Bool :: (n :: Nat) -> Eq (sort 0) (Seq (TCNum n) Bool) (bitvector n);

subNat_0 :: (n :: Nat) -> Eq Nat (subNat n 0) n;

-- TODO: implement these rules more generally with conversions:
subNat_5_1 :: Eq Nat (subNat 5 1) 4;
widthNat_4 :: Eq Nat (widthNat 4) 3;
widthNat_5 :: Eq Nat (widthNat 5) 3;

--------------------------------------------------------------------------------
