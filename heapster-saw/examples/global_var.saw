enable_experimental;
env <- heapster_init_env "global_var" "global_var.bc";

// Integer types
heapster_define_perm env "int64" " " "llvmptr 64" "exists x:bv 64.eq(llvmword(x))";

// A heapster type for shared data
heapster_define_opaque_perm env "shared_data_eq" "x:bv 64" "unit"
    "\\ (_:Vec 64 Bool) -> UnitType";

// Demonstrates one technique for dealing with global variables and environment
// permissions like locks

// A heapster type for the lock global variable"
heapster_define_opaque_perm env "lock_perm" "x:bv 64" "unit"
    "\\ (_:Vec 64 Bool) -> Bool";

// Need to axiomatize acquire_lock so that it can return an environment
// permission
//
// For now, just assume we can always acquire a lock
heapster_assume_fun_rename_prim env
    "acquire_lock"
    "acquire_lock"
    "(u:unit). u:lock_perm<0> \ 
    \ -o \
    \ ret:int64<>, u:lock_perm<1>";

// Need to axiomatize release_lock so it requires an environment permission
heapster_assume_fun_rename_prim env
    "release_lock"
    "release_lock"
    "(u:unit). u:lock_perm<1> \
    \ -o \
    \ ret:true, u:lock_perm<0>";

// Need to axiomatize write_data because it accesses the global variable
heapster_assume_fun_rename_prim env
    "write_data"
    "write_data"
    "(u:unit). u:lock_perm<1>, arg0:int64<> \
    \ -o \
    \ ret:true, u:lock_perm<1>";

// Need to axiomatize get_data because it accesses the global variable
heapster_assume_fun_rename_prim env
    "get_data"
    "get_data"
    "(u:unit). u:lock_perm<1> \
    \ -o \
    \ ret:int64<>, u:lock_perm<1>";

heapster_typecheck_fun env
    "test"
    "(u:unit). u:lock_perm<0> -o ret:true";


heapster_export_coq env "global_var_gen.v";
